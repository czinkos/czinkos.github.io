"use strict";
(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __defProps = Object.defineProperties;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getOwnPropSymbols = Object.getOwnPropertySymbols;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __propIsEnum = Object.prototype.propertyIsEnumerable;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues = (a2, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp.call(b, prop))
        __defNormalProp(a2, prop, b[prop]);
    if (__getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(b)) {
        if (__propIsEnum.call(b, prop))
          __defNormalProp(a2, prop, b[prop]);
      }
    return a2;
  };
  var __spreadProps = (a2, b) => __defProps(a2, __getOwnPropDescs(b));
  var __objRest = (source, exclude) => {
    var target = {};
    for (var prop in source)
      if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
        target[prop] = source[prop];
    if (source != null && __getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(source)) {
        if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
          target[prop] = source[prop];
      }
    return target;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // node_modules/eventemitter3/index.js
  var require_eventemitter3 = __commonJS({
    "node_modules/eventemitter3/index.js"(exports, module) {
      "use strict";
      var has = Object.prototype.hasOwnProperty;
      var prefix = "~";
      function Events() {
      }
      if (Object.create) {
        Events.prototype = /* @__PURE__ */ Object.create(null);
        if (!new Events().__proto__)
          prefix = false;
      }
      function EE(fn, context2, once) {
        this.fn = fn;
        this.context = context2;
        this.once = once || false;
      }
      function addListener(emitter, event, fn, context2, once) {
        if (typeof fn !== "function") {
          throw new TypeError("The listener must be a function");
        }
        var listener = new EE(fn, context2 || emitter, once), evt = prefix ? prefix + event : event;
        if (!emitter._events[evt])
          emitter._events[evt] = listener, emitter._eventsCount++;
        else if (!emitter._events[evt].fn)
          emitter._events[evt].push(listener);
        else
          emitter._events[evt] = [emitter._events[evt], listener];
        return emitter;
      }
      function clearEvent(emitter, evt) {
        if (--emitter._eventsCount === 0)
          emitter._events = new Events();
        else
          delete emitter._events[evt];
      }
      function EventEmitter() {
        this._events = new Events();
        this._eventsCount = 0;
      }
      EventEmitter.prototype.eventNames = function eventNames() {
        var names = [], events, name;
        if (this._eventsCount === 0)
          return names;
        for (name in events = this._events) {
          if (has.call(events, name))
            names.push(prefix ? name.slice(1) : name);
        }
        if (Object.getOwnPropertySymbols) {
          return names.concat(Object.getOwnPropertySymbols(events));
        }
        return names;
      };
      EventEmitter.prototype.listeners = function listeners(event) {
        var evt = prefix ? prefix + event : event, handlers = this._events[evt];
        if (!handlers)
          return [];
        if (handlers.fn)
          return [handlers.fn];
        for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
          ee[i] = handlers[i].fn;
        }
        return ee;
      };
      EventEmitter.prototype.listenerCount = function listenerCount(event) {
        var evt = prefix ? prefix + event : event, listeners = this._events[evt];
        if (!listeners)
          return 0;
        if (listeners.fn)
          return 1;
        return listeners.length;
      };
      EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt])
          return false;
        var listeners = this._events[evt], len = arguments.length, args, i;
        if (listeners.fn) {
          if (listeners.once)
            this.removeListener(event, listeners.fn, void 0, true);
          switch (len) {
            case 1:
              return listeners.fn.call(listeners.context), true;
            case 2:
              return listeners.fn.call(listeners.context, a1), true;
            case 3:
              return listeners.fn.call(listeners.context, a1, a2), true;
            case 4:
              return listeners.fn.call(listeners.context, a1, a2, a3), true;
            case 5:
              return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
            case 6:
              return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
          }
          for (i = 1, args = new Array(len - 1); i < len; i++) {
            args[i - 1] = arguments[i];
          }
          listeners.fn.apply(listeners.context, args);
        } else {
          var length = listeners.length, j;
          for (i = 0; i < length; i++) {
            if (listeners[i].once)
              this.removeListener(event, listeners[i].fn, void 0, true);
            switch (len) {
              case 1:
                listeners[i].fn.call(listeners[i].context);
                break;
              case 2:
                listeners[i].fn.call(listeners[i].context, a1);
                break;
              case 3:
                listeners[i].fn.call(listeners[i].context, a1, a2);
                break;
              case 4:
                listeners[i].fn.call(listeners[i].context, a1, a2, a3);
                break;
              default:
                if (!args)
                  for (j = 1, args = new Array(len - 1); j < len; j++) {
                    args[j - 1] = arguments[j];
                  }
                listeners[i].fn.apply(listeners[i].context, args);
            }
          }
        }
        return true;
      };
      EventEmitter.prototype.on = function on(event, fn, context2) {
        return addListener(this, event, fn, context2, false);
      };
      EventEmitter.prototype.once = function once(event, fn, context2) {
        return addListener(this, event, fn, context2, true);
      };
      EventEmitter.prototype.removeListener = function removeListener(event, fn, context2, once) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt])
          return this;
        if (!fn) {
          clearEvent(this, evt);
          return this;
        }
        var listeners = this._events[evt];
        if (listeners.fn) {
          if (listeners.fn === fn && (!once || listeners.once) && (!context2 || listeners.context === context2)) {
            clearEvent(this, evt);
          }
        } else {
          for (var i = 0, events = [], length = listeners.length; i < length; i++) {
            if (listeners[i].fn !== fn || once && !listeners[i].once || context2 && listeners[i].context !== context2) {
              events.push(listeners[i]);
            }
          }
          if (events.length)
            this._events[evt] = events.length === 1 ? events[0] : events;
          else
            clearEvent(this, evt);
        }
        return this;
      };
      EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
        var evt;
        if (event) {
          evt = prefix ? prefix + event : event;
          if (this._events[evt])
            clearEvent(this, evt);
        } else {
          this._events = new Events();
          this._eventsCount = 0;
        }
        return this;
      };
      EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
      EventEmitter.prototype.addListener = EventEmitter.prototype.on;
      EventEmitter.prefixed = prefix;
      EventEmitter.EventEmitter = EventEmitter;
      if ("undefined" !== typeof module) {
        module.exports = EventEmitter;
      }
    }
  });

  // node_modules/earcut/src/earcut.js
  var require_earcut = __commonJS({
    "node_modules/earcut/src/earcut.js"(exports, module) {
      "use strict";
      module.exports = earcut;
      module.exports.default = earcut;
      function earcut(data, holeIndices, dim) {
        dim = dim || 2;
        var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = linkedList(data, 0, outerLen, dim, true), triangles = [];
        if (!outerNode || outerNode.next === outerNode.prev)
          return triangles;
        var minX, minY, maxX, maxY, x3, y3, invSize;
        if (hasHoles)
          outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
        if (data.length > 80 * dim) {
          minX = maxX = data[0];
          minY = maxY = data[1];
          for (var i = dim; i < outerLen; i += dim) {
            x3 = data[i];
            y3 = data[i + 1];
            if (x3 < minX)
              minX = x3;
            if (y3 < minY)
              minY = y3;
            if (x3 > maxX)
              maxX = x3;
            if (y3 > maxY)
              maxY = y3;
          }
          invSize = Math.max(maxX - minX, maxY - minY);
          invSize = invSize !== 0 ? 32767 / invSize : 0;
        }
        earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);
        return triangles;
      }
      function linkedList(data, start2, end, dim, clockwise) {
        var i, last;
        if (clockwise === signedArea(data, start2, end, dim) > 0) {
          for (i = start2; i < end; i += dim)
            last = insertNode(i, data[i], data[i + 1], last);
        } else {
          for (i = end - dim; i >= start2; i -= dim)
            last = insertNode(i, data[i], data[i + 1], last);
        }
        if (last && equals(last, last.next)) {
          removeNode(last);
          last = last.next;
        }
        return last;
      }
      function filterPoints(start2, end) {
        if (!start2)
          return start2;
        if (!end)
          end = start2;
        var p = start2, again;
        do {
          again = false;
          if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
            removeNode(p);
            p = end = p.prev;
            if (p === p.next)
              break;
            again = true;
          } else {
            p = p.next;
          }
        } while (again || p !== end);
        return end;
      }
      function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
        if (!ear)
          return;
        if (!pass && invSize)
          indexCurve(ear, minX, minY, invSize);
        var stop = ear, prev, next;
        while (ear.prev !== ear.next) {
          prev = ear.prev;
          next = ear.next;
          if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
            triangles.push(prev.i / dim | 0);
            triangles.push(ear.i / dim | 0);
            triangles.push(next.i / dim | 0);
            removeNode(ear);
            ear = next.next;
            stop = next.next;
            continue;
          }
          ear = next;
          if (ear === stop) {
            if (!pass) {
              earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
            } else if (pass === 1) {
              ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
              earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
            } else if (pass === 2) {
              splitEarcut(ear, triangles, dim, minX, minY, invSize);
            }
            break;
          }
        }
      }
      function isEar(ear) {
        var a2 = ear.prev, b = ear, c2 = ear.next;
        if (area(a2, b, c2) >= 0)
          return false;
        var ax = a2.x, bx = b.x, cx = c2.x, ay = a2.y, by = b.y, cy = c2.y;
        var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
        var p = c2.next;
        while (p !== a2) {
          if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0)
            return false;
          p = p.next;
        }
        return true;
      }
      function isEarHashed(ear, minX, minY, invSize) {
        var a2 = ear.prev, b = ear, c2 = ear.next;
        if (area(a2, b, c2) >= 0)
          return false;
        var ax = a2.x, bx = b.x, cx = c2.x, ay = a2.y, by = b.y, cy = c2.y;
        var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
        var minZ = zOrder(x0, y0, minX, minY, invSize), maxZ = zOrder(x1, y1, minX, minY, invSize);
        var p = ear.prevZ, n = ear.nextZ;
        while (p && p.z >= minZ && n && n.z <= maxZ) {
          if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a2 && p !== c2 && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0)
            return false;
          p = p.prevZ;
          if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a2 && n !== c2 && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0)
            return false;
          n = n.nextZ;
        }
        while (p && p.z >= minZ) {
          if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a2 && p !== c2 && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0)
            return false;
          p = p.prevZ;
        }
        while (n && n.z <= maxZ) {
          if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a2 && n !== c2 && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0)
            return false;
          n = n.nextZ;
        }
        return true;
      }
      function cureLocalIntersections(start2, triangles, dim) {
        var p = start2;
        do {
          var a2 = p.prev, b = p.next.next;
          if (!equals(a2, b) && intersects(a2, p, p.next, b) && locallyInside(a2, b) && locallyInside(b, a2)) {
            triangles.push(a2.i / dim | 0);
            triangles.push(p.i / dim | 0);
            triangles.push(b.i / dim | 0);
            removeNode(p);
            removeNode(p.next);
            p = start2 = b;
          }
          p = p.next;
        } while (p !== start2);
        return filterPoints(p);
      }
      function splitEarcut(start2, triangles, dim, minX, minY, invSize) {
        var a2 = start2;
        do {
          var b = a2.next.next;
          while (b !== a2.prev) {
            if (a2.i !== b.i && isValidDiagonal(a2, b)) {
              var c2 = splitPolygon(a2, b);
              a2 = filterPoints(a2, a2.next);
              c2 = filterPoints(c2, c2.next);
              earcutLinked(a2, triangles, dim, minX, minY, invSize, 0);
              earcutLinked(c2, triangles, dim, minX, minY, invSize, 0);
              return;
            }
            b = b.next;
          }
          a2 = a2.next;
        } while (a2 !== start2);
      }
      function eliminateHoles(data, holeIndices, outerNode, dim) {
        var queue = [], i, len, start2, end, list;
        for (i = 0, len = holeIndices.length; i < len; i++) {
          start2 = holeIndices[i] * dim;
          end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
          list = linkedList(data, start2, end, dim, false);
          if (list === list.next)
            list.steiner = true;
          queue.push(getLeftmost(list));
        }
        queue.sort(compareX);
        for (i = 0; i < queue.length; i++) {
          outerNode = eliminateHole(queue[i], outerNode);
        }
        return outerNode;
      }
      function compareX(a2, b) {
        return a2.x - b.x;
      }
      function eliminateHole(hole, outerNode) {
        var bridge = findHoleBridge(hole, outerNode);
        if (!bridge) {
          return outerNode;
        }
        var bridgeReverse = splitPolygon(bridge, hole);
        filterPoints(bridgeReverse, bridgeReverse.next);
        return filterPoints(bridge, bridge.next);
      }
      function findHoleBridge(hole, outerNode) {
        var p = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m2;
        do {
          if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
            var x3 = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
            if (x3 <= hx && x3 > qx) {
              qx = x3;
              m2 = p.x < p.next.x ? p : p.next;
              if (x3 === hx)
                return m2;
            }
          }
          p = p.next;
        } while (p !== outerNode);
        if (!m2)
          return null;
        var stop = m2, mx = m2.x, my = m2.y, tanMin = Infinity, tan2;
        p = m2;
        do {
          if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
            tan2 = Math.abs(hy - p.y) / (hx - p.x);
            if (locallyInside(p, hole) && (tan2 < tanMin || tan2 === tanMin && (p.x > m2.x || p.x === m2.x && sectorContainsSector(m2, p)))) {
              m2 = p;
              tanMin = tan2;
            }
          }
          p = p.next;
        } while (p !== stop);
        return m2;
      }
      function sectorContainsSector(m2, p) {
        return area(m2.prev, m2, p.prev) < 0 && area(p.next, m2, m2.next) < 0;
      }
      function indexCurve(start2, minX, minY, invSize) {
        var p = start2;
        do {
          if (p.z === 0)
            p.z = zOrder(p.x, p.y, minX, minY, invSize);
          p.prevZ = p.prev;
          p.nextZ = p.next;
          p = p.next;
        } while (p !== start2);
        p.prevZ.nextZ = null;
        p.prevZ = null;
        sortLinked(p);
      }
      function sortLinked(list) {
        var i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;
        do {
          p = list;
          list = null;
          tail = null;
          numMerges = 0;
          while (p) {
            numMerges++;
            q = p;
            pSize = 0;
            for (i = 0; i < inSize; i++) {
              pSize++;
              q = q.nextZ;
              if (!q)
                break;
            }
            qSize = inSize;
            while (pSize > 0 || qSize > 0 && q) {
              if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                e = p;
                p = p.nextZ;
                pSize--;
              } else {
                e = q;
                q = q.nextZ;
                qSize--;
              }
              if (tail)
                tail.nextZ = e;
              else
                list = e;
              e.prevZ = tail;
              tail = e;
            }
            p = q;
          }
          tail.nextZ = null;
          inSize *= 2;
        } while (numMerges > 1);
        return list;
      }
      function zOrder(x3, y3, minX, minY, invSize) {
        x3 = (x3 - minX) * invSize | 0;
        y3 = (y3 - minY) * invSize | 0;
        x3 = (x3 | x3 << 8) & 16711935;
        x3 = (x3 | x3 << 4) & 252645135;
        x3 = (x3 | x3 << 2) & 858993459;
        x3 = (x3 | x3 << 1) & 1431655765;
        y3 = (y3 | y3 << 8) & 16711935;
        y3 = (y3 | y3 << 4) & 252645135;
        y3 = (y3 | y3 << 2) & 858993459;
        y3 = (y3 | y3 << 1) & 1431655765;
        return x3 | y3 << 1;
      }
      function getLeftmost(start2) {
        var p = start2, leftmost = start2;
        do {
          if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y)
            leftmost = p;
          p = p.next;
        } while (p !== start2);
        return leftmost;
      }
      function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
        return (cx - px) * (ay - py) >= (ax - px) * (cy - py) && (ax - px) * (by - py) >= (bx - px) * (ay - py) && (bx - px) * (cy - py) >= (cx - px) * (by - py);
      }
      function isValidDiagonal(a2, b) {
        return a2.next.i !== b.i && a2.prev.i !== b.i && !intersectsPolygon(a2, b) && (locallyInside(a2, b) && locallyInside(b, a2) && middleInside(a2, b) && (area(a2.prev, a2, b.prev) || area(a2, b.prev, b)) || equals(a2, b) && area(a2.prev, a2, a2.next) > 0 && area(b.prev, b, b.next) > 0);
      }
      function area(p, q, r) {
        return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
      }
      function equals(p1, p2) {
        return p1.x === p2.x && p1.y === p2.y;
      }
      function intersects(p1, q1, p2, q2) {
        var o1 = sign2(area(p1, q1, p2));
        var o2 = sign2(area(p1, q1, q2));
        var o3 = sign2(area(p2, q2, p1));
        var o4 = sign2(area(p2, q2, q1));
        if (o1 !== o2 && o3 !== o4)
          return true;
        if (o1 === 0 && onSegment(p1, p2, q1))
          return true;
        if (o2 === 0 && onSegment(p1, q2, q1))
          return true;
        if (o3 === 0 && onSegment(p2, p1, q2))
          return true;
        if (o4 === 0 && onSegment(p2, q1, q2))
          return true;
        return false;
      }
      function onSegment(p, q, r) {
        return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
      }
      function sign2(num) {
        return num > 0 ? 1 : num < 0 ? -1 : 0;
      }
      function intersectsPolygon(a2, b) {
        var p = a2;
        do {
          if (p.i !== a2.i && p.next.i !== a2.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a2, b))
            return true;
          p = p.next;
        } while (p !== a2);
        return false;
      }
      function locallyInside(a2, b) {
        return area(a2.prev, a2, a2.next) < 0 ? area(a2, b, a2.next) >= 0 && area(a2, a2.prev, b) >= 0 : area(a2, b, a2.prev) < 0 || area(a2, a2.next, b) < 0;
      }
      function middleInside(a2, b) {
        var p = a2, inside = false, px = (a2.x + b.x) / 2, py = (a2.y + b.y) / 2;
        do {
          if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x)
            inside = !inside;
          p = p.next;
        } while (p !== a2);
        return inside;
      }
      function splitPolygon(a2, b) {
        var a22 = new Node(a2.i, a2.x, a2.y), b2 = new Node(b.i, b.x, b.y), an = a2.next, bp = b.prev;
        a2.next = b;
        b.prev = a2;
        a22.next = an;
        an.prev = a22;
        b2.next = a22;
        a22.prev = b2;
        bp.next = b2;
        b2.prev = bp;
        return b2;
      }
      function insertNode(i, x3, y3, last) {
        var p = new Node(i, x3, y3);
        if (!last) {
          p.prev = p;
          p.next = p;
        } else {
          p.next = last.next;
          p.prev = last;
          last.next.prev = p;
          last.next = p;
        }
        return p;
      }
      function removeNode(p) {
        p.next.prev = p.prev;
        p.prev.next = p.next;
        if (p.prevZ)
          p.prevZ.nextZ = p.nextZ;
        if (p.nextZ)
          p.nextZ.prevZ = p.prevZ;
      }
      function Node(i, x3, y3) {
        this.i = i;
        this.x = x3;
        this.y = y3;
        this.prev = null;
        this.next = null;
        this.z = 0;
        this.prevZ = null;
        this.nextZ = null;
        this.steiner = false;
      }
      earcut.deviation = function(data, holeIndices, dim, triangles) {
        var hasHoles = holeIndices && holeIndices.length;
        var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
        var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
        if (hasHoles) {
          for (var i = 0, len = holeIndices.length; i < len; i++) {
            var start2 = holeIndices[i] * dim;
            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
            polygonArea -= Math.abs(signedArea(data, start2, end, dim));
          }
        }
        var trianglesArea = 0;
        for (i = 0; i < triangles.length; i += 3) {
          var a2 = triangles[i] * dim;
          var b = triangles[i + 1] * dim;
          var c2 = triangles[i + 2] * dim;
          trianglesArea += Math.abs(
            (data[a2] - data[c2]) * (data[b + 1] - data[a2 + 1]) - (data[a2] - data[b]) * (data[c2 + 1] - data[a2 + 1])
          );
        }
        return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);
      };
      function signedArea(data, start2, end, dim) {
        var sum = 0;
        for (var i = start2, j = end - dim; i < end; i += dim) {
          sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
          j = i;
        }
        return sum;
      }
      earcut.flatten = function(data) {
        var dim = data[0][0].length, result = { vertices: [], holes: [], dimensions: dim }, holeIndex = 0;
        for (var i = 0; i < data.length; i++) {
          for (var j = 0; j < data[i].length; j++) {
            for (var d = 0; d < dim; d++)
              result.vertices.push(data[i][j][d]);
          }
          if (i > 0) {
            holeIndex += data[i - 1].length;
            result.holes.push(holeIndex);
          }
        }
        return result;
      };
    }
  });

  // node_modules/punycode/punycode.js
  var require_punycode = __commonJS({
    "node_modules/punycode/punycode.js"(exports, module) {
      (function(root2) {
        var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
        var freeModule = typeof module == "object" && module && !module.nodeType && module;
        var freeGlobal = typeof global == "object" && global;
        if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
          root2 = freeGlobal;
        }
        var punycode, maxInt = 2147483647, base = 36, tMin = 1, tMax = 26, skew = 38, damp = 700, initialBias = 72, initialN = 128, delimiter = "-", regexPunycode = /^xn--/, regexNonASCII = /[^\x20-\x7E]/, regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, errors = {
          "overflow": "Overflow: input needs wider integers to process",
          "not-basic": "Illegal input >= 0x80 (not a basic code point)",
          "invalid-input": "Invalid input"
        }, baseMinusTMin = base - tMin, floor = Math.floor, stringFromCharCode = String.fromCharCode, key;
        function error(type2) {
          throw RangeError(errors[type2]);
        }
        function map4(array2, fn) {
          var length = array2.length;
          var result = [];
          while (length--) {
            result[length] = fn(array2[length]);
          }
          return result;
        }
        function mapDomain(string, fn) {
          var parts = string.split("@");
          var result = "";
          if (parts.length > 1) {
            result = parts[0] + "@";
            string = parts[1];
          }
          string = string.replace(regexSeparators, ".");
          var labels = string.split(".");
          var encoded = map4(labels, fn).join(".");
          return result + encoded;
        }
        function ucs2decode(string) {
          var output = [], counter = 0, length = string.length, value, extra;
          while (counter < length) {
            value = string.charCodeAt(counter++);
            if (value >= 55296 && value <= 56319 && counter < length) {
              extra = string.charCodeAt(counter++);
              if ((extra & 64512) == 56320) {
                output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
              } else {
                output.push(value);
                counter--;
              }
            } else {
              output.push(value);
            }
          }
          return output;
        }
        function ucs2encode(array2) {
          return map4(array2, function(value) {
            var output = "";
            if (value > 65535) {
              value -= 65536;
              output += stringFromCharCode(value >>> 10 & 1023 | 55296);
              value = 56320 | value & 1023;
            }
            output += stringFromCharCode(value);
            return output;
          }).join("");
        }
        function basicToDigit(codePoint) {
          if (codePoint - 48 < 10) {
            return codePoint - 22;
          }
          if (codePoint - 65 < 26) {
            return codePoint - 65;
          }
          if (codePoint - 97 < 26) {
            return codePoint - 97;
          }
          return base;
        }
        function digitToBasic(digit, flag) {
          return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
        }
        function adapt(delta, numPoints, firstTime) {
          var k = 0;
          delta = firstTime ? floor(delta / damp) : delta >> 1;
          delta += floor(delta / numPoints);
          for (; delta > baseMinusTMin * tMax >> 1; k += base) {
            delta = floor(delta / baseMinusTMin);
          }
          return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
        }
        function decode(input) {
          var output = [], inputLength = input.length, out, i = 0, n = initialN, bias = initialBias, basic, j, index2, oldi, w, k, digit, t, baseMinusT;
          basic = input.lastIndexOf(delimiter);
          if (basic < 0) {
            basic = 0;
          }
          for (j = 0; j < basic; ++j) {
            if (input.charCodeAt(j) >= 128) {
              error("not-basic");
            }
            output.push(input.charCodeAt(j));
          }
          for (index2 = basic > 0 ? basic + 1 : 0; index2 < inputLength; ) {
            for (oldi = i, w = 1, k = base; ; k += base) {
              if (index2 >= inputLength) {
                error("invalid-input");
              }
              digit = basicToDigit(input.charCodeAt(index2++));
              if (digit >= base || digit > floor((maxInt - i) / w)) {
                error("overflow");
              }
              i += digit * w;
              t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
              if (digit < t) {
                break;
              }
              baseMinusT = base - t;
              if (w > floor(maxInt / baseMinusT)) {
                error("overflow");
              }
              w *= baseMinusT;
            }
            out = output.length + 1;
            bias = adapt(i - oldi, out, oldi == 0);
            if (floor(i / out) > maxInt - n) {
              error("overflow");
            }
            n += floor(i / out);
            i %= out;
            output.splice(i++, 0, n);
          }
          return ucs2encode(output);
        }
        function encode(input) {
          var n, delta, handledCPCount, basicLength, bias, j, m2, q, k, t, currentValue, output = [], inputLength, handledCPCountPlusOne, baseMinusT, qMinusT;
          input = ucs2decode(input);
          inputLength = input.length;
          n = initialN;
          delta = 0;
          bias = initialBias;
          for (j = 0; j < inputLength; ++j) {
            currentValue = input[j];
            if (currentValue < 128) {
              output.push(stringFromCharCode(currentValue));
            }
          }
          handledCPCount = basicLength = output.length;
          if (basicLength) {
            output.push(delimiter);
          }
          while (handledCPCount < inputLength) {
            for (m2 = maxInt, j = 0; j < inputLength; ++j) {
              currentValue = input[j];
              if (currentValue >= n && currentValue < m2) {
                m2 = currentValue;
              }
            }
            handledCPCountPlusOne = handledCPCount + 1;
            if (m2 - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
              error("overflow");
            }
            delta += (m2 - n) * handledCPCountPlusOne;
            n = m2;
            for (j = 0; j < inputLength; ++j) {
              currentValue = input[j];
              if (currentValue < n && ++delta > maxInt) {
                error("overflow");
              }
              if (currentValue == n) {
                for (q = delta, k = base; ; k += base) {
                  t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                  if (q < t) {
                    break;
                  }
                  qMinusT = q - t;
                  baseMinusT = base - t;
                  output.push(
                    stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
                  );
                  q = floor(qMinusT / baseMinusT);
                }
                output.push(stringFromCharCode(digitToBasic(q, 0)));
                bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                delta = 0;
                ++handledCPCount;
              }
            }
            ++delta;
            ++n;
          }
          return output.join("");
        }
        function toUnicode(input) {
          return mapDomain(input, function(string) {
            return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
          });
        }
        function toASCII(input) {
          return mapDomain(input, function(string) {
            return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
          });
        }
        punycode = {
          "version": "1.3.2",
          "ucs2": {
            "decode": ucs2decode,
            "encode": ucs2encode
          },
          "decode": decode,
          "encode": encode,
          "toASCII": toASCII,
          "toUnicode": toUnicode
        };
        if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
          define("punycode", function() {
            return punycode;
          });
        } else if (freeExports && freeModule) {
          if (module.exports == freeExports) {
            freeModule.exports = punycode;
          } else {
            for (key in punycode) {
              punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
            }
          }
        } else {
          root2.punycode = punycode;
        }
      })(exports);
    }
  });

  // node_modules/url/util.js
  var require_util = __commonJS({
    "node_modules/url/util.js"(exports, module) {
      "use strict";
      module.exports = {
        isString: function(arg) {
          return typeof arg === "string";
        },
        isObject: function(arg) {
          return typeof arg === "object" && arg !== null;
        },
        isNull: function(arg) {
          return arg === null;
        },
        isNullOrUndefined: function(arg) {
          return arg == null;
        }
      };
    }
  });

  // node_modules/querystring/decode.js
  var require_decode = __commonJS({
    "node_modules/querystring/decode.js"(exports, module) {
      "use strict";
      function hasOwnProperty(obj, prop) {
        return Object.prototype.hasOwnProperty.call(obj, prop);
      }
      module.exports = function(qs, sep, eq, options) {
        sep = sep || "&";
        eq = eq || "=";
        var obj = {};
        if (typeof qs !== "string" || qs.length === 0) {
          return obj;
        }
        var regexp = /\+/g;
        qs = qs.split(sep);
        var maxKeys = 1e3;
        if (options && typeof options.maxKeys === "number") {
          maxKeys = options.maxKeys;
        }
        var len = qs.length;
        if (maxKeys > 0 && len > maxKeys) {
          len = maxKeys;
        }
        for (var i = 0; i < len; ++i) {
          var x3 = qs[i].replace(regexp, "%20"), idx = x3.indexOf(eq), kstr, vstr, k, v;
          if (idx >= 0) {
            kstr = x3.substr(0, idx);
            vstr = x3.substr(idx + 1);
          } else {
            kstr = x3;
            vstr = "";
          }
          k = decodeURIComponent(kstr);
          v = decodeURIComponent(vstr);
          if (!hasOwnProperty(obj, k)) {
            obj[k] = v;
          } else if (Array.isArray(obj[k])) {
            obj[k].push(v);
          } else {
            obj[k] = [obj[k], v];
          }
        }
        return obj;
      };
    }
  });

  // node_modules/querystring/encode.js
  var require_encode = __commonJS({
    "node_modules/querystring/encode.js"(exports, module) {
      "use strict";
      var stringifyPrimitive = function(v) {
        switch (typeof v) {
          case "string":
            return v;
          case "boolean":
            return v ? "true" : "false";
          case "number":
            return isFinite(v) ? v : "";
          default:
            return "";
        }
      };
      module.exports = function(obj, sep, eq, name) {
        sep = sep || "&";
        eq = eq || "=";
        if (obj === null) {
          obj = void 0;
        }
        if (typeof obj === "object") {
          return Object.keys(obj).map(function(k) {
            var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
            if (Array.isArray(obj[k])) {
              return obj[k].map(function(v) {
                return ks + encodeURIComponent(stringifyPrimitive(v));
              }).join(sep);
            } else {
              return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
            }
          }).join(sep);
        }
        if (!name)
          return "";
        return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));
      };
    }
  });

  // node_modules/querystring/index.js
  var require_querystring = __commonJS({
    "node_modules/querystring/index.js"(exports) {
      "use strict";
      exports.decode = exports.parse = require_decode();
      exports.encode = exports.stringify = require_encode();
    }
  });

  // node_modules/url/url.js
  var require_url = __commonJS({
    "node_modules/url/url.js"(exports) {
      "use strict";
      var punycode = require_punycode();
      var util = require_util();
      exports.parse = urlParse;
      exports.resolve = urlResolve;
      exports.resolveObject = urlResolveObject;
      exports.format = urlFormat;
      exports.Url = Url;
      function Url() {
        this.protocol = null;
        this.slashes = null;
        this.auth = null;
        this.host = null;
        this.port = null;
        this.hostname = null;
        this.hash = null;
        this.search = null;
        this.query = null;
        this.pathname = null;
        this.path = null;
        this.href = null;
      }
      var protocolPattern = /^([a-z0-9.+-]+:)/i;
      var portPattern = /:[0-9]*$/;
      var simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/;
      var delims = ["<", ">", '"', "`", " ", "\r", "\n", "	"];
      var unwise = ["{", "}", "|", "\\", "^", "`"].concat(delims);
      var autoEscape = ["'"].concat(unwise);
      var nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape);
      var hostEndingChars = ["/", "?", "#"];
      var hostnameMaxLen = 255;
      var hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/;
      var hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;
      var unsafeProtocol = {
        "javascript": true,
        "javascript:": true
      };
      var hostlessProtocol = {
        "javascript": true,
        "javascript:": true
      };
      var slashedProtocol = {
        "http": true,
        "https": true,
        "ftp": true,
        "gopher": true,
        "file": true,
        "http:": true,
        "https:": true,
        "ftp:": true,
        "gopher:": true,
        "file:": true
      };
      var querystring = require_querystring();
      function urlParse(url2, parseQueryString, slashesDenoteHost) {
        if (url2 && util.isObject(url2) && url2 instanceof Url)
          return url2;
        var u = new Url();
        u.parse(url2, parseQueryString, slashesDenoteHost);
        return u;
      }
      Url.prototype.parse = function(url2, parseQueryString, slashesDenoteHost) {
        if (!util.isString(url2)) {
          throw new TypeError("Parameter 'url' must be a string, not " + typeof url2);
        }
        var queryIndex = url2.indexOf("?"), splitter = queryIndex !== -1 && queryIndex < url2.indexOf("#") ? "?" : "#", uSplit = url2.split(splitter), slashRegex = /\\/g;
        uSplit[0] = uSplit[0].replace(slashRegex, "/");
        url2 = uSplit.join(splitter);
        var rest = url2;
        rest = rest.trim();
        if (!slashesDenoteHost && url2.split("#").length === 1) {
          var simplePath = simplePathPattern.exec(rest);
          if (simplePath) {
            this.path = rest;
            this.href = rest;
            this.pathname = simplePath[1];
            if (simplePath[2]) {
              this.search = simplePath[2];
              if (parseQueryString) {
                this.query = querystring.parse(this.search.substr(1));
              } else {
                this.query = this.search.substr(1);
              }
            } else if (parseQueryString) {
              this.search = "";
              this.query = {};
            }
            return this;
          }
        }
        var proto = protocolPattern.exec(rest);
        if (proto) {
          proto = proto[0];
          var lowerProto = proto.toLowerCase();
          this.protocol = lowerProto;
          rest = rest.substr(proto.length);
        }
        if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
          var slashes = rest.substr(0, 2) === "//";
          if (slashes && !(proto && hostlessProtocol[proto])) {
            rest = rest.substr(2);
            this.slashes = true;
          }
        }
        if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
          var hostEnd = -1;
          for (var i = 0; i < hostEndingChars.length; i++) {
            var hec = rest.indexOf(hostEndingChars[i]);
            if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
              hostEnd = hec;
          }
          var auth, atSign;
          if (hostEnd === -1) {
            atSign = rest.lastIndexOf("@");
          } else {
            atSign = rest.lastIndexOf("@", hostEnd);
          }
          if (atSign !== -1) {
            auth = rest.slice(0, atSign);
            rest = rest.slice(atSign + 1);
            this.auth = decodeURIComponent(auth);
          }
          hostEnd = -1;
          for (var i = 0; i < nonHostChars.length; i++) {
            var hec = rest.indexOf(nonHostChars[i]);
            if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
              hostEnd = hec;
          }
          if (hostEnd === -1)
            hostEnd = rest.length;
          this.host = rest.slice(0, hostEnd);
          rest = rest.slice(hostEnd);
          this.parseHost();
          this.hostname = this.hostname || "";
          var ipv6Hostname = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
          if (!ipv6Hostname) {
            var hostparts = this.hostname.split(/\./);
            for (var i = 0, l = hostparts.length; i < l; i++) {
              var part = hostparts[i];
              if (!part)
                continue;
              if (!part.match(hostnamePartPattern)) {
                var newpart = "";
                for (var j = 0, k = part.length; j < k; j++) {
                  if (part.charCodeAt(j) > 127) {
                    newpart += "x";
                  } else {
                    newpart += part[j];
                  }
                }
                if (!newpart.match(hostnamePartPattern)) {
                  var validParts = hostparts.slice(0, i);
                  var notHost = hostparts.slice(i + 1);
                  var bit = part.match(hostnamePartStart);
                  if (bit) {
                    validParts.push(bit[1]);
                    notHost.unshift(bit[2]);
                  }
                  if (notHost.length) {
                    rest = "/" + notHost.join(".") + rest;
                  }
                  this.hostname = validParts.join(".");
                  break;
                }
              }
            }
          }
          if (this.hostname.length > hostnameMaxLen) {
            this.hostname = "";
          } else {
            this.hostname = this.hostname.toLowerCase();
          }
          if (!ipv6Hostname) {
            this.hostname = punycode.toASCII(this.hostname);
          }
          var p = this.port ? ":" + this.port : "";
          var h = this.hostname || "";
          this.host = h + p;
          this.href += this.host;
          if (ipv6Hostname) {
            this.hostname = this.hostname.substr(1, this.hostname.length - 2);
            if (rest[0] !== "/") {
              rest = "/" + rest;
            }
          }
        }
        if (!unsafeProtocol[lowerProto]) {
          for (var i = 0, l = autoEscape.length; i < l; i++) {
            var ae = autoEscape[i];
            if (rest.indexOf(ae) === -1)
              continue;
            var esc = encodeURIComponent(ae);
            if (esc === ae) {
              esc = escape(ae);
            }
            rest = rest.split(ae).join(esc);
          }
        }
        var hash = rest.indexOf("#");
        if (hash !== -1) {
          this.hash = rest.substr(hash);
          rest = rest.slice(0, hash);
        }
        var qm = rest.indexOf("?");
        if (qm !== -1) {
          this.search = rest.substr(qm);
          this.query = rest.substr(qm + 1);
          if (parseQueryString) {
            this.query = querystring.parse(this.query);
          }
          rest = rest.slice(0, qm);
        } else if (parseQueryString) {
          this.search = "";
          this.query = {};
        }
        if (rest)
          this.pathname = rest;
        if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
          this.pathname = "/";
        }
        if (this.pathname || this.search) {
          var p = this.pathname || "";
          var s = this.search || "";
          this.path = p + s;
        }
        this.href = this.format();
        return this;
      };
      function urlFormat(obj) {
        if (util.isString(obj))
          obj = urlParse(obj);
        if (!(obj instanceof Url))
          return Url.prototype.format.call(obj);
        return obj.format();
      }
      Url.prototype.format = function() {
        var auth = this.auth || "";
        if (auth) {
          auth = encodeURIComponent(auth);
          auth = auth.replace(/%3A/i, ":");
          auth += "@";
        }
        var protocol = this.protocol || "", pathname = this.pathname || "", hash = this.hash || "", host = false, query = "";
        if (this.host) {
          host = auth + this.host;
        } else if (this.hostname) {
          host = auth + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]");
          if (this.port) {
            host += ":" + this.port;
          }
        }
        if (this.query && util.isObject(this.query) && Object.keys(this.query).length) {
          query = querystring.stringify(this.query);
        }
        var search = this.search || query && "?" + query || "";
        if (protocol && protocol.substr(-1) !== ":")
          protocol += ":";
        if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
          host = "//" + (host || "");
          if (pathname && pathname.charAt(0) !== "/")
            pathname = "/" + pathname;
        } else if (!host) {
          host = "";
        }
        if (hash && hash.charAt(0) !== "#")
          hash = "#" + hash;
        if (search && search.charAt(0) !== "?")
          search = "?" + search;
        pathname = pathname.replace(/[?#]/g, function(match) {
          return encodeURIComponent(match);
        });
        search = search.replace("#", "%23");
        return protocol + host + pathname + search + hash;
      };
      function urlResolve(source, relative) {
        return urlParse(source, false, true).resolve(relative);
      }
      Url.prototype.resolve = function(relative) {
        return this.resolveObject(urlParse(relative, false, true)).format();
      };
      function urlResolveObject(source, relative) {
        if (!source)
          return relative;
        return urlParse(source, false, true).resolveObject(relative);
      }
      Url.prototype.resolveObject = function(relative) {
        if (util.isString(relative)) {
          var rel = new Url();
          rel.parse(relative, false, true);
          relative = rel;
        }
        var result = new Url();
        var tkeys = Object.keys(this);
        for (var tk = 0; tk < tkeys.length; tk++) {
          var tkey = tkeys[tk];
          result[tkey] = this[tkey];
        }
        result.hash = relative.hash;
        if (relative.href === "") {
          result.href = result.format();
          return result;
        }
        if (relative.slashes && !relative.protocol) {
          var rkeys = Object.keys(relative);
          for (var rk = 0; rk < rkeys.length; rk++) {
            var rkey = rkeys[rk];
            if (rkey !== "protocol")
              result[rkey] = relative[rkey];
          }
          if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
            result.path = result.pathname = "/";
          }
          result.href = result.format();
          return result;
        }
        if (relative.protocol && relative.protocol !== result.protocol) {
          if (!slashedProtocol[relative.protocol]) {
            var keys = Object.keys(relative);
            for (var v = 0; v < keys.length; v++) {
              var k = keys[v];
              result[k] = relative[k];
            }
            result.href = result.format();
            return result;
          }
          result.protocol = relative.protocol;
          if (!relative.host && !hostlessProtocol[relative.protocol]) {
            var relPath = (relative.pathname || "").split("/");
            while (relPath.length && !(relative.host = relPath.shift()))
              ;
            if (!relative.host)
              relative.host = "";
            if (!relative.hostname)
              relative.hostname = "";
            if (relPath[0] !== "")
              relPath.unshift("");
            if (relPath.length < 2)
              relPath.unshift("");
            result.pathname = relPath.join("/");
          } else {
            result.pathname = relative.pathname;
          }
          result.search = relative.search;
          result.query = relative.query;
          result.host = relative.host || "";
          result.auth = relative.auth;
          result.hostname = relative.hostname || relative.host;
          result.port = relative.port;
          if (result.pathname || result.search) {
            var p = result.pathname || "";
            var s = result.search || "";
            result.path = p + s;
          }
          result.slashes = result.slashes || relative.slashes;
          result.href = result.format();
          return result;
        }
        var isSourceAbs = result.pathname && result.pathname.charAt(0) === "/", isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === "/", mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname, removeAllDots = mustEndAbs, srcPath = result.pathname && result.pathname.split("/") || [], relPath = relative.pathname && relative.pathname.split("/") || [], psychotic = result.protocol && !slashedProtocol[result.protocol];
        if (psychotic) {
          result.hostname = "";
          result.port = null;
          if (result.host) {
            if (srcPath[0] === "")
              srcPath[0] = result.host;
            else
              srcPath.unshift(result.host);
          }
          result.host = "";
          if (relative.protocol) {
            relative.hostname = null;
            relative.port = null;
            if (relative.host) {
              if (relPath[0] === "")
                relPath[0] = relative.host;
              else
                relPath.unshift(relative.host);
            }
            relative.host = null;
          }
          mustEndAbs = mustEndAbs && (relPath[0] === "" || srcPath[0] === "");
        }
        if (isRelAbs) {
          result.host = relative.host || relative.host === "" ? relative.host : result.host;
          result.hostname = relative.hostname || relative.hostname === "" ? relative.hostname : result.hostname;
          result.search = relative.search;
          result.query = relative.query;
          srcPath = relPath;
        } else if (relPath.length) {
          if (!srcPath)
            srcPath = [];
          srcPath.pop();
          srcPath = srcPath.concat(relPath);
          result.search = relative.search;
          result.query = relative.query;
        } else if (!util.isNullOrUndefined(relative.search)) {
          if (psychotic) {
            result.hostname = result.host = srcPath.shift();
            var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
            if (authInHost) {
              result.auth = authInHost.shift();
              result.host = result.hostname = authInHost.shift();
            }
          }
          result.search = relative.search;
          result.query = relative.query;
          if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
            result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
          }
          result.href = result.format();
          return result;
        }
        if (!srcPath.length) {
          result.pathname = null;
          if (result.search) {
            result.path = "/" + result.search;
          } else {
            result.path = null;
          }
          result.href = result.format();
          return result;
        }
        var last = srcPath.slice(-1)[0];
        var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === "." || last === "..") || last === "";
        var up = 0;
        for (var i = srcPath.length; i >= 0; i--) {
          last = srcPath[i];
          if (last === ".") {
            srcPath.splice(i, 1);
          } else if (last === "..") {
            srcPath.splice(i, 1);
            up++;
          } else if (up) {
            srcPath.splice(i, 1);
            up--;
          }
        }
        if (!mustEndAbs && !removeAllDots) {
          for (; up--; up) {
            srcPath.unshift("..");
          }
        }
        if (mustEndAbs && srcPath[0] !== "" && (!srcPath[0] || srcPath[0].charAt(0) !== "/")) {
          srcPath.unshift("");
        }
        if (hasTrailingSlash && srcPath.join("/").substr(-1) !== "/") {
          srcPath.push("");
        }
        var isAbsolute = srcPath[0] === "" || srcPath[0] && srcPath[0].charAt(0) === "/";
        if (psychotic) {
          result.hostname = result.host = isAbsolute ? "" : srcPath.length ? srcPath.shift() : "";
          var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
          if (authInHost) {
            result.auth = authInHost.shift();
            result.host = result.hostname = authInHost.shift();
          }
        }
        mustEndAbs = mustEndAbs || result.host && srcPath.length;
        if (mustEndAbs && !isAbsolute) {
          srcPath.unshift("");
        }
        if (!srcPath.length) {
          result.pathname = null;
          result.path = null;
        } else {
          result.pathname = srcPath.join("/");
        }
        if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
          result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
        }
        result.auth = relative.auth || result.auth;
        result.slashes = result.slashes || relative.slashes;
        result.href = result.format();
        return result;
      };
      Url.prototype.parseHost = function() {
        var host = this.host;
        var port = portPattern.exec(host);
        if (port) {
          port = port[0];
          if (port !== ":") {
            this.port = port.substr(1);
          }
          host = host.substr(0, host.length - port.length);
        }
        if (host)
          this.hostname = host;
      };
    }
  });

  // node_modules/scrollama/build/scrollama.js
  var require_scrollama = __commonJS({
    "node_modules/scrollama/build/scrollama.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = global2 || self, global2.scrollama = factory());
      })(exports, function() {
        "use strict";
        function selectAll(selector, parent2 = document) {
          if (typeof selector === "string") {
            return Array.from(parent2.querySelectorAll(selector));
          } else if (selector instanceof Element) {
            return [selector];
          } else if (selector instanceof NodeList) {
            return Array.from(selector);
          } else if (selector instanceof Array) {
            return selector;
          }
          return [];
        }
        function create2(className) {
          const el = document.createElement("div");
          el.className = `scrollama__debug-step ${className}`;
          el.style.position = "fixed";
          el.style.left = "0";
          el.style.width = "100%";
          el.style.zIndex = "9999";
          el.style.borderTop = "2px solid black";
          el.style.borderBottom = "2px solid black";
          const p = document.createElement("p");
          p.style.position = "absolute";
          p.style.left = "0";
          p.style.height = "1px";
          p.style.width = "100%";
          p.style.borderTop = "1px dashed black";
          el.appendChild(p);
          document.body.appendChild(el);
          return el;
        }
        function update({ id: id2, step, marginTop }) {
          const { index: index2, height } = step;
          const className = `scrollama__debug-step--${id2}-${index2}`;
          let el = document.querySelector(`.${className}`);
          if (!el)
            el = create2(className);
          el.style.top = `${marginTop * -1}px`;
          el.style.height = `${height}px`;
          el.querySelector("p").style.top = `${height / 2}px`;
        }
        function generateId() {
          const alphabet = "abcdefghijklmnopqrstuvwxyz";
          const date = Date.now();
          const result = [];
          for (let i = 0; i < 6; i += 1) {
            const char = alphabet[Math.floor(Math.random() * alphabet.length)];
            result.push(char);
          }
          return `${result.join("")}${date}`;
        }
        function err$1(msg) {
          console.error(`scrollama error: ${msg}`);
        }
        function getIndex(node) {
          return +node.getAttribute("data-scrollama-index");
        }
        function createProgressThreshold(height, threshold) {
          const count = Math.ceil(height / threshold);
          const t = [];
          const ratio = 1 / count;
          for (let i = 0; i < count + 1; i += 1) {
            t.push(i * ratio);
          }
          return t;
        }
        function parseOffset(x3) {
          if (typeof x3 === "string" && x3.indexOf("px") > 0) {
            const v = +x3.replace("px", "");
            if (!isNaN(v))
              return { format: "pixels", value: v };
            else {
              err("offset value must be in 'px' format. Fallback to 0.5.");
              return { format: "percent", value: 0.5 };
            }
          } else if (typeof x3 === "number" || !isNaN(+x3)) {
            if (x3 > 1)
              err("offset value is greater than 1. Fallback to 1.");
            if (x3 < 0)
              err("offset value is lower than 0. Fallback to 0.");
            return { format: "percent", value: Math.min(Math.max(0, x3), 1) };
          }
          return null;
        }
        function indexSteps(steps) {
          steps.forEach(
            (step) => step.node.setAttribute("data-scrollama-index", step.index)
          );
        }
        function getOffsetTop(node) {
          const { top } = node.getBoundingClientRect();
          const scrollTop = window.pageYOffset;
          const clientTop = document.body.clientTop || 0;
          return top + scrollTop - clientTop;
        }
        let currentScrollY;
        let comparisonScrollY;
        let direction;
        function onScroll(container) {
          const scrollTop = container ? container.scrollTop : window.pageYOffset;
          if (currentScrollY === scrollTop)
            return;
          currentScrollY = scrollTop;
          if (currentScrollY > comparisonScrollY)
            direction = "down";
          else if (currentScrollY < comparisonScrollY)
            direction = "up";
          comparisonScrollY = currentScrollY;
        }
        function setupScroll(container) {
          currentScrollY = 0;
          comparisonScrollY = 0;
          document.addEventListener("scroll", () => onScroll(container));
        }
        function scrollama2() {
          let cb = {};
          let id2 = generateId();
          let steps = [];
          let globalOffset;
          let containerElement;
          let rootElement;
          let progressThreshold = 0;
          let isEnabled = false;
          let isProgress = false;
          let isDebug = false;
          let isTriggerOnce = false;
          let exclude = [];
          function reset() {
            cb = {
              stepEnter: () => {
              },
              stepExit: () => {
              },
              stepProgress: () => {
              }
            };
            exclude = [];
          }
          function handleEnable(shouldEnable) {
            if (shouldEnable && !isEnabled)
              updateObservers();
            if (!shouldEnable && isEnabled)
              disconnectObservers();
            isEnabled = shouldEnable;
          }
          function notifyProgress(element, progress) {
            const index2 = getIndex(element);
            const step = steps[index2];
            if (progress !== void 0)
              step.progress = progress;
            const response = { element, index: index2, progress, direction };
            if (step.state === "enter")
              cb.stepProgress(response);
          }
          function notifyStepEnter(element, check = true) {
            const index2 = getIndex(element);
            const step = steps[index2];
            const response = { element, index: index2, direction };
            step.direction = direction;
            step.state = "enter";
            if (!exclude[index2])
              cb.stepEnter(response);
            if (isTriggerOnce)
              exclude[index2] = true;
          }
          function notifyStepExit(element, check = true) {
            const index2 = getIndex(element);
            const step = steps[index2];
            if (!step.state)
              return false;
            const response = { element, index: index2, direction };
            if (isProgress) {
              if (direction === "down" && step.progress < 1)
                notifyProgress(element, 1);
              else if (direction === "up" && step.progress > 0)
                notifyProgress(element, 0);
            }
            step.direction = direction;
            step.state = "exit";
            cb.stepExit(response);
          }
          function resizeStep([entry]) {
            const index2 = getIndex(entry.target);
            const step = steps[index2];
            const h = entry.target.offsetHeight;
            if (h !== step.height) {
              step.height = h;
              disconnectObserver(step);
              updateStepObserver(step);
              updateResizeObserver(step);
            }
          }
          function intersectStep([entry]) {
            onScroll(containerElement);
            const { isIntersecting, target } = entry;
            if (isIntersecting)
              notifyStepEnter(target);
            else
              notifyStepExit(target);
          }
          function intersectProgress([entry]) {
            const index2 = getIndex(entry.target);
            const step = steps[index2];
            const { isIntersecting, intersectionRatio, target } = entry;
            if (isIntersecting && step.state === "enter")
              notifyProgress(target, intersectionRatio);
          }
          function disconnectObserver({ observers }) {
            Object.keys(observers).map((name) => {
              observers[name].disconnect();
            });
          }
          function disconnectObservers() {
            steps.forEach(disconnectObserver);
          }
          function updateResizeObserver(step) {
            const observer = new ResizeObserver(resizeStep);
            observer.observe(step.node);
            step.observers.resize = observer;
          }
          function updateResizeObservers() {
            steps.forEach(updateResizeObserver);
          }
          function updateStepObserver(step) {
            const h = window.innerHeight;
            const off = step.offset || globalOffset;
            const factor = off.format === "pixels" ? 1 : h;
            const offset = off.value * factor;
            const marginTop = step.height / 2 - offset;
            const marginBottom = step.height / 2 - (h - offset);
            const rootMargin = `${marginTop}px 0px ${marginBottom}px 0px`;
            const root2 = rootElement;
            const threshold = 0.5;
            const options = { rootMargin, threshold, root: root2 };
            const observer = new IntersectionObserver(intersectStep, options);
            observer.observe(step.node);
            step.observers.step = observer;
            if (isDebug)
              update({ id: id2, step, marginTop, marginBottom });
          }
          function updateStepObservers() {
            steps.forEach(updateStepObserver);
          }
          function updateProgressObserver(step) {
            const h = window.innerHeight;
            const off = step.offset || globalOffset;
            const factor = off.format === "pixels" ? 1 : h;
            const offset = off.value * factor;
            const marginTop = -offset + step.height;
            const marginBottom = offset - h;
            const rootMargin = `${marginTop}px 0px ${marginBottom}px 0px`;
            const threshold = createProgressThreshold(step.height, progressThreshold);
            const options = { rootMargin, threshold };
            const observer = new IntersectionObserver(intersectProgress, options);
            observer.observe(step.node);
            step.observers.progress = observer;
          }
          function updateProgressObservers() {
            steps.forEach(updateProgressObserver);
          }
          function updateObservers() {
            disconnectObservers();
            updateResizeObservers();
            updateStepObservers();
            if (isProgress)
              updateProgressObservers();
          }
          const S = {};
          S.setup = ({
            step,
            parent: parent2,
            offset = 0.5,
            threshold = 4,
            progress = false,
            once = false,
            debug = false,
            container = void 0,
            root: root2 = null
          }) => {
            setupScroll(container);
            steps = selectAll(step, parent2).map((node, index2) => ({
              index: index2,
              direction: void 0,
              height: node.offsetHeight,
              node,
              observers: {},
              offset: parseOffset(node.dataset.offset),
              top: getOffsetTop(node),
              progress: 0,
              state: void 0
            }));
            if (!steps.length) {
              err$1("no step elements");
              return S;
            }
            isProgress = progress;
            isTriggerOnce = once;
            isDebug = debug;
            progressThreshold = Math.max(1, +threshold);
            globalOffset = parseOffset(offset);
            containerElement = container;
            rootElement = root2;
            reset();
            indexSteps(steps);
            handleEnable(true);
            return S;
          };
          S.enable = () => {
            handleEnable(true);
            return S;
          };
          S.disable = () => {
            handleEnable(false);
            return S;
          };
          S.destroy = () => {
            handleEnable(false);
            reset();
            return S;
          };
          S.resize = () => {
            updateObservers();
            return S;
          };
          S.offset = (x3) => {
            if (x3 === null || x3 === void 0)
              return globalOffset.value;
            globalOffset = parseOffset(x3);
            updateObservers();
            return S;
          };
          S.onStepEnter = (f) => {
            if (typeof f === "function")
              cb.stepEnter = f;
            else
              err$1("onStepEnter requires a function");
            return S;
          };
          S.onStepExit = (f) => {
            if (typeof f === "function")
              cb.stepExit = f;
            else
              err$1("onStepExit requires a function");
            return S;
          };
          S.onStepProgress = (f) => {
            if (typeof f === "function")
              cb.stepProgress = f;
            else
              err$1("onStepProgress requires a function");
            return S;
          };
          return S;
        }
        return scrollama2;
      });
    }
  });

  // node_modules/lodash/lodash.js
  var require_lodash = __commonJS({
    "node_modules/lodash/lodash.js"(exports, module) {
      (function() {
        var undefined2;
        var VERSION = "4.17.21";
        var LARGE_ARRAY_SIZE = 200;
        var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
        var HASH_UNDEFINED = "__lodash_hash_undefined__";
        var MAX_MEMOIZE_SIZE = 500;
        var PLACEHOLDER = "__lodash_placeholder__";
        var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
        var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
        var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
        var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
        var HOT_COUNT = 800, HOT_SPAN = 16;
        var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
        var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
        var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
        var wrapFlags = [
          ["ary", WRAP_ARY_FLAG],
          ["bind", WRAP_BIND_FLAG],
          ["bindKey", WRAP_BIND_KEY_FLAG],
          ["curry", WRAP_CURRY_FLAG],
          ["curryRight", WRAP_CURRY_RIGHT_FLAG],
          ["flip", WRAP_FLIP_FLAG],
          ["partial", WRAP_PARTIAL_FLAG],
          ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
          ["rearg", WRAP_REARG_FLAG]
        ];
        var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
        var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
        var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
        var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
        var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
        var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
        var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
        var reTrimStart = /^\s+/;
        var reWhitespace = /\s/;
        var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
        var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
        var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
        var reEscapeChar = /\\(\\)?/g;
        var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
        var reFlags = /\w*$/;
        var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
        var reIsBinary = /^0b[01]+$/i;
        var reIsHostCtor = /^\[object .+?Constructor\]$/;
        var reIsOctal = /^0o[0-7]+$/i;
        var reIsUint = /^(?:0|[1-9]\d*)$/;
        var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
        var reNoMatch = /($^)/;
        var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
        var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
        var rsApos = "['\u2019]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
        var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
        var reApos = RegExp(rsApos, "g");
        var reComboMark = RegExp(rsCombo, "g");
        var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
        var reUnicodeWord = RegExp([
          rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
          rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
          rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
          rsUpper + "+" + rsOptContrUpper,
          rsOrdUpper,
          rsOrdLower,
          rsDigits,
          rsEmoji
        ].join("|"), "g");
        var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
        var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
        var contextProps = [
          "Array",
          "Buffer",
          "DataView",
          "Date",
          "Error",
          "Float32Array",
          "Float64Array",
          "Function",
          "Int8Array",
          "Int16Array",
          "Int32Array",
          "Map",
          "Math",
          "Object",
          "Promise",
          "RegExp",
          "Set",
          "String",
          "Symbol",
          "TypeError",
          "Uint8Array",
          "Uint8ClampedArray",
          "Uint16Array",
          "Uint32Array",
          "WeakMap",
          "_",
          "clearTimeout",
          "isFinite",
          "parseInt",
          "setTimeout"
        ];
        var templateCounter = -1;
        var typedArrayTags = {};
        typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
        typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
        var cloneableTags = {};
        cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
        cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
        var deburredLetters = {
          "\xC0": "A",
          "\xC1": "A",
          "\xC2": "A",
          "\xC3": "A",
          "\xC4": "A",
          "\xC5": "A",
          "\xE0": "a",
          "\xE1": "a",
          "\xE2": "a",
          "\xE3": "a",
          "\xE4": "a",
          "\xE5": "a",
          "\xC7": "C",
          "\xE7": "c",
          "\xD0": "D",
          "\xF0": "d",
          "\xC8": "E",
          "\xC9": "E",
          "\xCA": "E",
          "\xCB": "E",
          "\xE8": "e",
          "\xE9": "e",
          "\xEA": "e",
          "\xEB": "e",
          "\xCC": "I",
          "\xCD": "I",
          "\xCE": "I",
          "\xCF": "I",
          "\xEC": "i",
          "\xED": "i",
          "\xEE": "i",
          "\xEF": "i",
          "\xD1": "N",
          "\xF1": "n",
          "\xD2": "O",
          "\xD3": "O",
          "\xD4": "O",
          "\xD5": "O",
          "\xD6": "O",
          "\xD8": "O",
          "\xF2": "o",
          "\xF3": "o",
          "\xF4": "o",
          "\xF5": "o",
          "\xF6": "o",
          "\xF8": "o",
          "\xD9": "U",
          "\xDA": "U",
          "\xDB": "U",
          "\xDC": "U",
          "\xF9": "u",
          "\xFA": "u",
          "\xFB": "u",
          "\xFC": "u",
          "\xDD": "Y",
          "\xFD": "y",
          "\xFF": "y",
          "\xC6": "Ae",
          "\xE6": "ae",
          "\xDE": "Th",
          "\xFE": "th",
          "\xDF": "ss",
          "\u0100": "A",
          "\u0102": "A",
          "\u0104": "A",
          "\u0101": "a",
          "\u0103": "a",
          "\u0105": "a",
          "\u0106": "C",
          "\u0108": "C",
          "\u010A": "C",
          "\u010C": "C",
          "\u0107": "c",
          "\u0109": "c",
          "\u010B": "c",
          "\u010D": "c",
          "\u010E": "D",
          "\u0110": "D",
          "\u010F": "d",
          "\u0111": "d",
          "\u0112": "E",
          "\u0114": "E",
          "\u0116": "E",
          "\u0118": "E",
          "\u011A": "E",
          "\u0113": "e",
          "\u0115": "e",
          "\u0117": "e",
          "\u0119": "e",
          "\u011B": "e",
          "\u011C": "G",
          "\u011E": "G",
          "\u0120": "G",
          "\u0122": "G",
          "\u011D": "g",
          "\u011F": "g",
          "\u0121": "g",
          "\u0123": "g",
          "\u0124": "H",
          "\u0126": "H",
          "\u0125": "h",
          "\u0127": "h",
          "\u0128": "I",
          "\u012A": "I",
          "\u012C": "I",
          "\u012E": "I",
          "\u0130": "I",
          "\u0129": "i",
          "\u012B": "i",
          "\u012D": "i",
          "\u012F": "i",
          "\u0131": "i",
          "\u0134": "J",
          "\u0135": "j",
          "\u0136": "K",
          "\u0137": "k",
          "\u0138": "k",
          "\u0139": "L",
          "\u013B": "L",
          "\u013D": "L",
          "\u013F": "L",
          "\u0141": "L",
          "\u013A": "l",
          "\u013C": "l",
          "\u013E": "l",
          "\u0140": "l",
          "\u0142": "l",
          "\u0143": "N",
          "\u0145": "N",
          "\u0147": "N",
          "\u014A": "N",
          "\u0144": "n",
          "\u0146": "n",
          "\u0148": "n",
          "\u014B": "n",
          "\u014C": "O",
          "\u014E": "O",
          "\u0150": "O",
          "\u014D": "o",
          "\u014F": "o",
          "\u0151": "o",
          "\u0154": "R",
          "\u0156": "R",
          "\u0158": "R",
          "\u0155": "r",
          "\u0157": "r",
          "\u0159": "r",
          "\u015A": "S",
          "\u015C": "S",
          "\u015E": "S",
          "\u0160": "S",
          "\u015B": "s",
          "\u015D": "s",
          "\u015F": "s",
          "\u0161": "s",
          "\u0162": "T",
          "\u0164": "T",
          "\u0166": "T",
          "\u0163": "t",
          "\u0165": "t",
          "\u0167": "t",
          "\u0168": "U",
          "\u016A": "U",
          "\u016C": "U",
          "\u016E": "U",
          "\u0170": "U",
          "\u0172": "U",
          "\u0169": "u",
          "\u016B": "u",
          "\u016D": "u",
          "\u016F": "u",
          "\u0171": "u",
          "\u0173": "u",
          "\u0174": "W",
          "\u0175": "w",
          "\u0176": "Y",
          "\u0177": "y",
          "\u0178": "Y",
          "\u0179": "Z",
          "\u017B": "Z",
          "\u017D": "Z",
          "\u017A": "z",
          "\u017C": "z",
          "\u017E": "z",
          "\u0132": "IJ",
          "\u0133": "ij",
          "\u0152": "Oe",
          "\u0153": "oe",
          "\u0149": "'n",
          "\u017F": "s"
        };
        var htmlEscapes = {
          "&": "&amp;",
          "<": "&lt;",
          ">": "&gt;",
          '"': "&quot;",
          "'": "&#39;"
        };
        var htmlUnescapes = {
          "&amp;": "&",
          "&lt;": "<",
          "&gt;": ">",
          "&quot;": '"',
          "&#39;": "'"
        };
        var stringEscapes = {
          "\\": "\\",
          "'": "'",
          "\n": "n",
          "\r": "r",
          "\u2028": "u2028",
          "\u2029": "u2029"
        };
        var freeParseFloat = parseFloat, freeParseInt = parseInt;
        var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
        var freeSelf = typeof self == "object" && self && self.Object === Object && self;
        var root2 = freeGlobal || freeSelf || Function("return this")();
        var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
        var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
        var moduleExports = freeModule && freeModule.exports === freeExports;
        var freeProcess = moduleExports && freeGlobal.process;
        var nodeUtil = function() {
          try {
            var types = freeModule && freeModule.require && freeModule.require("util").types;
            if (types) {
              return types;
            }
            return freeProcess && freeProcess.binding && freeProcess.binding("util");
          } catch (e) {
          }
        }();
        var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
        function apply(func, thisArg, args) {
          switch (args.length) {
            case 0:
              return func.call(thisArg);
            case 1:
              return func.call(thisArg, args[0]);
            case 2:
              return func.call(thisArg, args[0], args[1]);
            case 3:
              return func.call(thisArg, args[0], args[1], args[2]);
          }
          return func.apply(thisArg, args);
        }
        function arrayAggregator(array2, setter, iteratee, accumulator) {
          var index2 = -1, length = array2 == null ? 0 : array2.length;
          while (++index2 < length) {
            var value = array2[index2];
            setter(accumulator, value, iteratee(value), array2);
          }
          return accumulator;
        }
        function arrayEach(array2, iteratee) {
          var index2 = -1, length = array2 == null ? 0 : array2.length;
          while (++index2 < length) {
            if (iteratee(array2[index2], index2, array2) === false) {
              break;
            }
          }
          return array2;
        }
        function arrayEachRight(array2, iteratee) {
          var length = array2 == null ? 0 : array2.length;
          while (length--) {
            if (iteratee(array2[length], length, array2) === false) {
              break;
            }
          }
          return array2;
        }
        function arrayEvery(array2, predicate) {
          var index2 = -1, length = array2 == null ? 0 : array2.length;
          while (++index2 < length) {
            if (!predicate(array2[index2], index2, array2)) {
              return false;
            }
          }
          return true;
        }
        function arrayFilter(array2, predicate) {
          var index2 = -1, length = array2 == null ? 0 : array2.length, resIndex = 0, result = [];
          while (++index2 < length) {
            var value = array2[index2];
            if (predicate(value, index2, array2)) {
              result[resIndex++] = value;
            }
          }
          return result;
        }
        function arrayIncludes(array2, value) {
          var length = array2 == null ? 0 : array2.length;
          return !!length && baseIndexOf(array2, value, 0) > -1;
        }
        function arrayIncludesWith(array2, value, comparator) {
          var index2 = -1, length = array2 == null ? 0 : array2.length;
          while (++index2 < length) {
            if (comparator(value, array2[index2])) {
              return true;
            }
          }
          return false;
        }
        function arrayMap(array2, iteratee) {
          var index2 = -1, length = array2 == null ? 0 : array2.length, result = Array(length);
          while (++index2 < length) {
            result[index2] = iteratee(array2[index2], index2, array2);
          }
          return result;
        }
        function arrayPush(array2, values) {
          var index2 = -1, length = values.length, offset = array2.length;
          while (++index2 < length) {
            array2[offset + index2] = values[index2];
          }
          return array2;
        }
        function arrayReduce(array2, iteratee, accumulator, initAccum) {
          var index2 = -1, length = array2 == null ? 0 : array2.length;
          if (initAccum && length) {
            accumulator = array2[++index2];
          }
          while (++index2 < length) {
            accumulator = iteratee(accumulator, array2[index2], index2, array2);
          }
          return accumulator;
        }
        function arrayReduceRight(array2, iteratee, accumulator, initAccum) {
          var length = array2 == null ? 0 : array2.length;
          if (initAccum && length) {
            accumulator = array2[--length];
          }
          while (length--) {
            accumulator = iteratee(accumulator, array2[length], length, array2);
          }
          return accumulator;
        }
        function arraySome(array2, predicate) {
          var index2 = -1, length = array2 == null ? 0 : array2.length;
          while (++index2 < length) {
            if (predicate(array2[index2], index2, array2)) {
              return true;
            }
          }
          return false;
        }
        var asciiSize = baseProperty("length");
        function asciiToArray(string) {
          return string.split("");
        }
        function asciiWords(string) {
          return string.match(reAsciiWord) || [];
        }
        function baseFindKey(collection, predicate, eachFunc) {
          var result;
          eachFunc(collection, function(value, key, collection2) {
            if (predicate(value, key, collection2)) {
              result = key;
              return false;
            }
          });
          return result;
        }
        function baseFindIndex(array2, predicate, fromIndex, fromRight) {
          var length = array2.length, index2 = fromIndex + (fromRight ? 1 : -1);
          while (fromRight ? index2-- : ++index2 < length) {
            if (predicate(array2[index2], index2, array2)) {
              return index2;
            }
          }
          return -1;
        }
        function baseIndexOf(array2, value, fromIndex) {
          return value === value ? strictIndexOf(array2, value, fromIndex) : baseFindIndex(array2, baseIsNaN, fromIndex);
        }
        function baseIndexOfWith(array2, value, fromIndex, comparator) {
          var index2 = fromIndex - 1, length = array2.length;
          while (++index2 < length) {
            if (comparator(array2[index2], value)) {
              return index2;
            }
          }
          return -1;
        }
        function baseIsNaN(value) {
          return value !== value;
        }
        function baseMean(array2, iteratee) {
          var length = array2 == null ? 0 : array2.length;
          return length ? baseSum(array2, iteratee) / length : NAN;
        }
        function baseProperty(key) {
          return function(object) {
            return object == null ? undefined2 : object[key];
          };
        }
        function basePropertyOf(object) {
          return function(key) {
            return object == null ? undefined2 : object[key];
          };
        }
        function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
          eachFunc(collection, function(value, index2, collection2) {
            accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index2, collection2);
          });
          return accumulator;
        }
        function baseSortBy(array2, comparer) {
          var length = array2.length;
          array2.sort(comparer);
          while (length--) {
            array2[length] = array2[length].value;
          }
          return array2;
        }
        function baseSum(array2, iteratee) {
          var result, index2 = -1, length = array2.length;
          while (++index2 < length) {
            var current = iteratee(array2[index2]);
            if (current !== undefined2) {
              result = result === undefined2 ? current : result + current;
            }
          }
          return result;
        }
        function baseTimes(n, iteratee) {
          var index2 = -1, result = Array(n);
          while (++index2 < n) {
            result[index2] = iteratee(index2);
          }
          return result;
        }
        function baseToPairs(object, props) {
          return arrayMap(props, function(key) {
            return [key, object[key]];
          });
        }
        function baseTrim(string) {
          return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
        }
        function baseUnary(func) {
          return function(value) {
            return func(value);
          };
        }
        function baseValues(object, props) {
          return arrayMap(props, function(key) {
            return object[key];
          });
        }
        function cacheHas(cache, key) {
          return cache.has(key);
        }
        function charsStartIndex(strSymbols, chrSymbols) {
          var index2 = -1, length = strSymbols.length;
          while (++index2 < length && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
          }
          return index2;
        }
        function charsEndIndex(strSymbols, chrSymbols) {
          var index2 = strSymbols.length;
          while (index2-- && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
          }
          return index2;
        }
        function countHolders(array2, placeholder) {
          var length = array2.length, result = 0;
          while (length--) {
            if (array2[length] === placeholder) {
              ++result;
            }
          }
          return result;
        }
        var deburrLetter = basePropertyOf(deburredLetters);
        var escapeHtmlChar = basePropertyOf(htmlEscapes);
        function escapeStringChar(chr) {
          return "\\" + stringEscapes[chr];
        }
        function getValue(object, key) {
          return object == null ? undefined2 : object[key];
        }
        function hasUnicode(string) {
          return reHasUnicode.test(string);
        }
        function hasUnicodeWord(string) {
          return reHasUnicodeWord.test(string);
        }
        function iteratorToArray(iterator) {
          var data, result = [];
          while (!(data = iterator.next()).done) {
            result.push(data.value);
          }
          return result;
        }
        function mapToArray(map4) {
          var index2 = -1, result = Array(map4.size);
          map4.forEach(function(value, key) {
            result[++index2] = [key, value];
          });
          return result;
        }
        function overArg(func, transform2) {
          return function(arg) {
            return func(transform2(arg));
          };
        }
        function replaceHolders(array2, placeholder) {
          var index2 = -1, length = array2.length, resIndex = 0, result = [];
          while (++index2 < length) {
            var value = array2[index2];
            if (value === placeholder || value === PLACEHOLDER) {
              array2[index2] = PLACEHOLDER;
              result[resIndex++] = index2;
            }
          }
          return result;
        }
        function setToArray(set3) {
          var index2 = -1, result = Array(set3.size);
          set3.forEach(function(value) {
            result[++index2] = value;
          });
          return result;
        }
        function setToPairs(set3) {
          var index2 = -1, result = Array(set3.size);
          set3.forEach(function(value) {
            result[++index2] = [value, value];
          });
          return result;
        }
        function strictIndexOf(array2, value, fromIndex) {
          var index2 = fromIndex - 1, length = array2.length;
          while (++index2 < length) {
            if (array2[index2] === value) {
              return index2;
            }
          }
          return -1;
        }
        function strictLastIndexOf(array2, value, fromIndex) {
          var index2 = fromIndex + 1;
          while (index2--) {
            if (array2[index2] === value) {
              return index2;
            }
          }
          return index2;
        }
        function stringSize(string) {
          return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
        }
        function stringToArray(string) {
          return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
        }
        function trimmedEndIndex(string) {
          var index2 = string.length;
          while (index2-- && reWhitespace.test(string.charAt(index2))) {
          }
          return index2;
        }
        var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
        function unicodeSize(string) {
          var result = reUnicode.lastIndex = 0;
          while (reUnicode.test(string)) {
            ++result;
          }
          return result;
        }
        function unicodeToArray(string) {
          return string.match(reUnicode) || [];
        }
        function unicodeWords(string) {
          return string.match(reUnicodeWord) || [];
        }
        var runInContext = function runInContext2(context2) {
          context2 = context2 == null ? root2 : _2.defaults(root2.Object(), context2, _2.pick(root2, contextProps));
          var Array2 = context2.Array, Date2 = context2.Date, Error2 = context2.Error, Function2 = context2.Function, Math2 = context2.Math, Object2 = context2.Object, RegExp2 = context2.RegExp, String2 = context2.String, TypeError2 = context2.TypeError;
          var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
          var coreJsData = context2["__core-js_shared__"];
          var funcToString = funcProto.toString;
          var hasOwnProperty = objectProto.hasOwnProperty;
          var idCounter = 0;
          var maskSrcKey = function() {
            var uid2 = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
            return uid2 ? "Symbol(src)_1." + uid2 : "";
          }();
          var nativeObjectToString = objectProto.toString;
          var objectCtorString = funcToString.call(Object2);
          var oldDash = root2._;
          var reIsNative = RegExp2(
            "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
          );
          var Buffer3 = moduleExports ? context2.Buffer : undefined2, Symbol2 = context2.Symbol, Uint8Array2 = context2.Uint8Array, allocUnsafe = Buffer3 ? Buffer3.allocUnsafe : undefined2, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined2, symIterator = Symbol2 ? Symbol2.iterator : undefined2, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined2;
          var defineProperty = function() {
            try {
              var func = getNative(Object2, "defineProperty");
              func({}, "", {});
              return func;
            } catch (e) {
            }
          }();
          var ctxClearTimeout = context2.clearTimeout !== root2.clearTimeout && context2.clearTimeout, ctxNow = Date2 && Date2.now !== root2.Date.now && Date2.now, ctxSetTimeout = context2.setTimeout !== root2.setTimeout && context2.setTimeout;
          var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer3 ? Buffer3.isBuffer : undefined2, nativeIsFinite = context2.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context2.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
          var DataView2 = getNative(context2, "DataView"), Map2 = getNative(context2, "Map"), Promise2 = getNative(context2, "Promise"), Set = getNative(context2, "Set"), WeakMap = getNative(context2, "WeakMap"), nativeCreate = getNative(Object2, "create");
          var metaMap = WeakMap && new WeakMap();
          var realNames = {};
          var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set), weakMapCtorString = toSource(WeakMap);
          var symbolProto = Symbol2 ? Symbol2.prototype : undefined2, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined2, symbolToString = symbolProto ? symbolProto.toString : undefined2;
          function lodash(value) {
            if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
              if (value instanceof LodashWrapper) {
                return value;
              }
              if (hasOwnProperty.call(value, "__wrapped__")) {
                return wrapperClone(value);
              }
            }
            return new LodashWrapper(value);
          }
          var baseCreate = function() {
            function object() {
            }
            return function(proto) {
              if (!isObject(proto)) {
                return {};
              }
              if (objectCreate) {
                return objectCreate(proto);
              }
              object.prototype = proto;
              var result2 = new object();
              object.prototype = undefined2;
              return result2;
            };
          }();
          function baseLodash() {
          }
          function LodashWrapper(value, chainAll) {
            this.__wrapped__ = value;
            this.__actions__ = [];
            this.__chain__ = !!chainAll;
            this.__index__ = 0;
            this.__values__ = undefined2;
          }
          lodash.templateSettings = {
            "escape": reEscape,
            "evaluate": reEvaluate,
            "interpolate": reInterpolate,
            "variable": "",
            "imports": {
              "_": lodash
            }
          };
          lodash.prototype = baseLodash.prototype;
          lodash.prototype.constructor = lodash;
          LodashWrapper.prototype = baseCreate(baseLodash.prototype);
          LodashWrapper.prototype.constructor = LodashWrapper;
          function LazyWrapper(value) {
            this.__wrapped__ = value;
            this.__actions__ = [];
            this.__dir__ = 1;
            this.__filtered__ = false;
            this.__iteratees__ = [];
            this.__takeCount__ = MAX_ARRAY_LENGTH;
            this.__views__ = [];
          }
          function lazyClone() {
            var result2 = new LazyWrapper(this.__wrapped__);
            result2.__actions__ = copyArray(this.__actions__);
            result2.__dir__ = this.__dir__;
            result2.__filtered__ = this.__filtered__;
            result2.__iteratees__ = copyArray(this.__iteratees__);
            result2.__takeCount__ = this.__takeCount__;
            result2.__views__ = copyArray(this.__views__);
            return result2;
          }
          function lazyReverse() {
            if (this.__filtered__) {
              var result2 = new LazyWrapper(this);
              result2.__dir__ = -1;
              result2.__filtered__ = true;
            } else {
              result2 = this.clone();
              result2.__dir__ *= -1;
            }
            return result2;
          }
          function lazyValue() {
            var array2 = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array2), isRight = dir < 0, arrLength = isArr ? array2.length : 0, view = getView(0, arrLength, this.__views__), start2 = view.start, end = view.end, length = end - start2, index2 = isRight ? end : start2 - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
            if (!isArr || !isRight && arrLength == length && takeCount == length) {
              return baseWrapperValue(array2, this.__actions__);
            }
            var result2 = [];
            outer:
              while (length-- && resIndex < takeCount) {
                index2 += dir;
                var iterIndex = -1, value = array2[index2];
                while (++iterIndex < iterLength) {
                  var data = iteratees[iterIndex], iteratee2 = data.iteratee, type2 = data.type, computed = iteratee2(value);
                  if (type2 == LAZY_MAP_FLAG) {
                    value = computed;
                  } else if (!computed) {
                    if (type2 == LAZY_FILTER_FLAG) {
                      continue outer;
                    } else {
                      break outer;
                    }
                  }
                }
                result2[resIndex++] = value;
              }
            return result2;
          }
          LazyWrapper.prototype = baseCreate(baseLodash.prototype);
          LazyWrapper.prototype.constructor = LazyWrapper;
          function Hash(entries) {
            var index2 = -1, length = entries == null ? 0 : entries.length;
            this.clear();
            while (++index2 < length) {
              var entry = entries[index2];
              this.set(entry[0], entry[1]);
            }
          }
          function hashClear() {
            this.__data__ = nativeCreate ? nativeCreate(null) : {};
            this.size = 0;
          }
          function hashDelete(key) {
            var result2 = this.has(key) && delete this.__data__[key];
            this.size -= result2 ? 1 : 0;
            return result2;
          }
          function hashGet(key) {
            var data = this.__data__;
            if (nativeCreate) {
              var result2 = data[key];
              return result2 === HASH_UNDEFINED ? undefined2 : result2;
            }
            return hasOwnProperty.call(data, key) ? data[key] : undefined2;
          }
          function hashHas(key) {
            var data = this.__data__;
            return nativeCreate ? data[key] !== undefined2 : hasOwnProperty.call(data, key);
          }
          function hashSet(key, value) {
            var data = this.__data__;
            this.size += this.has(key) ? 0 : 1;
            data[key] = nativeCreate && value === undefined2 ? HASH_UNDEFINED : value;
            return this;
          }
          Hash.prototype.clear = hashClear;
          Hash.prototype["delete"] = hashDelete;
          Hash.prototype.get = hashGet;
          Hash.prototype.has = hashHas;
          Hash.prototype.set = hashSet;
          function ListCache(entries) {
            var index2 = -1, length = entries == null ? 0 : entries.length;
            this.clear();
            while (++index2 < length) {
              var entry = entries[index2];
              this.set(entry[0], entry[1]);
            }
          }
          function listCacheClear() {
            this.__data__ = [];
            this.size = 0;
          }
          function listCacheDelete(key) {
            var data = this.__data__, index2 = assocIndexOf(data, key);
            if (index2 < 0) {
              return false;
            }
            var lastIndex = data.length - 1;
            if (index2 == lastIndex) {
              data.pop();
            } else {
              splice.call(data, index2, 1);
            }
            --this.size;
            return true;
          }
          function listCacheGet(key) {
            var data = this.__data__, index2 = assocIndexOf(data, key);
            return index2 < 0 ? undefined2 : data[index2][1];
          }
          function listCacheHas(key) {
            return assocIndexOf(this.__data__, key) > -1;
          }
          function listCacheSet(key, value) {
            var data = this.__data__, index2 = assocIndexOf(data, key);
            if (index2 < 0) {
              ++this.size;
              data.push([key, value]);
            } else {
              data[index2][1] = value;
            }
            return this;
          }
          ListCache.prototype.clear = listCacheClear;
          ListCache.prototype["delete"] = listCacheDelete;
          ListCache.prototype.get = listCacheGet;
          ListCache.prototype.has = listCacheHas;
          ListCache.prototype.set = listCacheSet;
          function MapCache(entries) {
            var index2 = -1, length = entries == null ? 0 : entries.length;
            this.clear();
            while (++index2 < length) {
              var entry = entries[index2];
              this.set(entry[0], entry[1]);
            }
          }
          function mapCacheClear() {
            this.size = 0;
            this.__data__ = {
              "hash": new Hash(),
              "map": new (Map2 || ListCache)(),
              "string": new Hash()
            };
          }
          function mapCacheDelete(key) {
            var result2 = getMapData(this, key)["delete"](key);
            this.size -= result2 ? 1 : 0;
            return result2;
          }
          function mapCacheGet(key) {
            return getMapData(this, key).get(key);
          }
          function mapCacheHas(key) {
            return getMapData(this, key).has(key);
          }
          function mapCacheSet(key, value) {
            var data = getMapData(this, key), size2 = data.size;
            data.set(key, value);
            this.size += data.size == size2 ? 0 : 1;
            return this;
          }
          MapCache.prototype.clear = mapCacheClear;
          MapCache.prototype["delete"] = mapCacheDelete;
          MapCache.prototype.get = mapCacheGet;
          MapCache.prototype.has = mapCacheHas;
          MapCache.prototype.set = mapCacheSet;
          function SetCache(values2) {
            var index2 = -1, length = values2 == null ? 0 : values2.length;
            this.__data__ = new MapCache();
            while (++index2 < length) {
              this.add(values2[index2]);
            }
          }
          function setCacheAdd(value) {
            this.__data__.set(value, HASH_UNDEFINED);
            return this;
          }
          function setCacheHas(value) {
            return this.__data__.has(value);
          }
          SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
          SetCache.prototype.has = setCacheHas;
          function Stack(entries) {
            var data = this.__data__ = new ListCache(entries);
            this.size = data.size;
          }
          function stackClear() {
            this.__data__ = new ListCache();
            this.size = 0;
          }
          function stackDelete(key) {
            var data = this.__data__, result2 = data["delete"](key);
            this.size = data.size;
            return result2;
          }
          function stackGet(key) {
            return this.__data__.get(key);
          }
          function stackHas(key) {
            return this.__data__.has(key);
          }
          function stackSet(key, value) {
            var data = this.__data__;
            if (data instanceof ListCache) {
              var pairs = data.__data__;
              if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
                pairs.push([key, value]);
                this.size = ++data.size;
                return this;
              }
              data = this.__data__ = new MapCache(pairs);
            }
            data.set(key, value);
            this.size = data.size;
            return this;
          }
          Stack.prototype.clear = stackClear;
          Stack.prototype["delete"] = stackDelete;
          Stack.prototype.get = stackGet;
          Stack.prototype.has = stackHas;
          Stack.prototype.set = stackSet;
          function arrayLikeKeys(value, inherited) {
            var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length = result2.length;
            for (var key in value) {
              if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))) {
                result2.push(key);
              }
            }
            return result2;
          }
          function arraySample(array2) {
            var length = array2.length;
            return length ? array2[baseRandom(0, length - 1)] : undefined2;
          }
          function arraySampleSize(array2, n) {
            return shuffleSelf(copyArray(array2), baseClamp(n, 0, array2.length));
          }
          function arrayShuffle(array2) {
            return shuffleSelf(copyArray(array2));
          }
          function assignMergeValue(object, key, value) {
            if (value !== undefined2 && !eq(object[key], value) || value === undefined2 && !(key in object)) {
              baseAssignValue(object, key, value);
            }
          }
          function assignValue(object, key, value) {
            var objValue = object[key];
            if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined2 && !(key in object)) {
              baseAssignValue(object, key, value);
            }
          }
          function assocIndexOf(array2, key) {
            var length = array2.length;
            while (length--) {
              if (eq(array2[length][0], key)) {
                return length;
              }
            }
            return -1;
          }
          function baseAggregator(collection, setter, iteratee2, accumulator) {
            baseEach(collection, function(value, key, collection2) {
              setter(accumulator, value, iteratee2(value), collection2);
            });
            return accumulator;
          }
          function baseAssign(object, source) {
            return object && copyObject(source, keys(source), object);
          }
          function baseAssignIn(object, source) {
            return object && copyObject(source, keysIn(source), object);
          }
          function baseAssignValue(object, key, value) {
            if (key == "__proto__" && defineProperty) {
              defineProperty(object, key, {
                "configurable": true,
                "enumerable": true,
                "value": value,
                "writable": true
              });
            } else {
              object[key] = value;
            }
          }
          function baseAt(object, paths) {
            var index2 = -1, length = paths.length, result2 = Array2(length), skip = object == null;
            while (++index2 < length) {
              result2[index2] = skip ? undefined2 : get3(object, paths[index2]);
            }
            return result2;
          }
          function baseClamp(number, lower2, upper) {
            if (number === number) {
              if (upper !== undefined2) {
                number = number <= upper ? number : upper;
              }
              if (lower2 !== undefined2) {
                number = number >= lower2 ? number : lower2;
              }
            }
            return number;
          }
          function baseClone(value, bitmask, customizer, key, object, stack) {
            var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
            if (customizer) {
              result2 = object ? customizer(value, key, object, stack) : customizer(value);
            }
            if (result2 !== undefined2) {
              return result2;
            }
            if (!isObject(value)) {
              return value;
            }
            var isArr = isArray(value);
            if (isArr) {
              result2 = initCloneArray(value);
              if (!isDeep) {
                return copyArray(value, result2);
              }
            } else {
              var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
              if (isBuffer(value)) {
                return cloneBuffer(value, isDeep);
              }
              if (tag == objectTag || tag == argsTag || isFunc && !object) {
                result2 = isFlat || isFunc ? {} : initCloneObject(value);
                if (!isDeep) {
                  return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
                }
              } else {
                if (!cloneableTags[tag]) {
                  return object ? value : {};
                }
                result2 = initCloneByTag(value, tag, isDeep);
              }
            }
            stack || (stack = new Stack());
            var stacked = stack.get(value);
            if (stacked) {
              return stacked;
            }
            stack.set(value, result2);
            if (isSet(value)) {
              value.forEach(function(subValue) {
                result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
              });
            } else if (isMap(value)) {
              value.forEach(function(subValue, key2) {
                result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
              });
            }
            var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
            var props = isArr ? undefined2 : keysFunc(value);
            arrayEach(props || value, function(subValue, key2) {
              if (props) {
                key2 = subValue;
                subValue = value[key2];
              }
              assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
            });
            return result2;
          }
          function baseConforms(source) {
            var props = keys(source);
            return function(object) {
              return baseConformsTo(object, source, props);
            };
          }
          function baseConformsTo(object, source, props) {
            var length = props.length;
            if (object == null) {
              return !length;
            }
            object = Object2(object);
            while (length--) {
              var key = props[length], predicate = source[key], value = object[key];
              if (value === undefined2 && !(key in object) || !predicate(value)) {
                return false;
              }
            }
            return true;
          }
          function baseDelay(func, wait, args) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return setTimeout2(function() {
              func.apply(undefined2, args);
            }, wait);
          }
          function baseDifference(array2, values2, iteratee2, comparator) {
            var index2 = -1, includes2 = arrayIncludes, isCommon = true, length = array2.length, result2 = [], valuesLength = values2.length;
            if (!length) {
              return result2;
            }
            if (iteratee2) {
              values2 = arrayMap(values2, baseUnary(iteratee2));
            }
            if (comparator) {
              includes2 = arrayIncludesWith;
              isCommon = false;
            } else if (values2.length >= LARGE_ARRAY_SIZE) {
              includes2 = cacheHas;
              isCommon = false;
              values2 = new SetCache(values2);
            }
            outer:
              while (++index2 < length) {
                var value = array2[index2], computed = iteratee2 == null ? value : iteratee2(value);
                value = comparator || value !== 0 ? value : 0;
                if (isCommon && computed === computed) {
                  var valuesIndex = valuesLength;
                  while (valuesIndex--) {
                    if (values2[valuesIndex] === computed) {
                      continue outer;
                    }
                  }
                  result2.push(value);
                } else if (!includes2(values2, computed, comparator)) {
                  result2.push(value);
                }
              }
            return result2;
          }
          var baseEach = createBaseEach(baseForOwn);
          var baseEachRight = createBaseEach(baseForOwnRight, true);
          function baseEvery(collection, predicate) {
            var result2 = true;
            baseEach(collection, function(value, index2, collection2) {
              result2 = !!predicate(value, index2, collection2);
              return result2;
            });
            return result2;
          }
          function baseExtremum(array2, iteratee2, comparator) {
            var index2 = -1, length = array2.length;
            while (++index2 < length) {
              var value = array2[index2], current = iteratee2(value);
              if (current != null && (computed === undefined2 ? current === current && !isSymbol(current) : comparator(current, computed))) {
                var computed = current, result2 = value;
              }
            }
            return result2;
          }
          function baseFill(array2, value, start2, end) {
            var length = array2.length;
            start2 = toInteger(start2);
            if (start2 < 0) {
              start2 = -start2 > length ? 0 : length + start2;
            }
            end = end === undefined2 || end > length ? length : toInteger(end);
            if (end < 0) {
              end += length;
            }
            end = start2 > end ? 0 : toLength(end);
            while (start2 < end) {
              array2[start2++] = value;
            }
            return array2;
          }
          function baseFilter(collection, predicate) {
            var result2 = [];
            baseEach(collection, function(value, index2, collection2) {
              if (predicate(value, index2, collection2)) {
                result2.push(value);
              }
            });
            return result2;
          }
          function baseFlatten(array2, depth, predicate, isStrict, result2) {
            var index2 = -1, length = array2.length;
            predicate || (predicate = isFlattenable);
            result2 || (result2 = []);
            while (++index2 < length) {
              var value = array2[index2];
              if (depth > 0 && predicate(value)) {
                if (depth > 1) {
                  baseFlatten(value, depth - 1, predicate, isStrict, result2);
                } else {
                  arrayPush(result2, value);
                }
              } else if (!isStrict) {
                result2[result2.length] = value;
              }
            }
            return result2;
          }
          var baseFor = createBaseFor();
          var baseForRight = createBaseFor(true);
          function baseForOwn(object, iteratee2) {
            return object && baseFor(object, iteratee2, keys);
          }
          function baseForOwnRight(object, iteratee2) {
            return object && baseForRight(object, iteratee2, keys);
          }
          function baseFunctions(object, props) {
            return arrayFilter(props, function(key) {
              return isFunction(object[key]);
            });
          }
          function baseGet(object, path2) {
            path2 = castPath(path2, object);
            var index2 = 0, length = path2.length;
            while (object != null && index2 < length) {
              object = object[toKey(path2[index2++])];
            }
            return index2 && index2 == length ? object : undefined2;
          }
          function baseGetAllKeys(object, keysFunc, symbolsFunc) {
            var result2 = keysFunc(object);
            return isArray(object) ? result2 : arrayPush(result2, symbolsFunc(object));
          }
          function baseGetTag(value) {
            if (value == null) {
              return value === undefined2 ? undefinedTag : nullTag;
            }
            return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
          }
          function baseGt(value, other) {
            return value > other;
          }
          function baseHas(object, key) {
            return object != null && hasOwnProperty.call(object, key);
          }
          function baseHasIn(object, key) {
            return object != null && key in Object2(object);
          }
          function baseInRange(number, start2, end) {
            return number >= nativeMin(start2, end) && number < nativeMax(start2, end);
          }
          function baseIntersection(arrays, iteratee2, comparator) {
            var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
            while (othIndex--) {
              var array2 = arrays[othIndex];
              if (othIndex && iteratee2) {
                array2 = arrayMap(array2, baseUnary(iteratee2));
              }
              maxLength = nativeMin(array2.length, maxLength);
              caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array2.length >= 120) ? new SetCache(othIndex && array2) : undefined2;
            }
            array2 = arrays[0];
            var index2 = -1, seen = caches[0];
            outer:
              while (++index2 < length && result2.length < maxLength) {
                var value = array2[index2], computed = iteratee2 ? iteratee2(value) : value;
                value = comparator || value !== 0 ? value : 0;
                if (!(seen ? cacheHas(seen, computed) : includes2(result2, computed, comparator))) {
                  othIndex = othLength;
                  while (--othIndex) {
                    var cache = caches[othIndex];
                    if (!(cache ? cacheHas(cache, computed) : includes2(arrays[othIndex], computed, comparator))) {
                      continue outer;
                    }
                  }
                  if (seen) {
                    seen.push(computed);
                  }
                  result2.push(value);
                }
              }
            return result2;
          }
          function baseInverter(object, setter, iteratee2, accumulator) {
            baseForOwn(object, function(value, key, object2) {
              setter(accumulator, iteratee2(value), key, object2);
            });
            return accumulator;
          }
          function baseInvoke(object, path2, args) {
            path2 = castPath(path2, object);
            object = parent2(object, path2);
            var func = object == null ? object : object[toKey(last(path2))];
            return func == null ? undefined2 : apply(func, object, args);
          }
          function baseIsArguments(value) {
            return isObjectLike(value) && baseGetTag(value) == argsTag;
          }
          function baseIsArrayBuffer(value) {
            return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
          }
          function baseIsDate(value) {
            return isObjectLike(value) && baseGetTag(value) == dateTag;
          }
          function baseIsEqual(value, other, bitmask, customizer, stack) {
            if (value === other) {
              return true;
            }
            if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
              return value !== value && other !== other;
            }
            return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
          }
          function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
            var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
            objTag = objTag == argsTag ? objectTag : objTag;
            othTag = othTag == argsTag ? objectTag : othTag;
            var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
            if (isSameTag && isBuffer(object)) {
              if (!isBuffer(other)) {
                return false;
              }
              objIsArr = true;
              objIsObj = false;
            }
            if (isSameTag && !objIsObj) {
              stack || (stack = new Stack());
              return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
            }
            if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
              var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
              if (objIsWrapped || othIsWrapped) {
                var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
                stack || (stack = new Stack());
                return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
              }
            }
            if (!isSameTag) {
              return false;
            }
            stack || (stack = new Stack());
            return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
          }
          function baseIsMap(value) {
            return isObjectLike(value) && getTag(value) == mapTag;
          }
          function baseIsMatch(object, source, matchData, customizer) {
            var index2 = matchData.length, length = index2, noCustomizer = !customizer;
            if (object == null) {
              return !length;
            }
            object = Object2(object);
            while (index2--) {
              var data = matchData[index2];
              if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
                return false;
              }
            }
            while (++index2 < length) {
              data = matchData[index2];
              var key = data[0], objValue = object[key], srcValue = data[1];
              if (noCustomizer && data[2]) {
                if (objValue === undefined2 && !(key in object)) {
                  return false;
                }
              } else {
                var stack = new Stack();
                if (customizer) {
                  var result2 = customizer(objValue, srcValue, key, object, source, stack);
                }
                if (!(result2 === undefined2 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
                  return false;
                }
              }
            }
            return true;
          }
          function baseIsNative(value) {
            if (!isObject(value) || isMasked(value)) {
              return false;
            }
            var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
            return pattern.test(toSource(value));
          }
          function baseIsRegExp(value) {
            return isObjectLike(value) && baseGetTag(value) == regexpTag;
          }
          function baseIsSet(value) {
            return isObjectLike(value) && getTag(value) == setTag;
          }
          function baseIsTypedArray(value) {
            return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
          }
          function baseIteratee(value) {
            if (typeof value == "function") {
              return value;
            }
            if (value == null) {
              return identity3;
            }
            if (typeof value == "object") {
              return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
            }
            return property(value);
          }
          function baseKeys(object) {
            if (!isPrototype(object)) {
              return nativeKeys(object);
            }
            var result2 = [];
            for (var key in Object2(object)) {
              if (hasOwnProperty.call(object, key) && key != "constructor") {
                result2.push(key);
              }
            }
            return result2;
          }
          function baseKeysIn(object) {
            if (!isObject(object)) {
              return nativeKeysIn(object);
            }
            var isProto = isPrototype(object), result2 = [];
            for (var key in object) {
              if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
                result2.push(key);
              }
            }
            return result2;
          }
          function baseLt(value, other) {
            return value < other;
          }
          function baseMap(collection, iteratee2) {
            var index2 = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
            baseEach(collection, function(value, key, collection2) {
              result2[++index2] = iteratee2(value, key, collection2);
            });
            return result2;
          }
          function baseMatches(source) {
            var matchData = getMatchData(source);
            if (matchData.length == 1 && matchData[0][2]) {
              return matchesStrictComparable(matchData[0][0], matchData[0][1]);
            }
            return function(object) {
              return object === source || baseIsMatch(object, source, matchData);
            };
          }
          function baseMatchesProperty(path2, srcValue) {
            if (isKey(path2) && isStrictComparable(srcValue)) {
              return matchesStrictComparable(toKey(path2), srcValue);
            }
            return function(object) {
              var objValue = get3(object, path2);
              return objValue === undefined2 && objValue === srcValue ? hasIn(object, path2) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
            };
          }
          function baseMerge(object, source, srcIndex, customizer, stack) {
            if (object === source) {
              return;
            }
            baseFor(source, function(srcValue, key) {
              stack || (stack = new Stack());
              if (isObject(srcValue)) {
                baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
              } else {
                var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined2;
                if (newValue === undefined2) {
                  newValue = srcValue;
                }
                assignMergeValue(object, key, newValue);
              }
            }, keysIn);
          }
          function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
            var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
            if (stacked) {
              assignMergeValue(object, key, stacked);
              return;
            }
            var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined2;
            var isCommon = newValue === undefined2;
            if (isCommon) {
              var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
              newValue = srcValue;
              if (isArr || isBuff || isTyped) {
                if (isArray(objValue)) {
                  newValue = objValue;
                } else if (isArrayLikeObject(objValue)) {
                  newValue = copyArray(objValue);
                } else if (isBuff) {
                  isCommon = false;
                  newValue = cloneBuffer(srcValue, true);
                } else if (isTyped) {
                  isCommon = false;
                  newValue = cloneTypedArray(srcValue, true);
                } else {
                  newValue = [];
                }
              } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
                newValue = objValue;
                if (isArguments(objValue)) {
                  newValue = toPlainObject(objValue);
                } else if (!isObject(objValue) || isFunction(objValue)) {
                  newValue = initCloneObject(srcValue);
                }
              } else {
                isCommon = false;
              }
            }
            if (isCommon) {
              stack.set(srcValue, newValue);
              mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
              stack["delete"](srcValue);
            }
            assignMergeValue(object, key, newValue);
          }
          function baseNth(array2, n) {
            var length = array2.length;
            if (!length) {
              return;
            }
            n += n < 0 ? length : 0;
            return isIndex(n, length) ? array2[n] : undefined2;
          }
          function baseOrderBy(collection, iteratees, orders) {
            if (iteratees.length) {
              iteratees = arrayMap(iteratees, function(iteratee2) {
                if (isArray(iteratee2)) {
                  return function(value) {
                    return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
                  };
                }
                return iteratee2;
              });
            } else {
              iteratees = [identity3];
            }
            var index2 = -1;
            iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
            var result2 = baseMap(collection, function(value, key, collection2) {
              var criteria = arrayMap(iteratees, function(iteratee2) {
                return iteratee2(value);
              });
              return { "criteria": criteria, "index": ++index2, "value": value };
            });
            return baseSortBy(result2, function(object, other) {
              return compareMultiple(object, other, orders);
            });
          }
          function basePick(object, paths) {
            return basePickBy(object, paths, function(value, path2) {
              return hasIn(object, path2);
            });
          }
          function basePickBy(object, paths, predicate) {
            var index2 = -1, length = paths.length, result2 = {};
            while (++index2 < length) {
              var path2 = paths[index2], value = baseGet(object, path2);
              if (predicate(value, path2)) {
                baseSet(result2, castPath(path2, object), value);
              }
            }
            return result2;
          }
          function basePropertyDeep(path2) {
            return function(object) {
              return baseGet(object, path2);
            };
          }
          function basePullAll(array2, values2, iteratee2, comparator) {
            var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index2 = -1, length = values2.length, seen = array2;
            if (array2 === values2) {
              values2 = copyArray(values2);
            }
            if (iteratee2) {
              seen = arrayMap(array2, baseUnary(iteratee2));
            }
            while (++index2 < length) {
              var fromIndex = 0, value = values2[index2], computed = iteratee2 ? iteratee2(value) : value;
              while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
                if (seen !== array2) {
                  splice.call(seen, fromIndex, 1);
                }
                splice.call(array2, fromIndex, 1);
              }
            }
            return array2;
          }
          function basePullAt(array2, indexes) {
            var length = array2 ? indexes.length : 0, lastIndex = length - 1;
            while (length--) {
              var index2 = indexes[length];
              if (length == lastIndex || index2 !== previous) {
                var previous = index2;
                if (isIndex(index2)) {
                  splice.call(array2, index2, 1);
                } else {
                  baseUnset(array2, index2);
                }
              }
            }
            return array2;
          }
          function baseRandom(lower2, upper) {
            return lower2 + nativeFloor(nativeRandom() * (upper - lower2 + 1));
          }
          function baseRange(start2, end, step, fromRight) {
            var index2 = -1, length = nativeMax(nativeCeil((end - start2) / (step || 1)), 0), result2 = Array2(length);
            while (length--) {
              result2[fromRight ? length : ++index2] = start2;
              start2 += step;
            }
            return result2;
          }
          function baseRepeat(string, n) {
            var result2 = "";
            if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
              return result2;
            }
            do {
              if (n % 2) {
                result2 += string;
              }
              n = nativeFloor(n / 2);
              if (n) {
                string += string;
              }
            } while (n);
            return result2;
          }
          function baseRest(func, start2) {
            return setToString(overRest(func, start2, identity3), func + "");
          }
          function baseSample(collection) {
            return arraySample(values(collection));
          }
          function baseSampleSize(collection, n) {
            var array2 = values(collection);
            return shuffleSelf(array2, baseClamp(n, 0, array2.length));
          }
          function baseSet(object, path2, value, customizer) {
            if (!isObject(object)) {
              return object;
            }
            path2 = castPath(path2, object);
            var index2 = -1, length = path2.length, lastIndex = length - 1, nested = object;
            while (nested != null && ++index2 < length) {
              var key = toKey(path2[index2]), newValue = value;
              if (key === "__proto__" || key === "constructor" || key === "prototype") {
                return object;
              }
              if (index2 != lastIndex) {
                var objValue = nested[key];
                newValue = customizer ? customizer(objValue, key, nested) : undefined2;
                if (newValue === undefined2) {
                  newValue = isObject(objValue) ? objValue : isIndex(path2[index2 + 1]) ? [] : {};
                }
              }
              assignValue(nested, key, newValue);
              nested = nested[key];
            }
            return object;
          }
          var baseSetData = !metaMap ? identity3 : function(func, data) {
            metaMap.set(func, data);
            return func;
          };
          var baseSetToString = !defineProperty ? identity3 : function(func, string) {
            return defineProperty(func, "toString", {
              "configurable": true,
              "enumerable": false,
              "value": constant(string),
              "writable": true
            });
          };
          function baseShuffle(collection) {
            return shuffleSelf(values(collection));
          }
          function baseSlice(array2, start2, end) {
            var index2 = -1, length = array2.length;
            if (start2 < 0) {
              start2 = -start2 > length ? 0 : length + start2;
            }
            end = end > length ? length : end;
            if (end < 0) {
              end += length;
            }
            length = start2 > end ? 0 : end - start2 >>> 0;
            start2 >>>= 0;
            var result2 = Array2(length);
            while (++index2 < length) {
              result2[index2] = array2[index2 + start2];
            }
            return result2;
          }
          function baseSome(collection, predicate) {
            var result2;
            baseEach(collection, function(value, index2, collection2) {
              result2 = predicate(value, index2, collection2);
              return !result2;
            });
            return !!result2;
          }
          function baseSortedIndex(array2, value, retHighest) {
            var low = 0, high = array2 == null ? low : array2.length;
            if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
              while (low < high) {
                var mid = low + high >>> 1, computed = array2[mid];
                if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
                  low = mid + 1;
                } else {
                  high = mid;
                }
              }
              return high;
            }
            return baseSortedIndexBy(array2, value, identity3, retHighest);
          }
          function baseSortedIndexBy(array2, value, iteratee2, retHighest) {
            var low = 0, high = array2 == null ? 0 : array2.length;
            if (high === 0) {
              return 0;
            }
            value = iteratee2(value);
            var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined2;
            while (low < high) {
              var mid = nativeFloor((low + high) / 2), computed = iteratee2(array2[mid]), othIsDefined = computed !== undefined2, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
              if (valIsNaN) {
                var setLow = retHighest || othIsReflexive;
              } else if (valIsUndefined) {
                setLow = othIsReflexive && (retHighest || othIsDefined);
              } else if (valIsNull) {
                setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
              } else if (valIsSymbol) {
                setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
              } else if (othIsNull || othIsSymbol) {
                setLow = false;
              } else {
                setLow = retHighest ? computed <= value : computed < value;
              }
              if (setLow) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return nativeMin(high, MAX_ARRAY_INDEX);
          }
          function baseSortedUniq(array2, iteratee2) {
            var index2 = -1, length = array2.length, resIndex = 0, result2 = [];
            while (++index2 < length) {
              var value = array2[index2], computed = iteratee2 ? iteratee2(value) : value;
              if (!index2 || !eq(computed, seen)) {
                var seen = computed;
                result2[resIndex++] = value === 0 ? 0 : value;
              }
            }
            return result2;
          }
          function baseToNumber(value) {
            if (typeof value == "number") {
              return value;
            }
            if (isSymbol(value)) {
              return NAN;
            }
            return +value;
          }
          function baseToString(value) {
            if (typeof value == "string") {
              return value;
            }
            if (isArray(value)) {
              return arrayMap(value, baseToString) + "";
            }
            if (isSymbol(value)) {
              return symbolToString ? symbolToString.call(value) : "";
            }
            var result2 = value + "";
            return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
          }
          function baseUniq(array2, iteratee2, comparator) {
            var index2 = -1, includes2 = arrayIncludes, length = array2.length, isCommon = true, result2 = [], seen = result2;
            if (comparator) {
              isCommon = false;
              includes2 = arrayIncludesWith;
            } else if (length >= LARGE_ARRAY_SIZE) {
              var set4 = iteratee2 ? null : createSet(array2);
              if (set4) {
                return setToArray(set4);
              }
              isCommon = false;
              includes2 = cacheHas;
              seen = new SetCache();
            } else {
              seen = iteratee2 ? [] : result2;
            }
            outer:
              while (++index2 < length) {
                var value = array2[index2], computed = iteratee2 ? iteratee2(value) : value;
                value = comparator || value !== 0 ? value : 0;
                if (isCommon && computed === computed) {
                  var seenIndex = seen.length;
                  while (seenIndex--) {
                    if (seen[seenIndex] === computed) {
                      continue outer;
                    }
                  }
                  if (iteratee2) {
                    seen.push(computed);
                  }
                  result2.push(value);
                } else if (!includes2(seen, computed, comparator)) {
                  if (seen !== result2) {
                    seen.push(computed);
                  }
                  result2.push(value);
                }
              }
            return result2;
          }
          function baseUnset(object, path2) {
            path2 = castPath(path2, object);
            object = parent2(object, path2);
            return object == null || delete object[toKey(last(path2))];
          }
          function baseUpdate(object, path2, updater, customizer) {
            return baseSet(object, path2, updater(baseGet(object, path2)), customizer);
          }
          function baseWhile(array2, predicate, isDrop, fromRight) {
            var length = array2.length, index2 = fromRight ? length : -1;
            while ((fromRight ? index2-- : ++index2 < length) && predicate(array2[index2], index2, array2)) {
            }
            return isDrop ? baseSlice(array2, fromRight ? 0 : index2, fromRight ? index2 + 1 : length) : baseSlice(array2, fromRight ? index2 + 1 : 0, fromRight ? length : index2);
          }
          function baseWrapperValue(value, actions) {
            var result2 = value;
            if (result2 instanceof LazyWrapper) {
              result2 = result2.value();
            }
            return arrayReduce(actions, function(result3, action) {
              return action.func.apply(action.thisArg, arrayPush([result3], action.args));
            }, result2);
          }
          function baseXor(arrays, iteratee2, comparator) {
            var length = arrays.length;
            if (length < 2) {
              return length ? baseUniq(arrays[0]) : [];
            }
            var index2 = -1, result2 = Array2(length);
            while (++index2 < length) {
              var array2 = arrays[index2], othIndex = -1;
              while (++othIndex < length) {
                if (othIndex != index2) {
                  result2[index2] = baseDifference(result2[index2] || array2, arrays[othIndex], iteratee2, comparator);
                }
              }
            }
            return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
          }
          function baseZipObject(props, values2, assignFunc) {
            var index2 = -1, length = props.length, valsLength = values2.length, result2 = {};
            while (++index2 < length) {
              var value = index2 < valsLength ? values2[index2] : undefined2;
              assignFunc(result2, props[index2], value);
            }
            return result2;
          }
          function castArrayLikeObject(value) {
            return isArrayLikeObject(value) ? value : [];
          }
          function castFunction(value) {
            return typeof value == "function" ? value : identity3;
          }
          function castPath(value, object) {
            if (isArray(value)) {
              return value;
            }
            return isKey(value, object) ? [value] : stringToPath(toString(value));
          }
          var castRest = baseRest;
          function castSlice(array2, start2, end) {
            var length = array2.length;
            end = end === undefined2 ? length : end;
            return !start2 && end >= length ? array2 : baseSlice(array2, start2, end);
          }
          var clearTimeout2 = ctxClearTimeout || function(id2) {
            return root2.clearTimeout(id2);
          };
          function cloneBuffer(buffer, isDeep) {
            if (isDeep) {
              return buffer.slice();
            }
            var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
            buffer.copy(result2);
            return result2;
          }
          function cloneArrayBuffer(arrayBuffer) {
            var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
            new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
            return result2;
          }
          function cloneDataView(dataView, isDeep) {
            var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
            return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
          }
          function cloneRegExp(regexp) {
            var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
            result2.lastIndex = regexp.lastIndex;
            return result2;
          }
          function cloneSymbol(symbol) {
            return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
          }
          function cloneTypedArray(typedArray, isDeep) {
            var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
            return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
          }
          function compareAscending(value, other) {
            if (value !== other) {
              var valIsDefined = value !== undefined2, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
              var othIsDefined = other !== undefined2, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
              if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
                return 1;
              }
              if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
                return -1;
              }
            }
            return 0;
          }
          function compareMultiple(object, other, orders) {
            var index2 = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
            while (++index2 < length) {
              var result2 = compareAscending(objCriteria[index2], othCriteria[index2]);
              if (result2) {
                if (index2 >= ordersLength) {
                  return result2;
                }
                var order = orders[index2];
                return result2 * (order == "desc" ? -1 : 1);
              }
            }
            return object.index - other.index;
          }
          function composeArgs(args, partials, holders, isCurried) {
            var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
            while (++leftIndex < leftLength) {
              result2[leftIndex] = partials[leftIndex];
            }
            while (++argsIndex < holdersLength) {
              if (isUncurried || argsIndex < argsLength) {
                result2[holders[argsIndex]] = args[argsIndex];
              }
            }
            while (rangeLength--) {
              result2[leftIndex++] = args[argsIndex++];
            }
            return result2;
          }
          function composeArgsRight(args, partials, holders, isCurried) {
            var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
            while (++argsIndex < rangeLength) {
              result2[argsIndex] = args[argsIndex];
            }
            var offset = argsIndex;
            while (++rightIndex < rightLength) {
              result2[offset + rightIndex] = partials[rightIndex];
            }
            while (++holdersIndex < holdersLength) {
              if (isUncurried || argsIndex < argsLength) {
                result2[offset + holders[holdersIndex]] = args[argsIndex++];
              }
            }
            return result2;
          }
          function copyArray(source, array2) {
            var index2 = -1, length = source.length;
            array2 || (array2 = Array2(length));
            while (++index2 < length) {
              array2[index2] = source[index2];
            }
            return array2;
          }
          function copyObject(source, props, object, customizer) {
            var isNew = !object;
            object || (object = {});
            var index2 = -1, length = props.length;
            while (++index2 < length) {
              var key = props[index2];
              var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined2;
              if (newValue === undefined2) {
                newValue = source[key];
              }
              if (isNew) {
                baseAssignValue(object, key, newValue);
              } else {
                assignValue(object, key, newValue);
              }
            }
            return object;
          }
          function copySymbols(source, object) {
            return copyObject(source, getSymbols(source), object);
          }
          function copySymbolsIn(source, object) {
            return copyObject(source, getSymbolsIn(source), object);
          }
          function createAggregator(setter, initializer) {
            return function(collection, iteratee2) {
              var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
              return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
            };
          }
          function createAssigner(assigner) {
            return baseRest(function(object, sources) {
              var index2 = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined2, guard = length > 2 ? sources[2] : undefined2;
              customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined2;
              if (guard && isIterateeCall(sources[0], sources[1], guard)) {
                customizer = length < 3 ? undefined2 : customizer;
                length = 1;
              }
              object = Object2(object);
              while (++index2 < length) {
                var source = sources[index2];
                if (source) {
                  assigner(object, source, index2, customizer);
                }
              }
              return object;
            });
          }
          function createBaseEach(eachFunc, fromRight) {
            return function(collection, iteratee2) {
              if (collection == null) {
                return collection;
              }
              if (!isArrayLike(collection)) {
                return eachFunc(collection, iteratee2);
              }
              var length = collection.length, index2 = fromRight ? length : -1, iterable = Object2(collection);
              while (fromRight ? index2-- : ++index2 < length) {
                if (iteratee2(iterable[index2], index2, iterable) === false) {
                  break;
                }
              }
              return collection;
            };
          }
          function createBaseFor(fromRight) {
            return function(object, iteratee2, keysFunc) {
              var index2 = -1, iterable = Object2(object), props = keysFunc(object), length = props.length;
              while (length--) {
                var key = props[fromRight ? length : ++index2];
                if (iteratee2(iterable[key], key, iterable) === false) {
                  break;
                }
              }
              return object;
            };
          }
          function createBind(func, bitmask, thisArg) {
            var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
            function wrapper() {
              var fn = this && this !== root2 && this instanceof wrapper ? Ctor : func;
              return fn.apply(isBind ? thisArg : this, arguments);
            }
            return wrapper;
          }
          function createCaseFirst(methodName) {
            return function(string) {
              string = toString(string);
              var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined2;
              var chr = strSymbols ? strSymbols[0] : string.charAt(0);
              var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
              return chr[methodName]() + trailing;
            };
          }
          function createCompounder(callback) {
            return function(string) {
              return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
            };
          }
          function createCtor(Ctor) {
            return function() {
              var args = arguments;
              switch (args.length) {
                case 0:
                  return new Ctor();
                case 1:
                  return new Ctor(args[0]);
                case 2:
                  return new Ctor(args[0], args[1]);
                case 3:
                  return new Ctor(args[0], args[1], args[2]);
                case 4:
                  return new Ctor(args[0], args[1], args[2], args[3]);
                case 5:
                  return new Ctor(args[0], args[1], args[2], args[3], args[4]);
                case 6:
                  return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
                case 7:
                  return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
              }
              var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
              return isObject(result2) ? result2 : thisBinding;
            };
          }
          function createCurry(func, bitmask, arity) {
            var Ctor = createCtor(func);
            function wrapper() {
              var length = arguments.length, args = Array2(length), index2 = length, placeholder = getHolder(wrapper);
              while (index2--) {
                args[index2] = arguments[index2];
              }
              var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
              length -= holders.length;
              if (length < arity) {
                return createRecurry(
                  func,
                  bitmask,
                  createHybrid,
                  wrapper.placeholder,
                  undefined2,
                  args,
                  holders,
                  undefined2,
                  undefined2,
                  arity - length
                );
              }
              var fn = this && this !== root2 && this instanceof wrapper ? Ctor : func;
              return apply(fn, this, args);
            }
            return wrapper;
          }
          function createFind(findIndexFunc) {
            return function(collection, predicate, fromIndex) {
              var iterable = Object2(collection);
              if (!isArrayLike(collection)) {
                var iteratee2 = getIteratee(predicate, 3);
                collection = keys(collection);
                predicate = function(key) {
                  return iteratee2(iterable[key], key, iterable);
                };
              }
              var index2 = findIndexFunc(collection, predicate, fromIndex);
              return index2 > -1 ? iterable[iteratee2 ? collection[index2] : index2] : undefined2;
            };
          }
          function createFlow(fromRight) {
            return flatRest(function(funcs) {
              var length = funcs.length, index2 = length, prereq = LodashWrapper.prototype.thru;
              if (fromRight) {
                funcs.reverse();
              }
              while (index2--) {
                var func = funcs[index2];
                if (typeof func != "function") {
                  throw new TypeError2(FUNC_ERROR_TEXT);
                }
                if (prereq && !wrapper && getFuncName(func) == "wrapper") {
                  var wrapper = new LodashWrapper([], true);
                }
              }
              index2 = wrapper ? index2 : length;
              while (++index2 < length) {
                func = funcs[index2];
                var funcName = getFuncName(func), data = funcName == "wrapper" ? getData2(func) : undefined2;
                if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
                  wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
                } else {
                  wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
                }
              }
              return function() {
                var args = arguments, value = args[0];
                if (wrapper && args.length == 1 && isArray(value)) {
                  return wrapper.plant(value).value();
                }
                var index3 = 0, result2 = length ? funcs[index3].apply(this, args) : value;
                while (++index3 < length) {
                  result2 = funcs[index3].call(this, result2);
                }
                return result2;
              };
            });
          }
          function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
            var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined2 : createCtor(func);
            function wrapper() {
              var length = arguments.length, args = Array2(length), index2 = length;
              while (index2--) {
                args[index2] = arguments[index2];
              }
              if (isCurried) {
                var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
              }
              if (partials) {
                args = composeArgs(args, partials, holders, isCurried);
              }
              if (partialsRight) {
                args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
              }
              length -= holdersCount;
              if (isCurried && length < arity) {
                var newHolders = replaceHolders(args, placeholder);
                return createRecurry(
                  func,
                  bitmask,
                  createHybrid,
                  wrapper.placeholder,
                  thisArg,
                  args,
                  newHolders,
                  argPos,
                  ary2,
                  arity - length
                );
              }
              var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
              length = args.length;
              if (argPos) {
                args = reorder(args, argPos);
              } else if (isFlip && length > 1) {
                args.reverse();
              }
              if (isAry && ary2 < length) {
                args.length = ary2;
              }
              if (this && this !== root2 && this instanceof wrapper) {
                fn = Ctor || createCtor(fn);
              }
              return fn.apply(thisBinding, args);
            }
            return wrapper;
          }
          function createInverter(setter, toIteratee) {
            return function(object, iteratee2) {
              return baseInverter(object, setter, toIteratee(iteratee2), {});
            };
          }
          function createMathOperation(operator, defaultValue2) {
            return function(value, other) {
              var result2;
              if (value === undefined2 && other === undefined2) {
                return defaultValue2;
              }
              if (value !== undefined2) {
                result2 = value;
              }
              if (other !== undefined2) {
                if (result2 === undefined2) {
                  return other;
                }
                if (typeof value == "string" || typeof other == "string") {
                  value = baseToString(value);
                  other = baseToString(other);
                } else {
                  value = baseToNumber(value);
                  other = baseToNumber(other);
                }
                result2 = operator(value, other);
              }
              return result2;
            };
          }
          function createOver(arrayFunc) {
            return flatRest(function(iteratees) {
              iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
              return baseRest(function(args) {
                var thisArg = this;
                return arrayFunc(iteratees, function(iteratee2) {
                  return apply(iteratee2, thisArg, args);
                });
              });
            });
          }
          function createPadding(length, chars) {
            chars = chars === undefined2 ? " " : baseToString(chars);
            var charsLength = chars.length;
            if (charsLength < 2) {
              return charsLength ? baseRepeat(chars, length) : chars;
            }
            var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
            return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
          }
          function createPartial(func, bitmask, thisArg, partials) {
            var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
            function wrapper() {
              var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root2 && this instanceof wrapper ? Ctor : func;
              while (++leftIndex < leftLength) {
                args[leftIndex] = partials[leftIndex];
              }
              while (argsLength--) {
                args[leftIndex++] = arguments[++argsIndex];
              }
              return apply(fn, isBind ? thisArg : this, args);
            }
            return wrapper;
          }
          function createRange(fromRight) {
            return function(start2, end, step) {
              if (step && typeof step != "number" && isIterateeCall(start2, end, step)) {
                end = step = undefined2;
              }
              start2 = toFinite(start2);
              if (end === undefined2) {
                end = start2;
                start2 = 0;
              } else {
                end = toFinite(end);
              }
              step = step === undefined2 ? start2 < end ? 1 : -1 : toFinite(step);
              return baseRange(start2, end, step, fromRight);
            };
          }
          function createRelationalOperation(operator) {
            return function(value, other) {
              if (!(typeof value == "string" && typeof other == "string")) {
                value = toNumber(value);
                other = toNumber(other);
              }
              return operator(value, other);
            };
          }
          function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
            var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined2, newHoldersRight = isCurry ? undefined2 : holders, newPartials = isCurry ? partials : undefined2, newPartialsRight = isCurry ? undefined2 : partials;
            bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
            bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
            if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
              bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
            }
            var newData = [
              func,
              bitmask,
              thisArg,
              newPartials,
              newHolders,
              newPartialsRight,
              newHoldersRight,
              argPos,
              ary2,
              arity
            ];
            var result2 = wrapFunc.apply(undefined2, newData);
            if (isLaziable(func)) {
              setData(result2, newData);
            }
            result2.placeholder = placeholder;
            return setWrapToString(result2, func, bitmask);
          }
          function createRound(methodName) {
            var func = Math2[methodName];
            return function(number, precision) {
              number = toNumber(number);
              precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
              if (precision && nativeIsFinite(number)) {
                var pair = (toString(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
                pair = (toString(value) + "e").split("e");
                return +(pair[0] + "e" + (+pair[1] - precision));
              }
              return func(number);
            };
          }
          var createSet = !(Set && 1 / setToArray(new Set([, -0]))[1] == INFINITY) ? noop2 : function(values2) {
            return new Set(values2);
          };
          function createToPairs(keysFunc) {
            return function(object) {
              var tag = getTag(object);
              if (tag == mapTag) {
                return mapToArray(object);
              }
              if (tag == setTag) {
                return setToPairs(object);
              }
              return baseToPairs(object, keysFunc(object));
            };
          }
          function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
            var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
            if (!isBindKey && typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            var length = partials ? partials.length : 0;
            if (!length) {
              bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
              partials = holders = undefined2;
            }
            ary2 = ary2 === undefined2 ? ary2 : nativeMax(toInteger(ary2), 0);
            arity = arity === undefined2 ? arity : toInteger(arity);
            length -= holders ? holders.length : 0;
            if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
              var partialsRight = partials, holdersRight = holders;
              partials = holders = undefined2;
            }
            var data = isBindKey ? undefined2 : getData2(func);
            var newData = [
              func,
              bitmask,
              thisArg,
              partials,
              holders,
              partialsRight,
              holdersRight,
              argPos,
              ary2,
              arity
            ];
            if (data) {
              mergeData(newData, data);
            }
            func = newData[0];
            bitmask = newData[1];
            thisArg = newData[2];
            partials = newData[3];
            holders = newData[4];
            arity = newData[9] = newData[9] === undefined2 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
            if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
              bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
            }
            if (!bitmask || bitmask == WRAP_BIND_FLAG) {
              var result2 = createBind(func, bitmask, thisArg);
            } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
              result2 = createCurry(func, bitmask, arity);
            } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
              result2 = createPartial(func, bitmask, thisArg, partials);
            } else {
              result2 = createHybrid.apply(undefined2, newData);
            }
            var setter = data ? baseSetData : setData;
            return setWrapToString(setter(result2, newData), func, bitmask);
          }
          function customDefaultsAssignIn(objValue, srcValue, key, object) {
            if (objValue === undefined2 || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {
              return srcValue;
            }
            return objValue;
          }
          function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
            if (isObject(objValue) && isObject(srcValue)) {
              stack.set(srcValue, objValue);
              baseMerge(objValue, srcValue, undefined2, customDefaultsMerge, stack);
              stack["delete"](srcValue);
            }
            return objValue;
          }
          function customOmitClone(value) {
            return isPlainObject(value) ? undefined2 : value;
          }
          function equalArrays(array2, other, bitmask, customizer, equalFunc, stack) {
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array2.length, othLength = other.length;
            if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
              return false;
            }
            var arrStacked = stack.get(array2);
            var othStacked = stack.get(other);
            if (arrStacked && othStacked) {
              return arrStacked == other && othStacked == array2;
            }
            var index2 = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined2;
            stack.set(array2, other);
            stack.set(other, array2);
            while (++index2 < arrLength) {
              var arrValue = array2[index2], othValue = other[index2];
              if (customizer) {
                var compared = isPartial ? customizer(othValue, arrValue, index2, other, array2, stack) : customizer(arrValue, othValue, index2, array2, other, stack);
              }
              if (compared !== undefined2) {
                if (compared) {
                  continue;
                }
                result2 = false;
                break;
              }
              if (seen) {
                if (!arraySome(other, function(othValue2, othIndex) {
                  if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                    return seen.push(othIndex);
                  }
                })) {
                  result2 = false;
                  break;
                }
              } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                result2 = false;
                break;
              }
            }
            stack["delete"](array2);
            stack["delete"](other);
            return result2;
          }
          function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
            switch (tag) {
              case dataViewTag:
                if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                  return false;
                }
                object = object.buffer;
                other = other.buffer;
              case arrayBufferTag:
                if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
                  return false;
                }
                return true;
              case boolTag:
              case dateTag:
              case numberTag:
                return eq(+object, +other);
              case errorTag:
                return object.name == other.name && object.message == other.message;
              case regexpTag:
              case stringTag:
                return object == other + "";
              case mapTag:
                var convert = mapToArray;
              case setTag:
                var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
                convert || (convert = setToArray);
                if (object.size != other.size && !isPartial) {
                  return false;
                }
                var stacked = stack.get(object);
                if (stacked) {
                  return stacked == other;
                }
                bitmask |= COMPARE_UNORDERED_FLAG;
                stack.set(object, other);
                var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
                stack["delete"](object);
                return result2;
              case symbolTag:
                if (symbolValueOf) {
                  return symbolValueOf.call(object) == symbolValueOf.call(other);
                }
            }
            return false;
          }
          function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
            if (objLength != othLength && !isPartial) {
              return false;
            }
            var index2 = objLength;
            while (index2--) {
              var key = objProps[index2];
              if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
                return false;
              }
            }
            var objStacked = stack.get(object);
            var othStacked = stack.get(other);
            if (objStacked && othStacked) {
              return objStacked == other && othStacked == object;
            }
            var result2 = true;
            stack.set(object, other);
            stack.set(other, object);
            var skipCtor = isPartial;
            while (++index2 < objLength) {
              key = objProps[index2];
              var objValue = object[key], othValue = other[key];
              if (customizer) {
                var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
              }
              if (!(compared === undefined2 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
                result2 = false;
                break;
              }
              skipCtor || (skipCtor = key == "constructor");
            }
            if (result2 && !skipCtor) {
              var objCtor = object.constructor, othCtor = other.constructor;
              if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
                result2 = false;
              }
            }
            stack["delete"](object);
            stack["delete"](other);
            return result2;
          }
          function flatRest(func) {
            return setToString(overRest(func, undefined2, flatten), func + "");
          }
          function getAllKeys(object) {
            return baseGetAllKeys(object, keys, getSymbols);
          }
          function getAllKeysIn(object) {
            return baseGetAllKeys(object, keysIn, getSymbolsIn);
          }
          var getData2 = !metaMap ? noop2 : function(func) {
            return metaMap.get(func);
          };
          function getFuncName(func) {
            var result2 = func.name + "", array2 = realNames[result2], length = hasOwnProperty.call(realNames, result2) ? array2.length : 0;
            while (length--) {
              var data = array2[length], otherFunc = data.func;
              if (otherFunc == null || otherFunc == func) {
                return data.name;
              }
            }
            return result2;
          }
          function getHolder(func) {
            var object = hasOwnProperty.call(lodash, "placeholder") ? lodash : func;
            return object.placeholder;
          }
          function getIteratee() {
            var result2 = lodash.iteratee || iteratee;
            result2 = result2 === iteratee ? baseIteratee : result2;
            return arguments.length ? result2(arguments[0], arguments[1]) : result2;
          }
          function getMapData(map5, key) {
            var data = map5.__data__;
            return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
          }
          function getMatchData(object) {
            var result2 = keys(object), length = result2.length;
            while (length--) {
              var key = result2[length], value = object[key];
              result2[length] = [key, value, isStrictComparable(value)];
            }
            return result2;
          }
          function getNative(object, key) {
            var value = getValue(object, key);
            return baseIsNative(value) ? value : undefined2;
          }
          function getRawTag(value) {
            var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
            try {
              value[symToStringTag] = undefined2;
              var unmasked = true;
            } catch (e) {
            }
            var result2 = nativeObjectToString.call(value);
            if (unmasked) {
              if (isOwn) {
                value[symToStringTag] = tag;
              } else {
                delete value[symToStringTag];
              }
            }
            return result2;
          }
          var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
            if (object == null) {
              return [];
            }
            object = Object2(object);
            return arrayFilter(nativeGetSymbols(object), function(symbol) {
              return propertyIsEnumerable.call(object, symbol);
            });
          };
          var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
            var result2 = [];
            while (object) {
              arrayPush(result2, getSymbols(object));
              object = getPrototype(object);
            }
            return result2;
          };
          var getTag = baseGetTag;
          if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
            getTag = function(value) {
              var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined2, ctorString = Ctor ? toSource(Ctor) : "";
              if (ctorString) {
                switch (ctorString) {
                  case dataViewCtorString:
                    return dataViewTag;
                  case mapCtorString:
                    return mapTag;
                  case promiseCtorString:
                    return promiseTag;
                  case setCtorString:
                    return setTag;
                  case weakMapCtorString:
                    return weakMapTag;
                }
              }
              return result2;
            };
          }
          function getView(start2, end, transforms) {
            var index2 = -1, length = transforms.length;
            while (++index2 < length) {
              var data = transforms[index2], size2 = data.size;
              switch (data.type) {
                case "drop":
                  start2 += size2;
                  break;
                case "dropRight":
                  end -= size2;
                  break;
                case "take":
                  end = nativeMin(end, start2 + size2);
                  break;
                case "takeRight":
                  start2 = nativeMax(start2, end - size2);
                  break;
              }
            }
            return { "start": start2, "end": end };
          }
          function getWrapDetails(source) {
            var match = source.match(reWrapDetails);
            return match ? match[1].split(reSplitDetails) : [];
          }
          function hasPath(object, path2, hasFunc) {
            path2 = castPath(path2, object);
            var index2 = -1, length = path2.length, result2 = false;
            while (++index2 < length) {
              var key = toKey(path2[index2]);
              if (!(result2 = object != null && hasFunc(object, key))) {
                break;
              }
              object = object[key];
            }
            if (result2 || ++index2 != length) {
              return result2;
            }
            length = object == null ? 0 : object.length;
            return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
          }
          function initCloneArray(array2) {
            var length = array2.length, result2 = new array2.constructor(length);
            if (length && typeof array2[0] == "string" && hasOwnProperty.call(array2, "index")) {
              result2.index = array2.index;
              result2.input = array2.input;
            }
            return result2;
          }
          function initCloneObject(object) {
            return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
          }
          function initCloneByTag(object, tag, isDeep) {
            var Ctor = object.constructor;
            switch (tag) {
              case arrayBufferTag:
                return cloneArrayBuffer(object);
              case boolTag:
              case dateTag:
                return new Ctor(+object);
              case dataViewTag:
                return cloneDataView(object, isDeep);
              case float32Tag:
              case float64Tag:
              case int8Tag:
              case int16Tag:
              case int32Tag:
              case uint8Tag:
              case uint8ClampedTag:
              case uint16Tag:
              case uint32Tag:
                return cloneTypedArray(object, isDeep);
              case mapTag:
                return new Ctor();
              case numberTag:
              case stringTag:
                return new Ctor(object);
              case regexpTag:
                return cloneRegExp(object);
              case setTag:
                return new Ctor();
              case symbolTag:
                return cloneSymbol(object);
            }
          }
          function insertWrapDetails(source, details) {
            var length = details.length;
            if (!length) {
              return source;
            }
            var lastIndex = length - 1;
            details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
            details = details.join(length > 2 ? ", " : " ");
            return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
          }
          function isFlattenable(value) {
            return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
          }
          function isIndex(value, length) {
            var type2 = typeof value;
            length = length == null ? MAX_SAFE_INTEGER : length;
            return !!length && (type2 == "number" || type2 != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
          }
          function isIterateeCall(value, index2, object) {
            if (!isObject(object)) {
              return false;
            }
            var type2 = typeof index2;
            if (type2 == "number" ? isArrayLike(object) && isIndex(index2, object.length) : type2 == "string" && index2 in object) {
              return eq(object[index2], value);
            }
            return false;
          }
          function isKey(value, object) {
            if (isArray(value)) {
              return false;
            }
            var type2 = typeof value;
            if (type2 == "number" || type2 == "symbol" || type2 == "boolean" || value == null || isSymbol(value)) {
              return true;
            }
            return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
          }
          function isKeyable(value) {
            var type2 = typeof value;
            return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
          }
          function isLaziable(func) {
            var funcName = getFuncName(func), other = lodash[funcName];
            if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
              return false;
            }
            if (func === other) {
              return true;
            }
            var data = getData2(other);
            return !!data && func === data[0];
          }
          function isMasked(func) {
            return !!maskSrcKey && maskSrcKey in func;
          }
          var isMaskable = coreJsData ? isFunction : stubFalse;
          function isPrototype(value) {
            var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
            return value === proto;
          }
          function isStrictComparable(value) {
            return value === value && !isObject(value);
          }
          function matchesStrictComparable(key, srcValue) {
            return function(object) {
              if (object == null) {
                return false;
              }
              return object[key] === srcValue && (srcValue !== undefined2 || key in Object2(object));
            };
          }
          function memoizeCapped(func) {
            var result2 = memoize(func, function(key) {
              if (cache.size === MAX_MEMOIZE_SIZE) {
                cache.clear();
              }
              return key;
            });
            var cache = result2.cache;
            return result2;
          }
          function mergeData(data, source) {
            var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
            var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
            if (!(isCommon || isCombo)) {
              return data;
            }
            if (srcBitmask & WRAP_BIND_FLAG) {
              data[2] = source[2];
              newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
            }
            var value = source[3];
            if (value) {
              var partials = data[3];
              data[3] = partials ? composeArgs(partials, value, source[4]) : value;
              data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
            }
            value = source[5];
            if (value) {
              partials = data[5];
              data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
              data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
            }
            value = source[7];
            if (value) {
              data[7] = value;
            }
            if (srcBitmask & WRAP_ARY_FLAG) {
              data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
            }
            if (data[9] == null) {
              data[9] = source[9];
            }
            data[0] = source[0];
            data[1] = newBitmask;
            return data;
          }
          function nativeKeysIn(object) {
            var result2 = [];
            if (object != null) {
              for (var key in Object2(object)) {
                result2.push(key);
              }
            }
            return result2;
          }
          function objectToString(value) {
            return nativeObjectToString.call(value);
          }
          function overRest(func, start2, transform3) {
            start2 = nativeMax(start2 === undefined2 ? func.length - 1 : start2, 0);
            return function() {
              var args = arguments, index2 = -1, length = nativeMax(args.length - start2, 0), array2 = Array2(length);
              while (++index2 < length) {
                array2[index2] = args[start2 + index2];
              }
              index2 = -1;
              var otherArgs = Array2(start2 + 1);
              while (++index2 < start2) {
                otherArgs[index2] = args[index2];
              }
              otherArgs[start2] = transform3(array2);
              return apply(func, this, otherArgs);
            };
          }
          function parent2(object, path2) {
            return path2.length < 2 ? object : baseGet(object, baseSlice(path2, 0, -1));
          }
          function reorder(array2, indexes) {
            var arrLength = array2.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array2);
            while (length--) {
              var index2 = indexes[length];
              array2[length] = isIndex(index2, arrLength) ? oldArray[index2] : undefined2;
            }
            return array2;
          }
          function safeGet(object, key) {
            if (key === "constructor" && typeof object[key] === "function") {
              return;
            }
            if (key == "__proto__") {
              return;
            }
            return object[key];
          }
          var setData = shortOut(baseSetData);
          var setTimeout2 = ctxSetTimeout || function(func, wait) {
            return root2.setTimeout(func, wait);
          };
          var setToString = shortOut(baseSetToString);
          function setWrapToString(wrapper, reference, bitmask) {
            var source = reference + "";
            return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
          }
          function shortOut(func) {
            var count = 0, lastCalled = 0;
            return function() {
              var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
              lastCalled = stamp;
              if (remaining > 0) {
                if (++count >= HOT_COUNT) {
                  return arguments[0];
                }
              } else {
                count = 0;
              }
              return func.apply(undefined2, arguments);
            };
          }
          function shuffleSelf(array2, size2) {
            var index2 = -1, length = array2.length, lastIndex = length - 1;
            size2 = size2 === undefined2 ? length : size2;
            while (++index2 < size2) {
              var rand = baseRandom(index2, lastIndex), value = array2[rand];
              array2[rand] = array2[index2];
              array2[index2] = value;
            }
            array2.length = size2;
            return array2;
          }
          var stringToPath = memoizeCapped(function(string) {
            var result2 = [];
            if (string.charCodeAt(0) === 46) {
              result2.push("");
            }
            string.replace(rePropName, function(match, number, quote, subString) {
              result2.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
            });
            return result2;
          });
          function toKey(value) {
            if (typeof value == "string" || isSymbol(value)) {
              return value;
            }
            var result2 = value + "";
            return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
          }
          function toSource(func) {
            if (func != null) {
              try {
                return funcToString.call(func);
              } catch (e) {
              }
              try {
                return func + "";
              } catch (e) {
              }
            }
            return "";
          }
          function updateWrapDetails(details, bitmask) {
            arrayEach(wrapFlags, function(pair) {
              var value = "_." + pair[0];
              if (bitmask & pair[1] && !arrayIncludes(details, value)) {
                details.push(value);
              }
            });
            return details.sort();
          }
          function wrapperClone(wrapper) {
            if (wrapper instanceof LazyWrapper) {
              return wrapper.clone();
            }
            var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
            result2.__actions__ = copyArray(wrapper.__actions__);
            result2.__index__ = wrapper.__index__;
            result2.__values__ = wrapper.__values__;
            return result2;
          }
          function chunk(array2, size2, guard) {
            if (guard ? isIterateeCall(array2, size2, guard) : size2 === undefined2) {
              size2 = 1;
            } else {
              size2 = nativeMax(toInteger(size2), 0);
            }
            var length = array2 == null ? 0 : array2.length;
            if (!length || size2 < 1) {
              return [];
            }
            var index2 = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size2));
            while (index2 < length) {
              result2[resIndex++] = baseSlice(array2, index2, index2 += size2);
            }
            return result2;
          }
          function compact(array2) {
            var index2 = -1, length = array2 == null ? 0 : array2.length, resIndex = 0, result2 = [];
            while (++index2 < length) {
              var value = array2[index2];
              if (value) {
                result2[resIndex++] = value;
              }
            }
            return result2;
          }
          function concat() {
            var length = arguments.length;
            if (!length) {
              return [];
            }
            var args = Array2(length - 1), array2 = arguments[0], index2 = length;
            while (index2--) {
              args[index2 - 1] = arguments[index2];
            }
            return arrayPush(isArray(array2) ? copyArray(array2) : [array2], baseFlatten(args, 1));
          }
          var difference = baseRest(function(array2, values2) {
            return isArrayLikeObject(array2) ? baseDifference(array2, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
          });
          var differenceBy = baseRest(function(array2, values2) {
            var iteratee2 = last(values2);
            if (isArrayLikeObject(iteratee2)) {
              iteratee2 = undefined2;
            }
            return isArrayLikeObject(array2) ? baseDifference(array2, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
          });
          var differenceWith = baseRest(function(array2, values2) {
            var comparator = last(values2);
            if (isArrayLikeObject(comparator)) {
              comparator = undefined2;
            }
            return isArrayLikeObject(array2) ? baseDifference(array2, baseFlatten(values2, 1, isArrayLikeObject, true), undefined2, comparator) : [];
          });
          function drop(array2, n, guard) {
            var length = array2 == null ? 0 : array2.length;
            if (!length) {
              return [];
            }
            n = guard || n === undefined2 ? 1 : toInteger(n);
            return baseSlice(array2, n < 0 ? 0 : n, length);
          }
          function dropRight(array2, n, guard) {
            var length = array2 == null ? 0 : array2.length;
            if (!length) {
              return [];
            }
            n = guard || n === undefined2 ? 1 : toInteger(n);
            n = length - n;
            return baseSlice(array2, 0, n < 0 ? 0 : n);
          }
          function dropRightWhile(array2, predicate) {
            return array2 && array2.length ? baseWhile(array2, getIteratee(predicate, 3), true, true) : [];
          }
          function dropWhile(array2, predicate) {
            return array2 && array2.length ? baseWhile(array2, getIteratee(predicate, 3), true) : [];
          }
          function fill(array2, value, start2, end) {
            var length = array2 == null ? 0 : array2.length;
            if (!length) {
              return [];
            }
            if (start2 && typeof start2 != "number" && isIterateeCall(array2, value, start2)) {
              start2 = 0;
              end = length;
            }
            return baseFill(array2, value, start2, end);
          }
          function findIndex(array2, predicate, fromIndex) {
            var length = array2 == null ? 0 : array2.length;
            if (!length) {
              return -1;
            }
            var index2 = fromIndex == null ? 0 : toInteger(fromIndex);
            if (index2 < 0) {
              index2 = nativeMax(length + index2, 0);
            }
            return baseFindIndex(array2, getIteratee(predicate, 3), index2);
          }
          function findLastIndex(array2, predicate, fromIndex) {
            var length = array2 == null ? 0 : array2.length;
            if (!length) {
              return -1;
            }
            var index2 = length - 1;
            if (fromIndex !== undefined2) {
              index2 = toInteger(fromIndex);
              index2 = fromIndex < 0 ? nativeMax(length + index2, 0) : nativeMin(index2, length - 1);
            }
            return baseFindIndex(array2, getIteratee(predicate, 3), index2, true);
          }
          function flatten(array2) {
            var length = array2 == null ? 0 : array2.length;
            return length ? baseFlatten(array2, 1) : [];
          }
          function flattenDeep(array2) {
            var length = array2 == null ? 0 : array2.length;
            return length ? baseFlatten(array2, INFINITY) : [];
          }
          function flattenDepth(array2, depth) {
            var length = array2 == null ? 0 : array2.length;
            if (!length) {
              return [];
            }
            depth = depth === undefined2 ? 1 : toInteger(depth);
            return baseFlatten(array2, depth);
          }
          function fromPairs(pairs) {
            var index2 = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
            while (++index2 < length) {
              var pair = pairs[index2];
              result2[pair[0]] = pair[1];
            }
            return result2;
          }
          function head(array2) {
            return array2 && array2.length ? array2[0] : undefined2;
          }
          function indexOf(array2, value, fromIndex) {
            var length = array2 == null ? 0 : array2.length;
            if (!length) {
              return -1;
            }
            var index2 = fromIndex == null ? 0 : toInteger(fromIndex);
            if (index2 < 0) {
              index2 = nativeMax(length + index2, 0);
            }
            return baseIndexOf(array2, value, index2);
          }
          function initial(array2) {
            var length = array2 == null ? 0 : array2.length;
            return length ? baseSlice(array2, 0, -1) : [];
          }
          var intersection = baseRest(function(arrays) {
            var mapped = arrayMap(arrays, castArrayLikeObject);
            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
          });
          var intersectionBy = baseRest(function(arrays) {
            var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
            if (iteratee2 === last(mapped)) {
              iteratee2 = undefined2;
            } else {
              mapped.pop();
            }
            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
          });
          var intersectionWith = baseRest(function(arrays) {
            var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
            comparator = typeof comparator == "function" ? comparator : undefined2;
            if (comparator) {
              mapped.pop();
            }
            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined2, comparator) : [];
          });
          function join(array2, separator) {
            return array2 == null ? "" : nativeJoin.call(array2, separator);
          }
          function last(array2) {
            var length = array2 == null ? 0 : array2.length;
            return length ? array2[length - 1] : undefined2;
          }
          function lastIndexOf(array2, value, fromIndex) {
            var length = array2 == null ? 0 : array2.length;
            if (!length) {
              return -1;
            }
            var index2 = length;
            if (fromIndex !== undefined2) {
              index2 = toInteger(fromIndex);
              index2 = index2 < 0 ? nativeMax(length + index2, 0) : nativeMin(index2, length - 1);
            }
            return value === value ? strictLastIndexOf(array2, value, index2) : baseFindIndex(array2, baseIsNaN, index2, true);
          }
          function nth(array2, n) {
            return array2 && array2.length ? baseNth(array2, toInteger(n)) : undefined2;
          }
          var pull = baseRest(pullAll);
          function pullAll(array2, values2) {
            return array2 && array2.length && values2 && values2.length ? basePullAll(array2, values2) : array2;
          }
          function pullAllBy(array2, values2, iteratee2) {
            return array2 && array2.length && values2 && values2.length ? basePullAll(array2, values2, getIteratee(iteratee2, 2)) : array2;
          }
          function pullAllWith(array2, values2, comparator) {
            return array2 && array2.length && values2 && values2.length ? basePullAll(array2, values2, undefined2, comparator) : array2;
          }
          var pullAt = flatRest(function(array2, indexes) {
            var length = array2 == null ? 0 : array2.length, result2 = baseAt(array2, indexes);
            basePullAt(array2, arrayMap(indexes, function(index2) {
              return isIndex(index2, length) ? +index2 : index2;
            }).sort(compareAscending));
            return result2;
          });
          function remove2(array2, predicate) {
            var result2 = [];
            if (!(array2 && array2.length)) {
              return result2;
            }
            var index2 = -1, indexes = [], length = array2.length;
            predicate = getIteratee(predicate, 3);
            while (++index2 < length) {
              var value = array2[index2];
              if (predicate(value, index2, array2)) {
                result2.push(value);
                indexes.push(index2);
              }
            }
            basePullAt(array2, indexes);
            return result2;
          }
          function reverse(array2) {
            return array2 == null ? array2 : nativeReverse.call(array2);
          }
          function slice(array2, start2, end) {
            var length = array2 == null ? 0 : array2.length;
            if (!length) {
              return [];
            }
            if (end && typeof end != "number" && isIterateeCall(array2, start2, end)) {
              start2 = 0;
              end = length;
            } else {
              start2 = start2 == null ? 0 : toInteger(start2);
              end = end === undefined2 ? length : toInteger(end);
            }
            return baseSlice(array2, start2, end);
          }
          function sortedIndex(array2, value) {
            return baseSortedIndex(array2, value);
          }
          function sortedIndexBy(array2, value, iteratee2) {
            return baseSortedIndexBy(array2, value, getIteratee(iteratee2, 2));
          }
          function sortedIndexOf(array2, value) {
            var length = array2 == null ? 0 : array2.length;
            if (length) {
              var index2 = baseSortedIndex(array2, value);
              if (index2 < length && eq(array2[index2], value)) {
                return index2;
              }
            }
            return -1;
          }
          function sortedLastIndex(array2, value) {
            return baseSortedIndex(array2, value, true);
          }
          function sortedLastIndexBy(array2, value, iteratee2) {
            return baseSortedIndexBy(array2, value, getIteratee(iteratee2, 2), true);
          }
          function sortedLastIndexOf(array2, value) {
            var length = array2 == null ? 0 : array2.length;
            if (length) {
              var index2 = baseSortedIndex(array2, value, true) - 1;
              if (eq(array2[index2], value)) {
                return index2;
              }
            }
            return -1;
          }
          function sortedUniq(array2) {
            return array2 && array2.length ? baseSortedUniq(array2) : [];
          }
          function sortedUniqBy(array2, iteratee2) {
            return array2 && array2.length ? baseSortedUniq(array2, getIteratee(iteratee2, 2)) : [];
          }
          function tail(array2) {
            var length = array2 == null ? 0 : array2.length;
            return length ? baseSlice(array2, 1, length) : [];
          }
          function take(array2, n, guard) {
            if (!(array2 && array2.length)) {
              return [];
            }
            n = guard || n === undefined2 ? 1 : toInteger(n);
            return baseSlice(array2, 0, n < 0 ? 0 : n);
          }
          function takeRight(array2, n, guard) {
            var length = array2 == null ? 0 : array2.length;
            if (!length) {
              return [];
            }
            n = guard || n === undefined2 ? 1 : toInteger(n);
            n = length - n;
            return baseSlice(array2, n < 0 ? 0 : n, length);
          }
          function takeRightWhile(array2, predicate) {
            return array2 && array2.length ? baseWhile(array2, getIteratee(predicate, 3), false, true) : [];
          }
          function takeWhile(array2, predicate) {
            return array2 && array2.length ? baseWhile(array2, getIteratee(predicate, 3)) : [];
          }
          var union = baseRest(function(arrays) {
            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
          });
          var unionBy = baseRest(function(arrays) {
            var iteratee2 = last(arrays);
            if (isArrayLikeObject(iteratee2)) {
              iteratee2 = undefined2;
            }
            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
          });
          var unionWith = baseRest(function(arrays) {
            var comparator = last(arrays);
            comparator = typeof comparator == "function" ? comparator : undefined2;
            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined2, comparator);
          });
          function uniq2(array2) {
            return array2 && array2.length ? baseUniq(array2) : [];
          }
          function uniqBy(array2, iteratee2) {
            return array2 && array2.length ? baseUniq(array2, getIteratee(iteratee2, 2)) : [];
          }
          function uniqWith(array2, comparator) {
            comparator = typeof comparator == "function" ? comparator : undefined2;
            return array2 && array2.length ? baseUniq(array2, undefined2, comparator) : [];
          }
          function unzip(array2) {
            if (!(array2 && array2.length)) {
              return [];
            }
            var length = 0;
            array2 = arrayFilter(array2, function(group) {
              if (isArrayLikeObject(group)) {
                length = nativeMax(group.length, length);
                return true;
              }
            });
            return baseTimes(length, function(index2) {
              return arrayMap(array2, baseProperty(index2));
            });
          }
          function unzipWith(array2, iteratee2) {
            if (!(array2 && array2.length)) {
              return [];
            }
            var result2 = unzip(array2);
            if (iteratee2 == null) {
              return result2;
            }
            return arrayMap(result2, function(group) {
              return apply(iteratee2, undefined2, group);
            });
          }
          var without = baseRest(function(array2, values2) {
            return isArrayLikeObject(array2) ? baseDifference(array2, values2) : [];
          });
          var xor = baseRest(function(arrays) {
            return baseXor(arrayFilter(arrays, isArrayLikeObject));
          });
          var xorBy = baseRest(function(arrays) {
            var iteratee2 = last(arrays);
            if (isArrayLikeObject(iteratee2)) {
              iteratee2 = undefined2;
            }
            return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
          });
          var xorWith = baseRest(function(arrays) {
            var comparator = last(arrays);
            comparator = typeof comparator == "function" ? comparator : undefined2;
            return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined2, comparator);
          });
          var zip = baseRest(unzip);
          function zipObject(props, values2) {
            return baseZipObject(props || [], values2 || [], assignValue);
          }
          function zipObjectDeep(props, values2) {
            return baseZipObject(props || [], values2 || [], baseSet);
          }
          var zipWith = baseRest(function(arrays) {
            var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined2;
            iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined2;
            return unzipWith(arrays, iteratee2);
          });
          function chain(value) {
            var result2 = lodash(value);
            result2.__chain__ = true;
            return result2;
          }
          function tap(value, interceptor) {
            interceptor(value);
            return value;
          }
          function thru(value, interceptor) {
            return interceptor(value);
          }
          var wrapperAt = flatRest(function(paths) {
            var length = paths.length, start2 = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
              return baseAt(object, paths);
            };
            if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start2)) {
              return this.thru(interceptor);
            }
            value = value.slice(start2, +start2 + (length ? 1 : 0));
            value.__actions__.push({
              "func": thru,
              "args": [interceptor],
              "thisArg": undefined2
            });
            return new LodashWrapper(value, this.__chain__).thru(function(array2) {
              if (length && !array2.length) {
                array2.push(undefined2);
              }
              return array2;
            });
          });
          function wrapperChain() {
            return chain(this);
          }
          function wrapperCommit() {
            return new LodashWrapper(this.value(), this.__chain__);
          }
          function wrapperNext() {
            if (this.__values__ === undefined2) {
              this.__values__ = toArray(this.value());
            }
            var done = this.__index__ >= this.__values__.length, value = done ? undefined2 : this.__values__[this.__index__++];
            return { "done": done, "value": value };
          }
          function wrapperToIterator() {
            return this;
          }
          function wrapperPlant(value) {
            var result2, parent3 = this;
            while (parent3 instanceof baseLodash) {
              var clone2 = wrapperClone(parent3);
              clone2.__index__ = 0;
              clone2.__values__ = undefined2;
              if (result2) {
                previous.__wrapped__ = clone2;
              } else {
                result2 = clone2;
              }
              var previous = clone2;
              parent3 = parent3.__wrapped__;
            }
            previous.__wrapped__ = value;
            return result2;
          }
          function wrapperReverse() {
            var value = this.__wrapped__;
            if (value instanceof LazyWrapper) {
              var wrapped = value;
              if (this.__actions__.length) {
                wrapped = new LazyWrapper(this);
              }
              wrapped = wrapped.reverse();
              wrapped.__actions__.push({
                "func": thru,
                "args": [reverse],
                "thisArg": undefined2
              });
              return new LodashWrapper(wrapped, this.__chain__);
            }
            return this.thru(reverse);
          }
          function wrapperValue() {
            return baseWrapperValue(this.__wrapped__, this.__actions__);
          }
          var countBy = createAggregator(function(result2, value, key) {
            if (hasOwnProperty.call(result2, key)) {
              ++result2[key];
            } else {
              baseAssignValue(result2, key, 1);
            }
          });
          function every(collection, predicate, guard) {
            var func = isArray(collection) ? arrayEvery : baseEvery;
            if (guard && isIterateeCall(collection, predicate, guard)) {
              predicate = undefined2;
            }
            return func(collection, getIteratee(predicate, 3));
          }
          function filter2(collection, predicate) {
            var func = isArray(collection) ? arrayFilter : baseFilter;
            return func(collection, getIteratee(predicate, 3));
          }
          var find3 = createFind(findIndex);
          var findLast = createFind(findLastIndex);
          function flatMap(collection, iteratee2) {
            return baseFlatten(map4(collection, iteratee2), 1);
          }
          function flatMapDeep(collection, iteratee2) {
            return baseFlatten(map4(collection, iteratee2), INFINITY);
          }
          function flatMapDepth(collection, iteratee2, depth) {
            depth = depth === undefined2 ? 1 : toInteger(depth);
            return baseFlatten(map4(collection, iteratee2), depth);
          }
          function forEach(collection, iteratee2) {
            var func = isArray(collection) ? arrayEach : baseEach;
            return func(collection, getIteratee(iteratee2, 3));
          }
          function forEachRight(collection, iteratee2) {
            var func = isArray(collection) ? arrayEachRight : baseEachRight;
            return func(collection, getIteratee(iteratee2, 3));
          }
          var groupBy = createAggregator(function(result2, value, key) {
            if (hasOwnProperty.call(result2, key)) {
              result2[key].push(value);
            } else {
              baseAssignValue(result2, key, [value]);
            }
          });
          function includes(collection, value, fromIndex, guard) {
            collection = isArrayLike(collection) ? collection : values(collection);
            fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
            var length = collection.length;
            if (fromIndex < 0) {
              fromIndex = nativeMax(length + fromIndex, 0);
            }
            return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
          }
          var invokeMap = baseRest(function(collection, path2, args) {
            var index2 = -1, isFunc = typeof path2 == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
            baseEach(collection, function(value) {
              result2[++index2] = isFunc ? apply(path2, value, args) : baseInvoke(value, path2, args);
            });
            return result2;
          });
          var keyBy = createAggregator(function(result2, value, key) {
            baseAssignValue(result2, key, value);
          });
          function map4(collection, iteratee2) {
            var func = isArray(collection) ? arrayMap : baseMap;
            return func(collection, getIteratee(iteratee2, 3));
          }
          function orderBy(collection, iteratees, orders, guard) {
            if (collection == null) {
              return [];
            }
            if (!isArray(iteratees)) {
              iteratees = iteratees == null ? [] : [iteratees];
            }
            orders = guard ? undefined2 : orders;
            if (!isArray(orders)) {
              orders = orders == null ? [] : [orders];
            }
            return baseOrderBy(collection, iteratees, orders);
          }
          var partition = createAggregator(function(result2, value, key) {
            result2[key ? 0 : 1].push(value);
          }, function() {
            return [[], []];
          });
          function reduce(collection, iteratee2, accumulator) {
            var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
            return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
          }
          function reduceRight(collection, iteratee2, accumulator) {
            var func = isArray(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
            return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
          }
          function reject(collection, predicate) {
            var func = isArray(collection) ? arrayFilter : baseFilter;
            return func(collection, negate(getIteratee(predicate, 3)));
          }
          function sample(collection) {
            var func = isArray(collection) ? arraySample : baseSample;
            return func(collection);
          }
          function sampleSize(collection, n, guard) {
            if (guard ? isIterateeCall(collection, n, guard) : n === undefined2) {
              n = 1;
            } else {
              n = toInteger(n);
            }
            var func = isArray(collection) ? arraySampleSize : baseSampleSize;
            return func(collection, n);
          }
          function shuffle(collection) {
            var func = isArray(collection) ? arrayShuffle : baseShuffle;
            return func(collection);
          }
          function size(collection) {
            if (collection == null) {
              return 0;
            }
            if (isArrayLike(collection)) {
              return isString(collection) ? stringSize(collection) : collection.length;
            }
            var tag = getTag(collection);
            if (tag == mapTag || tag == setTag) {
              return collection.size;
            }
            return baseKeys(collection).length;
          }
          function some(collection, predicate, guard) {
            var func = isArray(collection) ? arraySome : baseSome;
            if (guard && isIterateeCall(collection, predicate, guard)) {
              predicate = undefined2;
            }
            return func(collection, getIteratee(predicate, 3));
          }
          var sortBy = baseRest(function(collection, iteratees) {
            if (collection == null) {
              return [];
            }
            var length = iteratees.length;
            if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
              iteratees = [];
            } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
              iteratees = [iteratees[0]];
            }
            return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
          });
          var now2 = ctxNow || function() {
            return root2.Date.now();
          };
          function after(n, func) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            n = toInteger(n);
            return function() {
              if (--n < 1) {
                return func.apply(this, arguments);
              }
            };
          }
          function ary(func, n, guard) {
            n = guard ? undefined2 : n;
            n = func && n == null ? func.length : n;
            return createWrap(func, WRAP_ARY_FLAG, undefined2, undefined2, undefined2, undefined2, n);
          }
          function before(n, func) {
            var result2;
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            n = toInteger(n);
            return function() {
              if (--n > 0) {
                result2 = func.apply(this, arguments);
              }
              if (n <= 1) {
                func = undefined2;
              }
              return result2;
            };
          }
          var bind = baseRest(function(func, thisArg, partials) {
            var bitmask = WRAP_BIND_FLAG;
            if (partials.length) {
              var holders = replaceHolders(partials, getHolder(bind));
              bitmask |= WRAP_PARTIAL_FLAG;
            }
            return createWrap(func, bitmask, thisArg, partials, holders);
          });
          var bindKey2 = baseRest(function(object, key, partials) {
            var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
            if (partials.length) {
              var holders = replaceHolders(partials, getHolder(bindKey2));
              bitmask |= WRAP_PARTIAL_FLAG;
            }
            return createWrap(key, bitmask, object, partials, holders);
          });
          function curry(func, arity, guard) {
            arity = guard ? undefined2 : arity;
            var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
            result2.placeholder = curry.placeholder;
            return result2;
          }
          function curryRight(func, arity, guard) {
            arity = guard ? undefined2 : arity;
            var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
            result2.placeholder = curryRight.placeholder;
            return result2;
          }
          function debounce(func, wait, options) {
            var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            wait = toNumber(wait) || 0;
            if (isObject(options)) {
              leading = !!options.leading;
              maxing = "maxWait" in options;
              maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
              trailing = "trailing" in options ? !!options.trailing : trailing;
            }
            function invokeFunc(time) {
              var args = lastArgs, thisArg = lastThis;
              lastArgs = lastThis = undefined2;
              lastInvokeTime = time;
              result2 = func.apply(thisArg, args);
              return result2;
            }
            function leadingEdge(time) {
              lastInvokeTime = time;
              timerId = setTimeout2(timerExpired, wait);
              return leading ? invokeFunc(time) : result2;
            }
            function remainingWait(time) {
              var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
              return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
            }
            function shouldInvoke(time) {
              var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
              return lastCallTime === undefined2 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
            }
            function timerExpired() {
              var time = now2();
              if (shouldInvoke(time)) {
                return trailingEdge(time);
              }
              timerId = setTimeout2(timerExpired, remainingWait(time));
            }
            function trailingEdge(time) {
              timerId = undefined2;
              if (trailing && lastArgs) {
                return invokeFunc(time);
              }
              lastArgs = lastThis = undefined2;
              return result2;
            }
            function cancel() {
              if (timerId !== undefined2) {
                clearTimeout2(timerId);
              }
              lastInvokeTime = 0;
              lastArgs = lastCallTime = lastThis = timerId = undefined2;
            }
            function flush() {
              return timerId === undefined2 ? result2 : trailingEdge(now2());
            }
            function debounced() {
              var time = now2(), isInvoking = shouldInvoke(time);
              lastArgs = arguments;
              lastThis = this;
              lastCallTime = time;
              if (isInvoking) {
                if (timerId === undefined2) {
                  return leadingEdge(lastCallTime);
                }
                if (maxing) {
                  clearTimeout2(timerId);
                  timerId = setTimeout2(timerExpired, wait);
                  return invokeFunc(lastCallTime);
                }
              }
              if (timerId === undefined2) {
                timerId = setTimeout2(timerExpired, wait);
              }
              return result2;
            }
            debounced.cancel = cancel;
            debounced.flush = flush;
            return debounced;
          }
          var defer = baseRest(function(func, args) {
            return baseDelay(func, 1, args);
          });
          var delay = baseRest(function(func, wait, args) {
            return baseDelay(func, toNumber(wait) || 0, args);
          });
          function flip(func) {
            return createWrap(func, WRAP_FLIP_FLAG);
          }
          function memoize(func, resolver) {
            if (typeof func != "function" || resolver != null && typeof resolver != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            var memoized = function() {
              var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
              if (cache.has(key)) {
                return cache.get(key);
              }
              var result2 = func.apply(this, args);
              memoized.cache = cache.set(key, result2) || cache;
              return result2;
            };
            memoized.cache = new (memoize.Cache || MapCache)();
            return memoized;
          }
          memoize.Cache = MapCache;
          function negate(predicate) {
            if (typeof predicate != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return function() {
              var args = arguments;
              switch (args.length) {
                case 0:
                  return !predicate.call(this);
                case 1:
                  return !predicate.call(this, args[0]);
                case 2:
                  return !predicate.call(this, args[0], args[1]);
                case 3:
                  return !predicate.call(this, args[0], args[1], args[2]);
              }
              return !predicate.apply(this, args);
            };
          }
          function once(func) {
            return before(2, func);
          }
          var overArgs = castRest(function(func, transforms) {
            transforms = transforms.length == 1 && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
            var funcsLength = transforms.length;
            return baseRest(function(args) {
              var index2 = -1, length = nativeMin(args.length, funcsLength);
              while (++index2 < length) {
                args[index2] = transforms[index2].call(this, args[index2]);
              }
              return apply(func, this, args);
            });
          });
          var partial = baseRest(function(func, partials) {
            var holders = replaceHolders(partials, getHolder(partial));
            return createWrap(func, WRAP_PARTIAL_FLAG, undefined2, partials, holders);
          });
          var partialRight = baseRest(function(func, partials) {
            var holders = replaceHolders(partials, getHolder(partialRight));
            return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined2, partials, holders);
          });
          var rearg = flatRest(function(func, indexes) {
            return createWrap(func, WRAP_REARG_FLAG, undefined2, undefined2, undefined2, indexes);
          });
          function rest(func, start2) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            start2 = start2 === undefined2 ? start2 : toInteger(start2);
            return baseRest(func, start2);
          }
          function spread(func, start2) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            start2 = start2 == null ? 0 : nativeMax(toInteger(start2), 0);
            return baseRest(function(args) {
              var array2 = args[start2], otherArgs = castSlice(args, 0, start2);
              if (array2) {
                arrayPush(otherArgs, array2);
              }
              return apply(func, this, otherArgs);
            });
          }
          function throttle(func, wait, options) {
            var leading = true, trailing = true;
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            if (isObject(options)) {
              leading = "leading" in options ? !!options.leading : leading;
              trailing = "trailing" in options ? !!options.trailing : trailing;
            }
            return debounce(func, wait, {
              "leading": leading,
              "maxWait": wait,
              "trailing": trailing
            });
          }
          function unary(func) {
            return ary(func, 1);
          }
          function wrap(value, wrapper) {
            return partial(castFunction(wrapper), value);
          }
          function castArray() {
            if (!arguments.length) {
              return [];
            }
            var value = arguments[0];
            return isArray(value) ? value : [value];
          }
          function clone(value) {
            return baseClone(value, CLONE_SYMBOLS_FLAG);
          }
          function cloneWith(value, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
          }
          function cloneDeep(value) {
            return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
          }
          function cloneDeepWith(value, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
          }
          function conformsTo(object, source) {
            return source == null || baseConformsTo(object, source, keys(source));
          }
          function eq(value, other) {
            return value === other || value !== value && other !== other;
          }
          var gt = createRelationalOperation(baseGt);
          var gte = createRelationalOperation(function(value, other) {
            return value >= other;
          });
          var isArguments = baseIsArguments(function() {
            return arguments;
          }()) ? baseIsArguments : function(value) {
            return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
          };
          var isArray = Array2.isArray;
          var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
          function isArrayLike(value) {
            return value != null && isLength(value.length) && !isFunction(value);
          }
          function isArrayLikeObject(value) {
            return isObjectLike(value) && isArrayLike(value);
          }
          function isBoolean(value) {
            return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
          }
          var isBuffer = nativeIsBuffer || stubFalse;
          var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
          function isElement(value) {
            return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
          }
          function isEmpty(value) {
            if (value == null) {
              return true;
            }
            if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
              return !value.length;
            }
            var tag = getTag(value);
            if (tag == mapTag || tag == setTag) {
              return !value.size;
            }
            if (isPrototype(value)) {
              return !baseKeys(value).length;
            }
            for (var key in value) {
              if (hasOwnProperty.call(value, key)) {
                return false;
              }
            }
            return true;
          }
          function isEqual(value, other) {
            return baseIsEqual(value, other);
          }
          function isEqualWith(value, other, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            var result2 = customizer ? customizer(value, other) : undefined2;
            return result2 === undefined2 ? baseIsEqual(value, other, undefined2, customizer) : !!result2;
          }
          function isError(value) {
            if (!isObjectLike(value)) {
              return false;
            }
            var tag = baseGetTag(value);
            return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject(value);
          }
          function isFinite2(value) {
            return typeof value == "number" && nativeIsFinite(value);
          }
          function isFunction(value) {
            if (!isObject(value)) {
              return false;
            }
            var tag = baseGetTag(value);
            return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
          }
          function isInteger(value) {
            return typeof value == "number" && value == toInteger(value);
          }
          function isLength(value) {
            return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
          }
          function isObject(value) {
            var type2 = typeof value;
            return value != null && (type2 == "object" || type2 == "function");
          }
          function isObjectLike(value) {
            return value != null && typeof value == "object";
          }
          var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
          function isMatch(object, source) {
            return object === source || baseIsMatch(object, source, getMatchData(source));
          }
          function isMatchWith(object, source, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return baseIsMatch(object, source, getMatchData(source), customizer);
          }
          function isNaN2(value) {
            return isNumber(value) && value != +value;
          }
          function isNative(value) {
            if (isMaskable(value)) {
              throw new Error2(CORE_ERROR_TEXT);
            }
            return baseIsNative(value);
          }
          function isNull(value) {
            return value === null;
          }
          function isNil(value) {
            return value == null;
          }
          function isNumber(value) {
            return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
          }
          function isPlainObject(value) {
            if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
              return false;
            }
            var proto = getPrototype(value);
            if (proto === null) {
              return true;
            }
            var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
            return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
          }
          var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
          function isSafeInteger(value) {
            return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
          }
          var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
          function isString(value) {
            return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
          }
          function isSymbol(value) {
            return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
          }
          var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
          function isUndefined(value) {
            return value === undefined2;
          }
          function isWeakMap(value) {
            return isObjectLike(value) && getTag(value) == weakMapTag;
          }
          function isWeakSet(value) {
            return isObjectLike(value) && baseGetTag(value) == weakSetTag;
          }
          var lt = createRelationalOperation(baseLt);
          var lte = createRelationalOperation(function(value, other) {
            return value <= other;
          });
          function toArray(value) {
            if (!value) {
              return [];
            }
            if (isArrayLike(value)) {
              return isString(value) ? stringToArray(value) : copyArray(value);
            }
            if (symIterator && value[symIterator]) {
              return iteratorToArray(value[symIterator]());
            }
            var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
            return func(value);
          }
          function toFinite(value) {
            if (!value) {
              return value === 0 ? value : 0;
            }
            value = toNumber(value);
            if (value === INFINITY || value === -INFINITY) {
              var sign2 = value < 0 ? -1 : 1;
              return sign2 * MAX_INTEGER;
            }
            return value === value ? value : 0;
          }
          function toInteger(value) {
            var result2 = toFinite(value), remainder = result2 % 1;
            return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
          }
          function toLength(value) {
            return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
          }
          function toNumber(value) {
            if (typeof value == "number") {
              return value;
            }
            if (isSymbol(value)) {
              return NAN;
            }
            if (isObject(value)) {
              var other = typeof value.valueOf == "function" ? value.valueOf() : value;
              value = isObject(other) ? other + "" : other;
            }
            if (typeof value != "string") {
              return value === 0 ? value : +value;
            }
            value = baseTrim(value);
            var isBinary = reIsBinary.test(value);
            return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
          }
          function toPlainObject(value) {
            return copyObject(value, keysIn(value));
          }
          function toSafeInteger(value) {
            return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
          }
          function toString(value) {
            return value == null ? "" : baseToString(value);
          }
          var assign = createAssigner(function(object, source) {
            if (isPrototype(source) || isArrayLike(source)) {
              copyObject(source, keys(source), object);
              return;
            }
            for (var key in source) {
              if (hasOwnProperty.call(source, key)) {
                assignValue(object, key, source[key]);
              }
            }
          });
          var assignIn = createAssigner(function(object, source) {
            copyObject(source, keysIn(source), object);
          });
          var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
            copyObject(source, keysIn(source), object, customizer);
          });
          var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
            copyObject(source, keys(source), object, customizer);
          });
          var at = flatRest(baseAt);
          function create2(prototype, properties) {
            var result2 = baseCreate(prototype);
            return properties == null ? result2 : baseAssign(result2, properties);
          }
          var defaults = baseRest(function(object, sources) {
            object = Object2(object);
            var index2 = -1;
            var length = sources.length;
            var guard = length > 2 ? sources[2] : undefined2;
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              length = 1;
            }
            while (++index2 < length) {
              var source = sources[index2];
              var props = keysIn(source);
              var propsIndex = -1;
              var propsLength = props.length;
              while (++propsIndex < propsLength) {
                var key = props[propsIndex];
                var value = object[key];
                if (value === undefined2 || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)) {
                  object[key] = source[key];
                }
              }
            }
            return object;
          });
          var defaultsDeep = baseRest(function(args) {
            args.push(undefined2, customDefaultsMerge);
            return apply(mergeWith, undefined2, args);
          });
          function findKey(object, predicate) {
            return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
          }
          function findLastKey(object, predicate) {
            return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
          }
          function forIn(object, iteratee2) {
            return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
          }
          function forInRight(object, iteratee2) {
            return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
          }
          function forOwn(object, iteratee2) {
            return object && baseForOwn(object, getIteratee(iteratee2, 3));
          }
          function forOwnRight(object, iteratee2) {
            return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
          }
          function functions(object) {
            return object == null ? [] : baseFunctions(object, keys(object));
          }
          function functionsIn(object) {
            return object == null ? [] : baseFunctions(object, keysIn(object));
          }
          function get3(object, path2, defaultValue2) {
            var result2 = object == null ? undefined2 : baseGet(object, path2);
            return result2 === undefined2 ? defaultValue2 : result2;
          }
          function has(object, path2) {
            return object != null && hasPath(object, path2, baseHas);
          }
          function hasIn(object, path2) {
            return object != null && hasPath(object, path2, baseHasIn);
          }
          var invert = createInverter(function(result2, value, key) {
            if (value != null && typeof value.toString != "function") {
              value = nativeObjectToString.call(value);
            }
            result2[value] = key;
          }, constant(identity3));
          var invertBy = createInverter(function(result2, value, key) {
            if (value != null && typeof value.toString != "function") {
              value = nativeObjectToString.call(value);
            }
            if (hasOwnProperty.call(result2, value)) {
              result2[value].push(key);
            } else {
              result2[value] = [key];
            }
          }, getIteratee);
          var invoke = baseRest(baseInvoke);
          function keys(object) {
            return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
          }
          function keysIn(object) {
            return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
          }
          function mapKeys(object, iteratee2) {
            var result2 = {};
            iteratee2 = getIteratee(iteratee2, 3);
            baseForOwn(object, function(value, key, object2) {
              baseAssignValue(result2, iteratee2(value, key, object2), value);
            });
            return result2;
          }
          function mapValues(object, iteratee2) {
            var result2 = {};
            iteratee2 = getIteratee(iteratee2, 3);
            baseForOwn(object, function(value, key, object2) {
              baseAssignValue(result2, key, iteratee2(value, key, object2));
            });
            return result2;
          }
          var merge = createAssigner(function(object, source, srcIndex) {
            baseMerge(object, source, srcIndex);
          });
          var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
            baseMerge(object, source, srcIndex, customizer);
          });
          var omit = flatRest(function(object, paths) {
            var result2 = {};
            if (object == null) {
              return result2;
            }
            var isDeep = false;
            paths = arrayMap(paths, function(path2) {
              path2 = castPath(path2, object);
              isDeep || (isDeep = path2.length > 1);
              return path2;
            });
            copyObject(object, getAllKeysIn(object), result2);
            if (isDeep) {
              result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
            }
            var length = paths.length;
            while (length--) {
              baseUnset(result2, paths[length]);
            }
            return result2;
          });
          function omitBy(object, predicate) {
            return pickBy(object, negate(getIteratee(predicate)));
          }
          var pick = flatRest(function(object, paths) {
            return object == null ? {} : basePick(object, paths);
          });
          function pickBy(object, predicate) {
            if (object == null) {
              return {};
            }
            var props = arrayMap(getAllKeysIn(object), function(prop) {
              return [prop];
            });
            predicate = getIteratee(predicate);
            return basePickBy(object, props, function(value, path2) {
              return predicate(value, path2[0]);
            });
          }
          function result(object, path2, defaultValue2) {
            path2 = castPath(path2, object);
            var index2 = -1, length = path2.length;
            if (!length) {
              length = 1;
              object = undefined2;
            }
            while (++index2 < length) {
              var value = object == null ? undefined2 : object[toKey(path2[index2])];
              if (value === undefined2) {
                index2 = length;
                value = defaultValue2;
              }
              object = isFunction(value) ? value.call(object) : value;
            }
            return object;
          }
          function set3(object, path2, value) {
            return object == null ? object : baseSet(object, path2, value);
          }
          function setWith(object, path2, value, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return object == null ? object : baseSet(object, path2, value, customizer);
          }
          var toPairs = createToPairs(keys);
          var toPairsIn = createToPairs(keysIn);
          function transform2(object, iteratee2, accumulator) {
            var isArr = isArray(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
            iteratee2 = getIteratee(iteratee2, 4);
            if (accumulator == null) {
              var Ctor = object && object.constructor;
              if (isArrLike) {
                accumulator = isArr ? new Ctor() : [];
              } else if (isObject(object)) {
                accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
              } else {
                accumulator = {};
              }
            }
            (isArrLike ? arrayEach : baseForOwn)(object, function(value, index2, object2) {
              return iteratee2(accumulator, value, index2, object2);
            });
            return accumulator;
          }
          function unset(object, path2) {
            return object == null ? true : baseUnset(object, path2);
          }
          function update(object, path2, updater) {
            return object == null ? object : baseUpdate(object, path2, castFunction(updater));
          }
          function updateWith(object, path2, updater, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return object == null ? object : baseUpdate(object, path2, castFunction(updater), customizer);
          }
          function values(object) {
            return object == null ? [] : baseValues(object, keys(object));
          }
          function valuesIn(object) {
            return object == null ? [] : baseValues(object, keysIn(object));
          }
          function clamp(number, lower2, upper) {
            if (upper === undefined2) {
              upper = lower2;
              lower2 = undefined2;
            }
            if (upper !== undefined2) {
              upper = toNumber(upper);
              upper = upper === upper ? upper : 0;
            }
            if (lower2 !== undefined2) {
              lower2 = toNumber(lower2);
              lower2 = lower2 === lower2 ? lower2 : 0;
            }
            return baseClamp(toNumber(number), lower2, upper);
          }
          function inRange(number, start2, end) {
            start2 = toFinite(start2);
            if (end === undefined2) {
              end = start2;
              start2 = 0;
            } else {
              end = toFinite(end);
            }
            number = toNumber(number);
            return baseInRange(number, start2, end);
          }
          function random(lower2, upper, floating) {
            if (floating && typeof floating != "boolean" && isIterateeCall(lower2, upper, floating)) {
              upper = floating = undefined2;
            }
            if (floating === undefined2) {
              if (typeof upper == "boolean") {
                floating = upper;
                upper = undefined2;
              } else if (typeof lower2 == "boolean") {
                floating = lower2;
                lower2 = undefined2;
              }
            }
            if (lower2 === undefined2 && upper === undefined2) {
              lower2 = 0;
              upper = 1;
            } else {
              lower2 = toFinite(lower2);
              if (upper === undefined2) {
                upper = lower2;
                lower2 = 0;
              } else {
                upper = toFinite(upper);
              }
            }
            if (lower2 > upper) {
              var temp2 = lower2;
              lower2 = upper;
              upper = temp2;
            }
            if (floating || lower2 % 1 || upper % 1) {
              var rand = nativeRandom();
              return nativeMin(lower2 + rand * (upper - lower2 + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
            }
            return baseRandom(lower2, upper);
          }
          var camelCase = createCompounder(function(result2, word, index2) {
            word = word.toLowerCase();
            return result2 + (index2 ? capitalize(word) : word);
          });
          function capitalize(string) {
            return upperFirst(toString(string).toLowerCase());
          }
          function deburr(string) {
            string = toString(string);
            return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
          }
          function endsWith(string, target, position) {
            string = toString(string);
            target = baseToString(target);
            var length = string.length;
            position = position === undefined2 ? length : baseClamp(toInteger(position), 0, length);
            var end = position;
            position -= target.length;
            return position >= 0 && string.slice(position, end) == target;
          }
          function escape2(string) {
            string = toString(string);
            return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
          }
          function escapeRegExp2(string) {
            string = toString(string);
            return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
          }
          var kebabCase = createCompounder(function(result2, word, index2) {
            return result2 + (index2 ? "-" : "") + word.toLowerCase();
          });
          var lowerCase = createCompounder(function(result2, word, index2) {
            return result2 + (index2 ? " " : "") + word.toLowerCase();
          });
          var lowerFirst = createCaseFirst("toLowerCase");
          function pad(string, length, chars) {
            string = toString(string);
            length = toInteger(length);
            var strLength = length ? stringSize(string) : 0;
            if (!length || strLength >= length) {
              return string;
            }
            var mid = (length - strLength) / 2;
            return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
          }
          function padEnd(string, length, chars) {
            string = toString(string);
            length = toInteger(length);
            var strLength = length ? stringSize(string) : 0;
            return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
          }
          function padStart(string, length, chars) {
            string = toString(string);
            length = toInteger(length);
            var strLength = length ? stringSize(string) : 0;
            return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
          }
          function parseInt2(string, radix, guard) {
            if (guard || radix == null) {
              radix = 0;
            } else if (radix) {
              radix = +radix;
            }
            return nativeParseInt(toString(string).replace(reTrimStart, ""), radix || 0);
          }
          function repeat(string, n, guard) {
            if (guard ? isIterateeCall(string, n, guard) : n === undefined2) {
              n = 1;
            } else {
              n = toInteger(n);
            }
            return baseRepeat(toString(string), n);
          }
          function replace() {
            var args = arguments, string = toString(args[0]);
            return args.length < 3 ? string : string.replace(args[1], args[2]);
          }
          var snakeCase = createCompounder(function(result2, word, index2) {
            return result2 + (index2 ? "_" : "") + word.toLowerCase();
          });
          function split(string, separator, limit) {
            if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
              separator = limit = undefined2;
            }
            limit = limit === undefined2 ? MAX_ARRAY_LENGTH : limit >>> 0;
            if (!limit) {
              return [];
            }
            string = toString(string);
            if (string && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
              separator = baseToString(separator);
              if (!separator && hasUnicode(string)) {
                return castSlice(stringToArray(string), 0, limit);
              }
            }
            return string.split(separator, limit);
          }
          var startCase = createCompounder(function(result2, word, index2) {
            return result2 + (index2 ? " " : "") + upperFirst(word);
          });
          function startsWith(string, target, position) {
            string = toString(string);
            position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
            target = baseToString(target);
            return string.slice(position, position + target.length) == target;
          }
          function template(string, options, guard) {
            var settings2 = lodash.templateSettings;
            if (guard && isIterateeCall(string, options, guard)) {
              options = undefined2;
            }
            string = toString(string);
            options = assignInWith({}, options, settings2, customDefaultsAssignIn);
            var imports = assignInWith({}, options.imports, settings2.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
            var isEscaping, isEvaluating, index2 = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
            var reDelimiters = RegExp2(
              (options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
              "g"
            );
            var sourceURL = "//# sourceURL=" + (hasOwnProperty.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
            string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
              interpolateValue || (interpolateValue = esTemplateValue);
              source += string.slice(index2, offset).replace(reUnescapedString, escapeStringChar);
              if (escapeValue) {
                isEscaping = true;
                source += "' +\n__e(" + escapeValue + ") +\n'";
              }
              if (evaluateValue) {
                isEvaluating = true;
                source += "';\n" + evaluateValue + ";\n__p += '";
              }
              if (interpolateValue) {
                source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
              }
              index2 = offset + match.length;
              return match;
            });
            source += "';\n";
            var variable = hasOwnProperty.call(options, "variable") && options.variable;
            if (!variable) {
              source = "with (obj) {\n" + source + "\n}\n";
            } else if (reForbiddenIdentifierChars.test(variable)) {
              throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
            }
            source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
            source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
            var result2 = attempt(function() {
              return Function2(importsKeys, sourceURL + "return " + source).apply(undefined2, importsValues);
            });
            result2.source = source;
            if (isError(result2)) {
              throw result2;
            }
            return result2;
          }
          function toLower(value) {
            return toString(value).toLowerCase();
          }
          function toUpper(value) {
            return toString(value).toUpperCase();
          }
          function trim(string, chars, guard) {
            string = toString(string);
            if (string && (guard || chars === undefined2)) {
              return baseTrim(string);
            }
            if (!string || !(chars = baseToString(chars))) {
              return string;
            }
            var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start2 = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
            return castSlice(strSymbols, start2, end).join("");
          }
          function trimEnd(string, chars, guard) {
            string = toString(string);
            if (string && (guard || chars === undefined2)) {
              return string.slice(0, trimmedEndIndex(string) + 1);
            }
            if (!string || !(chars = baseToString(chars))) {
              return string;
            }
            var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
            return castSlice(strSymbols, 0, end).join("");
          }
          function trimStart(string, chars, guard) {
            string = toString(string);
            if (string && (guard || chars === undefined2)) {
              return string.replace(reTrimStart, "");
            }
            if (!string || !(chars = baseToString(chars))) {
              return string;
            }
            var strSymbols = stringToArray(string), start2 = charsStartIndex(strSymbols, stringToArray(chars));
            return castSlice(strSymbols, start2).join("");
          }
          function truncate(string, options) {
            var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
            if (isObject(options)) {
              var separator = "separator" in options ? options.separator : separator;
              length = "length" in options ? toInteger(options.length) : length;
              omission = "omission" in options ? baseToString(options.omission) : omission;
            }
            string = toString(string);
            var strLength = string.length;
            if (hasUnicode(string)) {
              var strSymbols = stringToArray(string);
              strLength = strSymbols.length;
            }
            if (length >= strLength) {
              return string;
            }
            var end = length - stringSize(omission);
            if (end < 1) {
              return omission;
            }
            var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
            if (separator === undefined2) {
              return result2 + omission;
            }
            if (strSymbols) {
              end += result2.length - end;
            }
            if (isRegExp(separator)) {
              if (string.slice(end).search(separator)) {
                var match, substring = result2;
                if (!separator.global) {
                  separator = RegExp2(separator.source, toString(reFlags.exec(separator)) + "g");
                }
                separator.lastIndex = 0;
                while (match = separator.exec(substring)) {
                  var newEnd = match.index;
                }
                result2 = result2.slice(0, newEnd === undefined2 ? end : newEnd);
              }
            } else if (string.indexOf(baseToString(separator), end) != end) {
              var index2 = result2.lastIndexOf(separator);
              if (index2 > -1) {
                result2 = result2.slice(0, index2);
              }
            }
            return result2 + omission;
          }
          function unescape2(string) {
            string = toString(string);
            return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
          }
          var upperCase = createCompounder(function(result2, word, index2) {
            return result2 + (index2 ? " " : "") + word.toUpperCase();
          });
          var upperFirst = createCaseFirst("toUpperCase");
          function words(string, pattern, guard) {
            string = toString(string);
            pattern = guard ? undefined2 : pattern;
            if (pattern === undefined2) {
              return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
            }
            return string.match(pattern) || [];
          }
          var attempt = baseRest(function(func, args) {
            try {
              return apply(func, undefined2, args);
            } catch (e) {
              return isError(e) ? e : new Error2(e);
            }
          });
          var bindAll = flatRest(function(object, methodNames) {
            arrayEach(methodNames, function(key) {
              key = toKey(key);
              baseAssignValue(object, key, bind(object[key], object));
            });
            return object;
          });
          function cond(pairs) {
            var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
            pairs = !length ? [] : arrayMap(pairs, function(pair) {
              if (typeof pair[1] != "function") {
                throw new TypeError2(FUNC_ERROR_TEXT);
              }
              return [toIteratee(pair[0]), pair[1]];
            });
            return baseRest(function(args) {
              var index2 = -1;
              while (++index2 < length) {
                var pair = pairs[index2];
                if (apply(pair[0], this, args)) {
                  return apply(pair[1], this, args);
                }
              }
            });
          }
          function conforms(source) {
            return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
          }
          function constant(value) {
            return function() {
              return value;
            };
          }
          function defaultTo(value, defaultValue2) {
            return value == null || value !== value ? defaultValue2 : value;
          }
          var flow = createFlow();
          var flowRight = createFlow(true);
          function identity3(value) {
            return value;
          }
          function iteratee(func) {
            return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
          }
          function matches(source) {
            return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
          }
          function matchesProperty(path2, srcValue) {
            return baseMatchesProperty(path2, baseClone(srcValue, CLONE_DEEP_FLAG));
          }
          var method = baseRest(function(path2, args) {
            return function(object) {
              return baseInvoke(object, path2, args);
            };
          });
          var methodOf = baseRest(function(object, args) {
            return function(path2) {
              return baseInvoke(object, path2, args);
            };
          });
          function mixin(object, source, options) {
            var props = keys(source), methodNames = baseFunctions(source, props);
            if (options == null && !(isObject(source) && (methodNames.length || !props.length))) {
              options = source;
              source = object;
              object = this;
              methodNames = baseFunctions(source, keys(source));
            }
            var chain2 = !(isObject(options) && "chain" in options) || !!options.chain, isFunc = isFunction(object);
            arrayEach(methodNames, function(methodName) {
              var func = source[methodName];
              object[methodName] = func;
              if (isFunc) {
                object.prototype[methodName] = function() {
                  var chainAll = this.__chain__;
                  if (chain2 || chainAll) {
                    var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                    actions.push({ "func": func, "args": arguments, "thisArg": object });
                    result2.__chain__ = chainAll;
                    return result2;
                  }
                  return func.apply(object, arrayPush([this.value()], arguments));
                };
              }
            });
            return object;
          }
          function noConflict() {
            if (root2._ === this) {
              root2._ = oldDash;
            }
            return this;
          }
          function noop2() {
          }
          function nthArg(n) {
            n = toInteger(n);
            return baseRest(function(args) {
              return baseNth(args, n);
            });
          }
          var over = createOver(arrayMap);
          var overEvery = createOver(arrayEvery);
          var overSome = createOver(arraySome);
          function property(path2) {
            return isKey(path2) ? baseProperty(toKey(path2)) : basePropertyDeep(path2);
          }
          function propertyOf(object) {
            return function(path2) {
              return object == null ? undefined2 : baseGet(object, path2);
            };
          }
          var range = createRange();
          var rangeRight = createRange(true);
          function stubArray() {
            return [];
          }
          function stubFalse() {
            return false;
          }
          function stubObject() {
            return {};
          }
          function stubString() {
            return "";
          }
          function stubTrue() {
            return true;
          }
          function times(n, iteratee2) {
            n = toInteger(n);
            if (n < 1 || n > MAX_SAFE_INTEGER) {
              return [];
            }
            var index2 = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
            iteratee2 = getIteratee(iteratee2);
            n -= MAX_ARRAY_LENGTH;
            var result2 = baseTimes(length, iteratee2);
            while (++index2 < n) {
              iteratee2(index2);
            }
            return result2;
          }
          function toPath(value) {
            if (isArray(value)) {
              return arrayMap(value, toKey);
            }
            return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
          }
          function uniqueId(prefix) {
            var id2 = ++idCounter;
            return toString(prefix) + id2;
          }
          var add2 = createMathOperation(function(augend, addend) {
            return augend + addend;
          }, 0);
          var ceil = createRound("ceil");
          var divide = createMathOperation(function(dividend, divisor) {
            return dividend / divisor;
          }, 1);
          var floor = createRound("floor");
          function max2(array2) {
            return array2 && array2.length ? baseExtremum(array2, identity3, baseGt) : undefined2;
          }
          function maxBy(array2, iteratee2) {
            return array2 && array2.length ? baseExtremum(array2, getIteratee(iteratee2, 2), baseGt) : undefined2;
          }
          function mean(array2) {
            return baseMean(array2, identity3);
          }
          function meanBy(array2, iteratee2) {
            return baseMean(array2, getIteratee(iteratee2, 2));
          }
          function min2(array2) {
            return array2 && array2.length ? baseExtremum(array2, identity3, baseLt) : undefined2;
          }
          function minBy(array2, iteratee2) {
            return array2 && array2.length ? baseExtremum(array2, getIteratee(iteratee2, 2), baseLt) : undefined2;
          }
          var multiply = createMathOperation(function(multiplier, multiplicand) {
            return multiplier * multiplicand;
          }, 1);
          var round2 = createRound("round");
          var subtract = createMathOperation(function(minuend, subtrahend) {
            return minuend - subtrahend;
          }, 0);
          function sum(array2) {
            return array2 && array2.length ? baseSum(array2, identity3) : 0;
          }
          function sumBy(array2, iteratee2) {
            return array2 && array2.length ? baseSum(array2, getIteratee(iteratee2, 2)) : 0;
          }
          lodash.after = after;
          lodash.ary = ary;
          lodash.assign = assign;
          lodash.assignIn = assignIn;
          lodash.assignInWith = assignInWith;
          lodash.assignWith = assignWith;
          lodash.at = at;
          lodash.before = before;
          lodash.bind = bind;
          lodash.bindAll = bindAll;
          lodash.bindKey = bindKey2;
          lodash.castArray = castArray;
          lodash.chain = chain;
          lodash.chunk = chunk;
          lodash.compact = compact;
          lodash.concat = concat;
          lodash.cond = cond;
          lodash.conforms = conforms;
          lodash.constant = constant;
          lodash.countBy = countBy;
          lodash.create = create2;
          lodash.curry = curry;
          lodash.curryRight = curryRight;
          lodash.debounce = debounce;
          lodash.defaults = defaults;
          lodash.defaultsDeep = defaultsDeep;
          lodash.defer = defer;
          lodash.delay = delay;
          lodash.difference = difference;
          lodash.differenceBy = differenceBy;
          lodash.differenceWith = differenceWith;
          lodash.drop = drop;
          lodash.dropRight = dropRight;
          lodash.dropRightWhile = dropRightWhile;
          lodash.dropWhile = dropWhile;
          lodash.fill = fill;
          lodash.filter = filter2;
          lodash.flatMap = flatMap;
          lodash.flatMapDeep = flatMapDeep;
          lodash.flatMapDepth = flatMapDepth;
          lodash.flatten = flatten;
          lodash.flattenDeep = flattenDeep;
          lodash.flattenDepth = flattenDepth;
          lodash.flip = flip;
          lodash.flow = flow;
          lodash.flowRight = flowRight;
          lodash.fromPairs = fromPairs;
          lodash.functions = functions;
          lodash.functionsIn = functionsIn;
          lodash.groupBy = groupBy;
          lodash.initial = initial;
          lodash.intersection = intersection;
          lodash.intersectionBy = intersectionBy;
          lodash.intersectionWith = intersectionWith;
          lodash.invert = invert;
          lodash.invertBy = invertBy;
          lodash.invokeMap = invokeMap;
          lodash.iteratee = iteratee;
          lodash.keyBy = keyBy;
          lodash.keys = keys;
          lodash.keysIn = keysIn;
          lodash.map = map4;
          lodash.mapKeys = mapKeys;
          lodash.mapValues = mapValues;
          lodash.matches = matches;
          lodash.matchesProperty = matchesProperty;
          lodash.memoize = memoize;
          lodash.merge = merge;
          lodash.mergeWith = mergeWith;
          lodash.method = method;
          lodash.methodOf = methodOf;
          lodash.mixin = mixin;
          lodash.negate = negate;
          lodash.nthArg = nthArg;
          lodash.omit = omit;
          lodash.omitBy = omitBy;
          lodash.once = once;
          lodash.orderBy = orderBy;
          lodash.over = over;
          lodash.overArgs = overArgs;
          lodash.overEvery = overEvery;
          lodash.overSome = overSome;
          lodash.partial = partial;
          lodash.partialRight = partialRight;
          lodash.partition = partition;
          lodash.pick = pick;
          lodash.pickBy = pickBy;
          lodash.property = property;
          lodash.propertyOf = propertyOf;
          lodash.pull = pull;
          lodash.pullAll = pullAll;
          lodash.pullAllBy = pullAllBy;
          lodash.pullAllWith = pullAllWith;
          lodash.pullAt = pullAt;
          lodash.range = range;
          lodash.rangeRight = rangeRight;
          lodash.rearg = rearg;
          lodash.reject = reject;
          lodash.remove = remove2;
          lodash.rest = rest;
          lodash.reverse = reverse;
          lodash.sampleSize = sampleSize;
          lodash.set = set3;
          lodash.setWith = setWith;
          lodash.shuffle = shuffle;
          lodash.slice = slice;
          lodash.sortBy = sortBy;
          lodash.sortedUniq = sortedUniq;
          lodash.sortedUniqBy = sortedUniqBy;
          lodash.split = split;
          lodash.spread = spread;
          lodash.tail = tail;
          lodash.take = take;
          lodash.takeRight = takeRight;
          lodash.takeRightWhile = takeRightWhile;
          lodash.takeWhile = takeWhile;
          lodash.tap = tap;
          lodash.throttle = throttle;
          lodash.thru = thru;
          lodash.toArray = toArray;
          lodash.toPairs = toPairs;
          lodash.toPairsIn = toPairsIn;
          lodash.toPath = toPath;
          lodash.toPlainObject = toPlainObject;
          lodash.transform = transform2;
          lodash.unary = unary;
          lodash.union = union;
          lodash.unionBy = unionBy;
          lodash.unionWith = unionWith;
          lodash.uniq = uniq2;
          lodash.uniqBy = uniqBy;
          lodash.uniqWith = uniqWith;
          lodash.unset = unset;
          lodash.unzip = unzip;
          lodash.unzipWith = unzipWith;
          lodash.update = update;
          lodash.updateWith = updateWith;
          lodash.values = values;
          lodash.valuesIn = valuesIn;
          lodash.without = without;
          lodash.words = words;
          lodash.wrap = wrap;
          lodash.xor = xor;
          lodash.xorBy = xorBy;
          lodash.xorWith = xorWith;
          lodash.zip = zip;
          lodash.zipObject = zipObject;
          lodash.zipObjectDeep = zipObjectDeep;
          lodash.zipWith = zipWith;
          lodash.entries = toPairs;
          lodash.entriesIn = toPairsIn;
          lodash.extend = assignIn;
          lodash.extendWith = assignInWith;
          mixin(lodash, lodash);
          lodash.add = add2;
          lodash.attempt = attempt;
          lodash.camelCase = camelCase;
          lodash.capitalize = capitalize;
          lodash.ceil = ceil;
          lodash.clamp = clamp;
          lodash.clone = clone;
          lodash.cloneDeep = cloneDeep;
          lodash.cloneDeepWith = cloneDeepWith;
          lodash.cloneWith = cloneWith;
          lodash.conformsTo = conformsTo;
          lodash.deburr = deburr;
          lodash.defaultTo = defaultTo;
          lodash.divide = divide;
          lodash.endsWith = endsWith;
          lodash.eq = eq;
          lodash.escape = escape2;
          lodash.escapeRegExp = escapeRegExp2;
          lodash.every = every;
          lodash.find = find3;
          lodash.findIndex = findIndex;
          lodash.findKey = findKey;
          lodash.findLast = findLast;
          lodash.findLastIndex = findLastIndex;
          lodash.findLastKey = findLastKey;
          lodash.floor = floor;
          lodash.forEach = forEach;
          lodash.forEachRight = forEachRight;
          lodash.forIn = forIn;
          lodash.forInRight = forInRight;
          lodash.forOwn = forOwn;
          lodash.forOwnRight = forOwnRight;
          lodash.get = get3;
          lodash.gt = gt;
          lodash.gte = gte;
          lodash.has = has;
          lodash.hasIn = hasIn;
          lodash.head = head;
          lodash.identity = identity3;
          lodash.includes = includes;
          lodash.indexOf = indexOf;
          lodash.inRange = inRange;
          lodash.invoke = invoke;
          lodash.isArguments = isArguments;
          lodash.isArray = isArray;
          lodash.isArrayBuffer = isArrayBuffer;
          lodash.isArrayLike = isArrayLike;
          lodash.isArrayLikeObject = isArrayLikeObject;
          lodash.isBoolean = isBoolean;
          lodash.isBuffer = isBuffer;
          lodash.isDate = isDate;
          lodash.isElement = isElement;
          lodash.isEmpty = isEmpty;
          lodash.isEqual = isEqual;
          lodash.isEqualWith = isEqualWith;
          lodash.isError = isError;
          lodash.isFinite = isFinite2;
          lodash.isFunction = isFunction;
          lodash.isInteger = isInteger;
          lodash.isLength = isLength;
          lodash.isMap = isMap;
          lodash.isMatch = isMatch;
          lodash.isMatchWith = isMatchWith;
          lodash.isNaN = isNaN2;
          lodash.isNative = isNative;
          lodash.isNil = isNil;
          lodash.isNull = isNull;
          lodash.isNumber = isNumber;
          lodash.isObject = isObject;
          lodash.isObjectLike = isObjectLike;
          lodash.isPlainObject = isPlainObject;
          lodash.isRegExp = isRegExp;
          lodash.isSafeInteger = isSafeInteger;
          lodash.isSet = isSet;
          lodash.isString = isString;
          lodash.isSymbol = isSymbol;
          lodash.isTypedArray = isTypedArray;
          lodash.isUndefined = isUndefined;
          lodash.isWeakMap = isWeakMap;
          lodash.isWeakSet = isWeakSet;
          lodash.join = join;
          lodash.kebabCase = kebabCase;
          lodash.last = last;
          lodash.lastIndexOf = lastIndexOf;
          lodash.lowerCase = lowerCase;
          lodash.lowerFirst = lowerFirst;
          lodash.lt = lt;
          lodash.lte = lte;
          lodash.max = max2;
          lodash.maxBy = maxBy;
          lodash.mean = mean;
          lodash.meanBy = meanBy;
          lodash.min = min2;
          lodash.minBy = minBy;
          lodash.stubArray = stubArray;
          lodash.stubFalse = stubFalse;
          lodash.stubObject = stubObject;
          lodash.stubString = stubString;
          lodash.stubTrue = stubTrue;
          lodash.multiply = multiply;
          lodash.nth = nth;
          lodash.noConflict = noConflict;
          lodash.noop = noop2;
          lodash.now = now2;
          lodash.pad = pad;
          lodash.padEnd = padEnd;
          lodash.padStart = padStart;
          lodash.parseInt = parseInt2;
          lodash.random = random;
          lodash.reduce = reduce;
          lodash.reduceRight = reduceRight;
          lodash.repeat = repeat;
          lodash.replace = replace;
          lodash.result = result;
          lodash.round = round2;
          lodash.runInContext = runInContext2;
          lodash.sample = sample;
          lodash.size = size;
          lodash.snakeCase = snakeCase;
          lodash.some = some;
          lodash.sortedIndex = sortedIndex;
          lodash.sortedIndexBy = sortedIndexBy;
          lodash.sortedIndexOf = sortedIndexOf;
          lodash.sortedLastIndex = sortedLastIndex;
          lodash.sortedLastIndexBy = sortedLastIndexBy;
          lodash.sortedLastIndexOf = sortedLastIndexOf;
          lodash.startCase = startCase;
          lodash.startsWith = startsWith;
          lodash.subtract = subtract;
          lodash.sum = sum;
          lodash.sumBy = sumBy;
          lodash.template = template;
          lodash.times = times;
          lodash.toFinite = toFinite;
          lodash.toInteger = toInteger;
          lodash.toLength = toLength;
          lodash.toLower = toLower;
          lodash.toNumber = toNumber;
          lodash.toSafeInteger = toSafeInteger;
          lodash.toString = toString;
          lodash.toUpper = toUpper;
          lodash.trim = trim;
          lodash.trimEnd = trimEnd;
          lodash.trimStart = trimStart;
          lodash.truncate = truncate;
          lodash.unescape = unescape2;
          lodash.uniqueId = uniqueId;
          lodash.upperCase = upperCase;
          lodash.upperFirst = upperFirst;
          lodash.each = forEach;
          lodash.eachRight = forEachRight;
          lodash.first = head;
          mixin(lodash, function() {
            var source = {};
            baseForOwn(lodash, function(func, methodName) {
              if (!hasOwnProperty.call(lodash.prototype, methodName)) {
                source[methodName] = func;
              }
            });
            return source;
          }(), { "chain": false });
          lodash.VERSION = VERSION;
          arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
            lodash[methodName].placeholder = lodash;
          });
          arrayEach(["drop", "take"], function(methodName, index2) {
            LazyWrapper.prototype[methodName] = function(n) {
              n = n === undefined2 ? 1 : nativeMax(toInteger(n), 0);
              var result2 = this.__filtered__ && !index2 ? new LazyWrapper(this) : this.clone();
              if (result2.__filtered__) {
                result2.__takeCount__ = nativeMin(n, result2.__takeCount__);
              } else {
                result2.__views__.push({
                  "size": nativeMin(n, MAX_ARRAY_LENGTH),
                  "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
                });
              }
              return result2;
            };
            LazyWrapper.prototype[methodName + "Right"] = function(n) {
              return this.reverse()[methodName](n).reverse();
            };
          });
          arrayEach(["filter", "map", "takeWhile"], function(methodName, index2) {
            var type2 = index2 + 1, isFilter = type2 == LAZY_FILTER_FLAG || type2 == LAZY_WHILE_FLAG;
            LazyWrapper.prototype[methodName] = function(iteratee2) {
              var result2 = this.clone();
              result2.__iteratees__.push({
                "iteratee": getIteratee(iteratee2, 3),
                "type": type2
              });
              result2.__filtered__ = result2.__filtered__ || isFilter;
              return result2;
            };
          });
          arrayEach(["head", "last"], function(methodName, index2) {
            var takeName = "take" + (index2 ? "Right" : "");
            LazyWrapper.prototype[methodName] = function() {
              return this[takeName](1).value()[0];
            };
          });
          arrayEach(["initial", "tail"], function(methodName, index2) {
            var dropName = "drop" + (index2 ? "" : "Right");
            LazyWrapper.prototype[methodName] = function() {
              return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
            };
          });
          LazyWrapper.prototype.compact = function() {
            return this.filter(identity3);
          };
          LazyWrapper.prototype.find = function(predicate) {
            return this.filter(predicate).head();
          };
          LazyWrapper.prototype.findLast = function(predicate) {
            return this.reverse().find(predicate);
          };
          LazyWrapper.prototype.invokeMap = baseRest(function(path2, args) {
            if (typeof path2 == "function") {
              return new LazyWrapper(this);
            }
            return this.map(function(value) {
              return baseInvoke(value, path2, args);
            });
          });
          LazyWrapper.prototype.reject = function(predicate) {
            return this.filter(negate(getIteratee(predicate)));
          };
          LazyWrapper.prototype.slice = function(start2, end) {
            start2 = toInteger(start2);
            var result2 = this;
            if (result2.__filtered__ && (start2 > 0 || end < 0)) {
              return new LazyWrapper(result2);
            }
            if (start2 < 0) {
              result2 = result2.takeRight(-start2);
            } else if (start2) {
              result2 = result2.drop(start2);
            }
            if (end !== undefined2) {
              end = toInteger(end);
              result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start2);
            }
            return result2;
          };
          LazyWrapper.prototype.takeRightWhile = function(predicate) {
            return this.reverse().takeWhile(predicate).reverse();
          };
          LazyWrapper.prototype.toArray = function() {
            return this.take(MAX_ARRAY_LENGTH);
          };
          baseForOwn(LazyWrapper.prototype, function(func, methodName) {
            var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
            if (!lodashFunc) {
              return;
            }
            lodash.prototype[methodName] = function() {
              var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray(value);
              var interceptor = function(value2) {
                var result3 = lodashFunc.apply(lodash, arrayPush([value2], args));
                return isTaker && chainAll ? result3[0] : result3;
              };
              if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
                isLazy = useLazy = false;
              }
              var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
              if (!retUnwrapped && useLazy) {
                value = onlyLazy ? value : new LazyWrapper(this);
                var result2 = func.apply(value, args);
                result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined2 });
                return new LodashWrapper(result2, chainAll);
              }
              if (isUnwrapped && onlyLazy) {
                return func.apply(this, args);
              }
              result2 = this.thru(interceptor);
              return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
            };
          });
          arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
            var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
            lodash.prototype[methodName] = function() {
              var args = arguments;
              if (retUnwrapped && !this.__chain__) {
                var value = this.value();
                return func.apply(isArray(value) ? value : [], args);
              }
              return this[chainName](function(value2) {
                return func.apply(isArray(value2) ? value2 : [], args);
              });
            };
          });
          baseForOwn(LazyWrapper.prototype, function(func, methodName) {
            var lodashFunc = lodash[methodName];
            if (lodashFunc) {
              var key = lodashFunc.name + "";
              if (!hasOwnProperty.call(realNames, key)) {
                realNames[key] = [];
              }
              realNames[key].push({ "name": methodName, "func": lodashFunc });
            }
          });
          realNames[createHybrid(undefined2, WRAP_BIND_KEY_FLAG).name] = [{
            "name": "wrapper",
            "func": undefined2
          }];
          LazyWrapper.prototype.clone = lazyClone;
          LazyWrapper.prototype.reverse = lazyReverse;
          LazyWrapper.prototype.value = lazyValue;
          lodash.prototype.at = wrapperAt;
          lodash.prototype.chain = wrapperChain;
          lodash.prototype.commit = wrapperCommit;
          lodash.prototype.next = wrapperNext;
          lodash.prototype.plant = wrapperPlant;
          lodash.prototype.reverse = wrapperReverse;
          lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
          lodash.prototype.first = lodash.prototype.head;
          if (symIterator) {
            lodash.prototype[symIterator] = wrapperToIterator;
          }
          return lodash;
        };
        var _2 = runInContext();
        if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
          root2._ = _2;
          define(function() {
            return _2;
          });
        } else if (freeModule) {
          (freeModule.exports = _2)._ = _2;
          freeExports._ = _2;
        } else {
          root2._ = _2;
        }
      }).call(exports);
    }
  });

  // src/data.ts
  async function getData() {
    const data = await fetch("data.json").then((resp) => resp.json());
    const { uniqNodes, uniqLinks } = data.map(dataset2nodes).flat(10).reduce((acc, e) => (e.type === "node" ? acc.uniqNodes[e.id] = e : acc.uniqLinks[e.source + ":" + e.target] = e, acc), { uniqNodes: {}, uniqLinks: {} });
    const nodes = Object.values(uniqNodes);
    let links = Object.values(uniqLinks);
    nodes.push({ type: "node", class: "measure", id: "fo", name: "F\u0151", mutato: true });
    nodes.push({ type: "node", class: "measure", id: "darab", name: "Darab", mutato: true });
    links = links.concat([
      { id: "fo-WB1A01", type: "link", class: "measure2dataset", measure2dataset: true, source: "fo", target: "WB1A01" },
      { id: "fo-WB1A02", type: "link", class: "measure2dataset", measure2dataset: true, source: "fo", target: "WB1A02" },
      { id: "fo-WB1A03", type: "link", class: "measure2dataset", measure2dataset: true, source: "fo", target: "WB1A03" },
      { id: "fo-WB1A04", type: "link", class: "measure2dataset", measure2dataset: true, source: "fo", target: "WB1A04" },
      { id: "fo-WB1A05", type: "link", class: "measure2dataset", measure2dataset: true, source: "fo", target: "WB1A05" },
      { id: "fo-WB1A06", type: "link", class: "measure2dataset", measure2dataset: true, source: "fo", target: "WB1A06" },
      { id: "fo-WB1A07", type: "link", class: "measure2dataset", measure2dataset: true, source: "fo", target: "WB1A07" },
      { id: "fo-WB1A08", type: "link", class: "measure2dataset", measure2dataset: true, source: "fo", target: "WB1A08" },
      { id: "fo-WB1A11", type: "link", class: "measure2dataset", measure2dataset: true, source: "fo", target: "WB1A11" },
      { id: "darab-WB1A09", type: "link", class: "measure2dataset", measure2dataset: true, source: "darab", target: "WB1A09" },
      { id: "darab-WB1A10", type: "link", class: "measure2dataset", measure2dataset: true, source: "darab", target: "WB1A10" }
    ]);
    return { nodes, links };
  }
  function dataset2nodes({ id: id2, name, dimensions }) {
    const result = [{ type: "node", class: "dataset", dataset: true, id: id2, name }];
    return result.concat(Object.values(dimensions).map(dimension2nodes(id2)));
  }
  function dimension2nodes(datasetId) {
    return function({ id: id2, name, total, codes, usedCodes }) {
      const result = [
        { type: "node", class: "dimension", dimension: true, id: id2, name },
        { id: `${datasetId}-${id2}`, type: "link", class: "dataset2dim", dataset2dim: true, source: datasetId, target: id2 }
      ];
      Object.values(codes).forEach((c2) => {
        const code = codes[c2.id];
        result.push(__spreadProps(__spreadValues({ type: "node", class: "element" }, code), { element: true, id: id2 + "-" + code.id }));
        result.push(
          code.parent ? { id: `${id2 + "-" + code.parent}-${id2 + "-" + code.id}`, type: "link", class: "dim2elem", dim2elem: true, source: id2 + "-" + code.parent, target: id2 + "-" + code.id } : { id: `${id2}-${id2 + "-" + code.id}`, type: "link", class: "elem2elem", elem2elem: true, source: id2, target: id2 + "-" + code.id }
        );
      });
      return result;
    };
  }

  // node_modules/d3-dispatch/src/dispatch.js
  var noop = { value: () => {
  } };
  function dispatch() {
    for (var i = 0, n = arguments.length, _2 = {}, t; i < n; ++i) {
      if (!(t = arguments[i] + "") || t in _2 || /[\s.]/.test(t))
        throw new Error("illegal type: " + t);
      _2[t] = [];
    }
    return new Dispatch(_2);
  }
  function Dispatch(_2) {
    this._ = _2;
  }
  function parseTypenames(typenames, types) {
    return typenames.trim().split(/^|\s+/).map(function(t) {
      var name = "", i = t.indexOf(".");
      if (i >= 0)
        name = t.slice(i + 1), t = t.slice(0, i);
      if (t && !types.hasOwnProperty(t))
        throw new Error("unknown type: " + t);
      return { type: t, name };
    });
  }
  Dispatch.prototype = dispatch.prototype = {
    constructor: Dispatch,
    on: function(typename, callback) {
      var _2 = this._, T = parseTypenames(typename + "", _2), t, i = -1, n = T.length;
      if (arguments.length < 2) {
        while (++i < n)
          if ((t = (typename = T[i]).type) && (t = get(_2[t], typename.name)))
            return t;
        return;
      }
      if (callback != null && typeof callback !== "function")
        throw new Error("invalid callback: " + callback);
      while (++i < n) {
        if (t = (typename = T[i]).type)
          _2[t] = set(_2[t], typename.name, callback);
        else if (callback == null)
          for (t in _2)
            _2[t] = set(_2[t], typename.name, null);
      }
      return this;
    },
    copy: function() {
      var copy = {}, _2 = this._;
      for (var t in _2)
        copy[t] = _2[t].slice();
      return new Dispatch(copy);
    },
    call: function(type2, that) {
      if ((n = arguments.length - 2) > 0)
        for (var args = new Array(n), i = 0, n, t; i < n; ++i)
          args[i] = arguments[i + 2];
      if (!this._.hasOwnProperty(type2))
        throw new Error("unknown type: " + type2);
      for (t = this._[type2], i = 0, n = t.length; i < n; ++i)
        t[i].value.apply(that, args);
    },
    apply: function(type2, that, args) {
      if (!this._.hasOwnProperty(type2))
        throw new Error("unknown type: " + type2);
      for (var t = this._[type2], i = 0, n = t.length; i < n; ++i)
        t[i].value.apply(that, args);
    }
  };
  function get(type2, name) {
    for (var i = 0, n = type2.length, c2; i < n; ++i) {
      if ((c2 = type2[i]).name === name) {
        return c2.value;
      }
    }
  }
  function set(type2, name, callback) {
    for (var i = 0, n = type2.length; i < n; ++i) {
      if (type2[i].name === name) {
        type2[i] = noop, type2 = type2.slice(0, i).concat(type2.slice(i + 1));
        break;
      }
    }
    if (callback != null)
      type2.push({ name, value: callback });
    return type2;
  }
  var dispatch_default = dispatch;

  // node_modules/d3-selection/src/namespaces.js
  var xhtml = "http://www.w3.org/1999/xhtml";
  var namespaces_default = {
    svg: "http://www.w3.org/2000/svg",
    xhtml,
    xlink: "http://www.w3.org/1999/xlink",
    xml: "http://www.w3.org/XML/1998/namespace",
    xmlns: "http://www.w3.org/2000/xmlns/"
  };

  // node_modules/d3-selection/src/namespace.js
  function namespace_default(name) {
    var prefix = name += "", i = prefix.indexOf(":");
    if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns")
      name = name.slice(i + 1);
    return namespaces_default.hasOwnProperty(prefix) ? { space: namespaces_default[prefix], local: name } : name;
  }

  // node_modules/d3-selection/src/creator.js
  function creatorInherit(name) {
    return function() {
      var document2 = this.ownerDocument, uri = this.namespaceURI;
      return uri === xhtml && document2.documentElement.namespaceURI === xhtml ? document2.createElement(name) : document2.createElementNS(uri, name);
    };
  }
  function creatorFixed(fullname) {
    return function() {
      return this.ownerDocument.createElementNS(fullname.space, fullname.local);
    };
  }
  function creator_default(name) {
    var fullname = namespace_default(name);
    return (fullname.local ? creatorFixed : creatorInherit)(fullname);
  }

  // node_modules/d3-selection/src/selector.js
  function none() {
  }
  function selector_default(selector) {
    return selector == null ? none : function() {
      return this.querySelector(selector);
    };
  }

  // node_modules/d3-selection/src/selection/select.js
  function select_default(select) {
    if (typeof select !== "function")
      select = selector_default(select);
    for (var groups = this._groups, m2 = groups.length, subgroups = new Array(m2), j = 0; j < m2; ++j) {
      for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
        if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
          if ("__data__" in node)
            subnode.__data__ = node.__data__;
          subgroup[i] = subnode;
        }
      }
    }
    return new Selection(subgroups, this._parents);
  }

  // node_modules/d3-selection/src/array.js
  function array(x3) {
    return x3 == null ? [] : Array.isArray(x3) ? x3 : Array.from(x3);
  }

  // node_modules/d3-selection/src/selectorAll.js
  function empty() {
    return [];
  }
  function selectorAll_default(selector) {
    return selector == null ? empty : function() {
      return this.querySelectorAll(selector);
    };
  }

  // node_modules/d3-selection/src/selection/selectAll.js
  function arrayAll(select) {
    return function() {
      return array(select.apply(this, arguments));
    };
  }
  function selectAll_default(select) {
    if (typeof select === "function")
      select = arrayAll(select);
    else
      select = selectorAll_default(select);
    for (var groups = this._groups, m2 = groups.length, subgroups = [], parents = [], j = 0; j < m2; ++j) {
      for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
        if (node = group[i]) {
          subgroups.push(select.call(node, node.__data__, i, group));
          parents.push(node);
        }
      }
    }
    return new Selection(subgroups, parents);
  }

  // node_modules/d3-selection/src/matcher.js
  function matcher_default(selector) {
    return function() {
      return this.matches(selector);
    };
  }
  function childMatcher(selector) {
    return function(node) {
      return node.matches(selector);
    };
  }

  // node_modules/d3-selection/src/selection/selectChild.js
  var find = Array.prototype.find;
  function childFind(match) {
    return function() {
      return find.call(this.children, match);
    };
  }
  function childFirst() {
    return this.firstElementChild;
  }
  function selectChild_default(match) {
    return this.select(match == null ? childFirst : childFind(typeof match === "function" ? match : childMatcher(match)));
  }

  // node_modules/d3-selection/src/selection/selectChildren.js
  var filter = Array.prototype.filter;
  function children() {
    return Array.from(this.children);
  }
  function childrenFilter(match) {
    return function() {
      return filter.call(this.children, match);
    };
  }
  function selectChildren_default(match) {
    return this.selectAll(match == null ? children : childrenFilter(typeof match === "function" ? match : childMatcher(match)));
  }

  // node_modules/d3-selection/src/selection/filter.js
  function filter_default(match) {
    if (typeof match !== "function")
      match = matcher_default(match);
    for (var groups = this._groups, m2 = groups.length, subgroups = new Array(m2), j = 0; j < m2; ++j) {
      for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
        if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
          subgroup.push(node);
        }
      }
    }
    return new Selection(subgroups, this._parents);
  }

  // node_modules/d3-selection/src/selection/sparse.js
  function sparse_default(update) {
    return new Array(update.length);
  }

  // node_modules/d3-selection/src/selection/enter.js
  function enter_default() {
    return new Selection(this._enter || this._groups.map(sparse_default), this._parents);
  }
  function EnterNode(parent2, datum2) {
    this.ownerDocument = parent2.ownerDocument;
    this.namespaceURI = parent2.namespaceURI;
    this._next = null;
    this._parent = parent2;
    this.__data__ = datum2;
  }
  EnterNode.prototype = {
    constructor: EnterNode,
    appendChild: function(child) {
      return this._parent.insertBefore(child, this._next);
    },
    insertBefore: function(child, next) {
      return this._parent.insertBefore(child, next);
    },
    querySelector: function(selector) {
      return this._parent.querySelector(selector);
    },
    querySelectorAll: function(selector) {
      return this._parent.querySelectorAll(selector);
    }
  };

  // node_modules/d3-selection/src/constant.js
  function constant_default(x3) {
    return function() {
      return x3;
    };
  }

  // node_modules/d3-selection/src/selection/data.js
  function bindIndex(parent2, group, enter, update, exit, data) {
    var i = 0, node, groupLength = group.length, dataLength = data.length;
    for (; i < dataLength; ++i) {
      if (node = group[i]) {
        node.__data__ = data[i];
        update[i] = node;
      } else {
        enter[i] = new EnterNode(parent2, data[i]);
      }
    }
    for (; i < groupLength; ++i) {
      if (node = group[i]) {
        exit[i] = node;
      }
    }
  }
  function bindKey(parent2, group, enter, update, exit, data, key) {
    var i, node, nodeByKeyValue = /* @__PURE__ */ new Map(), groupLength = group.length, dataLength = data.length, keyValues = new Array(groupLength), keyValue;
    for (i = 0; i < groupLength; ++i) {
      if (node = group[i]) {
        keyValues[i] = keyValue = key.call(node, node.__data__, i, group) + "";
        if (nodeByKeyValue.has(keyValue)) {
          exit[i] = node;
        } else {
          nodeByKeyValue.set(keyValue, node);
        }
      }
    }
    for (i = 0; i < dataLength; ++i) {
      keyValue = key.call(parent2, data[i], i, data) + "";
      if (node = nodeByKeyValue.get(keyValue)) {
        update[i] = node;
        node.__data__ = data[i];
        nodeByKeyValue.delete(keyValue);
      } else {
        enter[i] = new EnterNode(parent2, data[i]);
      }
    }
    for (i = 0; i < groupLength; ++i) {
      if ((node = group[i]) && nodeByKeyValue.get(keyValues[i]) === node) {
        exit[i] = node;
      }
    }
  }
  function datum(node) {
    return node.__data__;
  }
  function data_default(value, key) {
    if (!arguments.length)
      return Array.from(this, datum);
    var bind = key ? bindKey : bindIndex, parents = this._parents, groups = this._groups;
    if (typeof value !== "function")
      value = constant_default(value);
    for (var m2 = groups.length, update = new Array(m2), enter = new Array(m2), exit = new Array(m2), j = 0; j < m2; ++j) {
      var parent2 = parents[j], group = groups[j], groupLength = group.length, data = arraylike(value.call(parent2, parent2 && parent2.__data__, j, parents)), dataLength = data.length, enterGroup = enter[j] = new Array(dataLength), updateGroup = update[j] = new Array(dataLength), exitGroup = exit[j] = new Array(groupLength);
      bind(parent2, group, enterGroup, updateGroup, exitGroup, data, key);
      for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
        if (previous = enterGroup[i0]) {
          if (i0 >= i1)
            i1 = i0 + 1;
          while (!(next = updateGroup[i1]) && ++i1 < dataLength)
            ;
          previous._next = next || null;
        }
      }
    }
    update = new Selection(update, parents);
    update._enter = enter;
    update._exit = exit;
    return update;
  }
  function arraylike(data) {
    return typeof data === "object" && "length" in data ? data : Array.from(data);
  }

  // node_modules/d3-selection/src/selection/exit.js
  function exit_default() {
    return new Selection(this._exit || this._groups.map(sparse_default), this._parents);
  }

  // node_modules/d3-selection/src/selection/join.js
  function join_default(onenter, onupdate, onexit) {
    var enter = this.enter(), update = this, exit = this.exit();
    if (typeof onenter === "function") {
      enter = onenter(enter);
      if (enter)
        enter = enter.selection();
    } else {
      enter = enter.append(onenter + "");
    }
    if (onupdate != null) {
      update = onupdate(update);
      if (update)
        update = update.selection();
    }
    if (onexit == null)
      exit.remove();
    else
      onexit(exit);
    return enter && update ? enter.merge(update).order() : update;
  }

  // node_modules/d3-selection/src/selection/merge.js
  function merge_default(context2) {
    var selection2 = context2.selection ? context2.selection() : context2;
    for (var groups0 = this._groups, groups1 = selection2._groups, m0 = groups0.length, m1 = groups1.length, m2 = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m2; ++j) {
      for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
        if (node = group0[i] || group1[i]) {
          merge[i] = node;
        }
      }
    }
    for (; j < m0; ++j) {
      merges[j] = groups0[j];
    }
    return new Selection(merges, this._parents);
  }

  // node_modules/d3-selection/src/selection/order.js
  function order_default() {
    for (var groups = this._groups, j = -1, m2 = groups.length; ++j < m2; ) {
      for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0; ) {
        if (node = group[i]) {
          if (next && node.compareDocumentPosition(next) ^ 4)
            next.parentNode.insertBefore(node, next);
          next = node;
        }
      }
    }
    return this;
  }

  // node_modules/d3-selection/src/selection/sort.js
  function sort_default(compare) {
    if (!compare)
      compare = ascending;
    function compareNode(a2, b) {
      return a2 && b ? compare(a2.__data__, b.__data__) : !a2 - !b;
    }
    for (var groups = this._groups, m2 = groups.length, sortgroups = new Array(m2), j = 0; j < m2; ++j) {
      for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
        if (node = group[i]) {
          sortgroup[i] = node;
        }
      }
      sortgroup.sort(compareNode);
    }
    return new Selection(sortgroups, this._parents).order();
  }
  function ascending(a2, b) {
    return a2 < b ? -1 : a2 > b ? 1 : a2 >= b ? 0 : NaN;
  }

  // node_modules/d3-selection/src/selection/call.js
  function call_default() {
    var callback = arguments[0];
    arguments[0] = this;
    callback.apply(null, arguments);
    return this;
  }

  // node_modules/d3-selection/src/selection/nodes.js
  function nodes_default() {
    return Array.from(this);
  }

  // node_modules/d3-selection/src/selection/node.js
  function node_default() {
    for (var groups = this._groups, j = 0, m2 = groups.length; j < m2; ++j) {
      for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
        var node = group[i];
        if (node)
          return node;
      }
    }
    return null;
  }

  // node_modules/d3-selection/src/selection/size.js
  function size_default() {
    let size = 0;
    for (const node of this)
      ++size;
    return size;
  }

  // node_modules/d3-selection/src/selection/empty.js
  function empty_default() {
    return !this.node();
  }

  // node_modules/d3-selection/src/selection/each.js
  function each_default(callback) {
    for (var groups = this._groups, j = 0, m2 = groups.length; j < m2; ++j) {
      for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
        if (node = group[i])
          callback.call(node, node.__data__, i, group);
      }
    }
    return this;
  }

  // node_modules/d3-selection/src/selection/attr.js
  function attrRemove(name) {
    return function() {
      this.removeAttribute(name);
    };
  }
  function attrRemoveNS(fullname) {
    return function() {
      this.removeAttributeNS(fullname.space, fullname.local);
    };
  }
  function attrConstant(name, value) {
    return function() {
      this.setAttribute(name, value);
    };
  }
  function attrConstantNS(fullname, value) {
    return function() {
      this.setAttributeNS(fullname.space, fullname.local, value);
    };
  }
  function attrFunction(name, value) {
    return function() {
      var v = value.apply(this, arguments);
      if (v == null)
        this.removeAttribute(name);
      else
        this.setAttribute(name, v);
    };
  }
  function attrFunctionNS(fullname, value) {
    return function() {
      var v = value.apply(this, arguments);
      if (v == null)
        this.removeAttributeNS(fullname.space, fullname.local);
      else
        this.setAttributeNS(fullname.space, fullname.local, v);
    };
  }
  function attr_default(name, value) {
    var fullname = namespace_default(name);
    if (arguments.length < 2) {
      var node = this.node();
      return fullname.local ? node.getAttributeNS(fullname.space, fullname.local) : node.getAttribute(fullname);
    }
    return this.each((value == null ? fullname.local ? attrRemoveNS : attrRemove : typeof value === "function" ? fullname.local ? attrFunctionNS : attrFunction : fullname.local ? attrConstantNS : attrConstant)(fullname, value));
  }

  // node_modules/d3-selection/src/window.js
  function window_default(node) {
    return node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView;
  }

  // node_modules/d3-selection/src/selection/style.js
  function styleRemove(name) {
    return function() {
      this.style.removeProperty(name);
    };
  }
  function styleConstant(name, value, priority) {
    return function() {
      this.style.setProperty(name, value, priority);
    };
  }
  function styleFunction(name, value, priority) {
    return function() {
      var v = value.apply(this, arguments);
      if (v == null)
        this.style.removeProperty(name);
      else
        this.style.setProperty(name, v, priority);
    };
  }
  function style_default(name, value, priority) {
    return arguments.length > 1 ? this.each((value == null ? styleRemove : typeof value === "function" ? styleFunction : styleConstant)(name, value, priority == null ? "" : priority)) : styleValue(this.node(), name);
  }
  function styleValue(node, name) {
    return node.style.getPropertyValue(name) || window_default(node).getComputedStyle(node, null).getPropertyValue(name);
  }

  // node_modules/d3-selection/src/selection/property.js
  function propertyRemove(name) {
    return function() {
      delete this[name];
    };
  }
  function propertyConstant(name, value) {
    return function() {
      this[name] = value;
    };
  }
  function propertyFunction(name, value) {
    return function() {
      var v = value.apply(this, arguments);
      if (v == null)
        delete this[name];
      else
        this[name] = v;
    };
  }
  function property_default(name, value) {
    return arguments.length > 1 ? this.each((value == null ? propertyRemove : typeof value === "function" ? propertyFunction : propertyConstant)(name, value)) : this.node()[name];
  }

  // node_modules/d3-selection/src/selection/classed.js
  function classArray(string) {
    return string.trim().split(/^|\s+/);
  }
  function classList(node) {
    return node.classList || new ClassList(node);
  }
  function ClassList(node) {
    this._node = node;
    this._names = classArray(node.getAttribute("class") || "");
  }
  ClassList.prototype = {
    add: function(name) {
      var i = this._names.indexOf(name);
      if (i < 0) {
        this._names.push(name);
        this._node.setAttribute("class", this._names.join(" "));
      }
    },
    remove: function(name) {
      var i = this._names.indexOf(name);
      if (i >= 0) {
        this._names.splice(i, 1);
        this._node.setAttribute("class", this._names.join(" "));
      }
    },
    contains: function(name) {
      return this._names.indexOf(name) >= 0;
    }
  };
  function classedAdd(node, names) {
    var list = classList(node), i = -1, n = names.length;
    while (++i < n)
      list.add(names[i]);
  }
  function classedRemove(node, names) {
    var list = classList(node), i = -1, n = names.length;
    while (++i < n)
      list.remove(names[i]);
  }
  function classedTrue(names) {
    return function() {
      classedAdd(this, names);
    };
  }
  function classedFalse(names) {
    return function() {
      classedRemove(this, names);
    };
  }
  function classedFunction(names, value) {
    return function() {
      (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
    };
  }
  function classed_default(name, value) {
    var names = classArray(name + "");
    if (arguments.length < 2) {
      var list = classList(this.node()), i = -1, n = names.length;
      while (++i < n)
        if (!list.contains(names[i]))
          return false;
      return true;
    }
    return this.each((typeof value === "function" ? classedFunction : value ? classedTrue : classedFalse)(names, value));
  }

  // node_modules/d3-selection/src/selection/text.js
  function textRemove() {
    this.textContent = "";
  }
  function textConstant(value) {
    return function() {
      this.textContent = value;
    };
  }
  function textFunction(value) {
    return function() {
      var v = value.apply(this, arguments);
      this.textContent = v == null ? "" : v;
    };
  }
  function text_default(value) {
    return arguments.length ? this.each(value == null ? textRemove : (typeof value === "function" ? textFunction : textConstant)(value)) : this.node().textContent;
  }

  // node_modules/d3-selection/src/selection/html.js
  function htmlRemove() {
    this.innerHTML = "";
  }
  function htmlConstant(value) {
    return function() {
      this.innerHTML = value;
    };
  }
  function htmlFunction(value) {
    return function() {
      var v = value.apply(this, arguments);
      this.innerHTML = v == null ? "" : v;
    };
  }
  function html_default(value) {
    return arguments.length ? this.each(value == null ? htmlRemove : (typeof value === "function" ? htmlFunction : htmlConstant)(value)) : this.node().innerHTML;
  }

  // node_modules/d3-selection/src/selection/raise.js
  function raise() {
    if (this.nextSibling)
      this.parentNode.appendChild(this);
  }
  function raise_default() {
    return this.each(raise);
  }

  // node_modules/d3-selection/src/selection/lower.js
  function lower() {
    if (this.previousSibling)
      this.parentNode.insertBefore(this, this.parentNode.firstChild);
  }
  function lower_default() {
    return this.each(lower);
  }

  // node_modules/d3-selection/src/selection/append.js
  function append_default(name) {
    var create2 = typeof name === "function" ? name : creator_default(name);
    return this.select(function() {
      return this.appendChild(create2.apply(this, arguments));
    });
  }

  // node_modules/d3-selection/src/selection/insert.js
  function constantNull() {
    return null;
  }
  function insert_default(name, before) {
    var create2 = typeof name === "function" ? name : creator_default(name), select = before == null ? constantNull : typeof before === "function" ? before : selector_default(before);
    return this.select(function() {
      return this.insertBefore(create2.apply(this, arguments), select.apply(this, arguments) || null);
    });
  }

  // node_modules/d3-selection/src/selection/remove.js
  function remove() {
    var parent2 = this.parentNode;
    if (parent2)
      parent2.removeChild(this);
  }
  function remove_default() {
    return this.each(remove);
  }

  // node_modules/d3-selection/src/selection/clone.js
  function selection_cloneShallow() {
    var clone = this.cloneNode(false), parent2 = this.parentNode;
    return parent2 ? parent2.insertBefore(clone, this.nextSibling) : clone;
  }
  function selection_cloneDeep() {
    var clone = this.cloneNode(true), parent2 = this.parentNode;
    return parent2 ? parent2.insertBefore(clone, this.nextSibling) : clone;
  }
  function clone_default(deep) {
    return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
  }

  // node_modules/d3-selection/src/selection/datum.js
  function datum_default(value) {
    return arguments.length ? this.property("__data__", value) : this.node().__data__;
  }

  // node_modules/d3-selection/src/selection/on.js
  function contextListener(listener) {
    return function(event) {
      listener.call(this, event, this.__data__);
    };
  }
  function parseTypenames2(typenames) {
    return typenames.trim().split(/^|\s+/).map(function(t) {
      var name = "", i = t.indexOf(".");
      if (i >= 0)
        name = t.slice(i + 1), t = t.slice(0, i);
      return { type: t, name };
    });
  }
  function onRemove(typename) {
    return function() {
      var on = this.__on;
      if (!on)
        return;
      for (var j = 0, i = -1, m2 = on.length, o; j < m2; ++j) {
        if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
          this.removeEventListener(o.type, o.listener, o.options);
        } else {
          on[++i] = o;
        }
      }
      if (++i)
        on.length = i;
      else
        delete this.__on;
    };
  }
  function onAdd(typename, value, options) {
    return function() {
      var on = this.__on, o, listener = contextListener(value);
      if (on)
        for (var j = 0, m2 = on.length; j < m2; ++j) {
          if ((o = on[j]).type === typename.type && o.name === typename.name) {
            this.removeEventListener(o.type, o.listener, o.options);
            this.addEventListener(o.type, o.listener = listener, o.options = options);
            o.value = value;
            return;
          }
        }
      this.addEventListener(typename.type, listener, options);
      o = { type: typename.type, name: typename.name, value, listener, options };
      if (!on)
        this.__on = [o];
      else
        on.push(o);
    };
  }
  function on_default(typename, value, options) {
    var typenames = parseTypenames2(typename + ""), i, n = typenames.length, t;
    if (arguments.length < 2) {
      var on = this.node().__on;
      if (on)
        for (var j = 0, m2 = on.length, o; j < m2; ++j) {
          for (i = 0, o = on[j]; i < n; ++i) {
            if ((t = typenames[i]).type === o.type && t.name === o.name) {
              return o.value;
            }
          }
        }
      return;
    }
    on = value ? onAdd : onRemove;
    for (i = 0; i < n; ++i)
      this.each(on(typenames[i], value, options));
    return this;
  }

  // node_modules/d3-selection/src/selection/dispatch.js
  function dispatchEvent(node, type2, params) {
    var window2 = window_default(node), event = window2.CustomEvent;
    if (typeof event === "function") {
      event = new event(type2, params);
    } else {
      event = window2.document.createEvent("Event");
      if (params)
        event.initEvent(type2, params.bubbles, params.cancelable), event.detail = params.detail;
      else
        event.initEvent(type2, false, false);
    }
    node.dispatchEvent(event);
  }
  function dispatchConstant(type2, params) {
    return function() {
      return dispatchEvent(this, type2, params);
    };
  }
  function dispatchFunction(type2, params) {
    return function() {
      return dispatchEvent(this, type2, params.apply(this, arguments));
    };
  }
  function dispatch_default2(type2, params) {
    return this.each((typeof params === "function" ? dispatchFunction : dispatchConstant)(type2, params));
  }

  // node_modules/d3-selection/src/selection/iterator.js
  function* iterator_default() {
    for (var groups = this._groups, j = 0, m2 = groups.length; j < m2; ++j) {
      for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
        if (node = group[i])
          yield node;
      }
    }
  }

  // node_modules/d3-selection/src/selection/index.js
  var root = [null];
  function Selection(groups, parents) {
    this._groups = groups;
    this._parents = parents;
  }
  function selection() {
    return new Selection([[document.documentElement]], root);
  }
  function selection_selection() {
    return this;
  }
  Selection.prototype = selection.prototype = {
    constructor: Selection,
    select: select_default,
    selectAll: selectAll_default,
    selectChild: selectChild_default,
    selectChildren: selectChildren_default,
    filter: filter_default,
    data: data_default,
    enter: enter_default,
    exit: exit_default,
    join: join_default,
    merge: merge_default,
    selection: selection_selection,
    order: order_default,
    sort: sort_default,
    call: call_default,
    nodes: nodes_default,
    node: node_default,
    size: size_default,
    empty: empty_default,
    each: each_default,
    attr: attr_default,
    style: style_default,
    property: property_default,
    classed: classed_default,
    text: text_default,
    html: html_default,
    raise: raise_default,
    lower: lower_default,
    append: append_default,
    insert: insert_default,
    remove: remove_default,
    clone: clone_default,
    datum: datum_default,
    on: on_default,
    dispatch: dispatch_default2,
    [Symbol.iterator]: iterator_default
  };
  var selection_default = selection;

  // node_modules/d3-selection/src/select.js
  function select_default2(selector) {
    return typeof selector === "string" ? new Selection([[document.querySelector(selector)]], [document.documentElement]) : new Selection([[selector]], root);
  }

  // node_modules/d3-selection/src/sourceEvent.js
  function sourceEvent_default(event) {
    let sourceEvent;
    while (sourceEvent = event.sourceEvent)
      event = sourceEvent;
    return event;
  }

  // node_modules/d3-selection/src/pointer.js
  function pointer_default(event, node) {
    event = sourceEvent_default(event);
    if (node === void 0)
      node = event.currentTarget;
    if (node) {
      var svg = node.ownerSVGElement || node;
      if (svg.createSVGPoint) {
        var point = svg.createSVGPoint();
        point.x = event.clientX, point.y = event.clientY;
        point = point.matrixTransform(node.getScreenCTM().inverse());
        return [point.x, point.y];
      }
      if (node.getBoundingClientRect) {
        var rect = node.getBoundingClientRect();
        return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
      }
    }
    return [event.pageX, event.pageY];
  }

  // node_modules/d3-drag/src/noevent.js
  var nonpassive = { passive: false };
  var nonpassivecapture = { capture: true, passive: false };
  function nopropagation(event) {
    event.stopImmediatePropagation();
  }
  function noevent_default(event) {
    event.preventDefault();
    event.stopImmediatePropagation();
  }

  // node_modules/d3-drag/src/nodrag.js
  function nodrag_default(view) {
    var root2 = view.document.documentElement, selection2 = select_default2(view).on("dragstart.drag", noevent_default, nonpassivecapture);
    if ("onselectstart" in root2) {
      selection2.on("selectstart.drag", noevent_default, nonpassivecapture);
    } else {
      root2.__noselect = root2.style.MozUserSelect;
      root2.style.MozUserSelect = "none";
    }
  }
  function yesdrag(view, noclick) {
    var root2 = view.document.documentElement, selection2 = select_default2(view).on("dragstart.drag", null);
    if (noclick) {
      selection2.on("click.drag", noevent_default, nonpassivecapture);
      setTimeout(function() {
        selection2.on("click.drag", null);
      }, 0);
    }
    if ("onselectstart" in root2) {
      selection2.on("selectstart.drag", null);
    } else {
      root2.style.MozUserSelect = root2.__noselect;
      delete root2.__noselect;
    }
  }

  // node_modules/d3-drag/src/constant.js
  var constant_default2 = (x3) => () => x3;

  // node_modules/d3-drag/src/event.js
  function DragEvent(type2, {
    sourceEvent,
    subject,
    target,
    identifier,
    active,
    x: x3,
    y: y3,
    dx,
    dy,
    dispatch: dispatch2
  }) {
    Object.defineProperties(this, {
      type: { value: type2, enumerable: true, configurable: true },
      sourceEvent: { value: sourceEvent, enumerable: true, configurable: true },
      subject: { value: subject, enumerable: true, configurable: true },
      target: { value: target, enumerable: true, configurable: true },
      identifier: { value: identifier, enumerable: true, configurable: true },
      active: { value: active, enumerable: true, configurable: true },
      x: { value: x3, enumerable: true, configurable: true },
      y: { value: y3, enumerable: true, configurable: true },
      dx: { value: dx, enumerable: true, configurable: true },
      dy: { value: dy, enumerable: true, configurable: true },
      _: { value: dispatch2 }
    });
  }
  DragEvent.prototype.on = function() {
    var value = this._.on.apply(this._, arguments);
    return value === this._ ? this : value;
  };

  // node_modules/d3-drag/src/drag.js
  function defaultFilter(event) {
    return !event.ctrlKey && !event.button;
  }
  function defaultContainer() {
    return this.parentNode;
  }
  function defaultSubject(event, d) {
    return d == null ? { x: event.x, y: event.y } : d;
  }
  function defaultTouchable() {
    return navigator.maxTouchPoints || "ontouchstart" in this;
  }
  function drag_default() {
    var filter2 = defaultFilter, container = defaultContainer, subject = defaultSubject, touchable = defaultTouchable, gestures = {}, listeners = dispatch_default("start", "drag", "end"), active = 0, mousedownx, mousedowny, mousemoving, touchending, clickDistance2 = 0;
    function drag(selection2) {
      selection2.on("mousedown.drag", mousedowned).filter(touchable).on("touchstart.drag", touchstarted).on("touchmove.drag", touchmoved, nonpassive).on("touchend.drag touchcancel.drag", touchended).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
    }
    function mousedowned(event, d) {
      if (touchending || !filter2.call(this, event, d))
        return;
      var gesture = beforestart(this, container.call(this, event, d), event, d, "mouse");
      if (!gesture)
        return;
      select_default2(event.view).on("mousemove.drag", mousemoved, nonpassivecapture).on("mouseup.drag", mouseupped, nonpassivecapture);
      nodrag_default(event.view);
      nopropagation(event);
      mousemoving = false;
      mousedownx = event.clientX;
      mousedowny = event.clientY;
      gesture("start", event);
    }
    function mousemoved(event) {
      noevent_default(event);
      if (!mousemoving) {
        var dx = event.clientX - mousedownx, dy = event.clientY - mousedowny;
        mousemoving = dx * dx + dy * dy > clickDistance2;
      }
      gestures.mouse("drag", event);
    }
    function mouseupped(event) {
      select_default2(event.view).on("mousemove.drag mouseup.drag", null);
      yesdrag(event.view, mousemoving);
      noevent_default(event);
      gestures.mouse("end", event);
    }
    function touchstarted(event, d) {
      if (!filter2.call(this, event, d))
        return;
      var touches = event.changedTouches, c2 = container.call(this, event, d), n = touches.length, i, gesture;
      for (i = 0; i < n; ++i) {
        if (gesture = beforestart(this, c2, event, d, touches[i].identifier, touches[i])) {
          nopropagation(event);
          gesture("start", event, touches[i]);
        }
      }
    }
    function touchmoved(event) {
      var touches = event.changedTouches, n = touches.length, i, gesture;
      for (i = 0; i < n; ++i) {
        if (gesture = gestures[touches[i].identifier]) {
          noevent_default(event);
          gesture("drag", event, touches[i]);
        }
      }
    }
    function touchended(event) {
      var touches = event.changedTouches, n = touches.length, i, gesture;
      if (touchending)
        clearTimeout(touchending);
      touchending = setTimeout(function() {
        touchending = null;
      }, 500);
      for (i = 0; i < n; ++i) {
        if (gesture = gestures[touches[i].identifier]) {
          nopropagation(event);
          gesture("end", event, touches[i]);
        }
      }
    }
    function beforestart(that, container2, event, d, identifier, touch) {
      var dispatch2 = listeners.copy(), p = pointer_default(touch || event, container2), dx, dy, s;
      if ((s = subject.call(that, new DragEvent("beforestart", {
        sourceEvent: event,
        target: drag,
        identifier,
        active,
        x: p[0],
        y: p[1],
        dx: 0,
        dy: 0,
        dispatch: dispatch2
      }), d)) == null)
        return;
      dx = s.x - p[0] || 0;
      dy = s.y - p[1] || 0;
      return function gesture(type2, event2, touch2) {
        var p0 = p, n;
        switch (type2) {
          case "start":
            gestures[identifier] = gesture, n = active++;
            break;
          case "end":
            delete gestures[identifier], --active;
          case "drag":
            p = pointer_default(touch2 || event2, container2), n = active;
            break;
        }
        dispatch2.call(
          type2,
          that,
          new DragEvent(type2, {
            sourceEvent: event2,
            subject: s,
            target: drag,
            identifier,
            active: n,
            x: p[0] + dx,
            y: p[1] + dy,
            dx: p[0] - p0[0],
            dy: p[1] - p0[1],
            dispatch: dispatch2
          }),
          d
        );
      };
    }
    drag.filter = function(_2) {
      return arguments.length ? (filter2 = typeof _2 === "function" ? _2 : constant_default2(!!_2), drag) : filter2;
    };
    drag.container = function(_2) {
      return arguments.length ? (container = typeof _2 === "function" ? _2 : constant_default2(_2), drag) : container;
    };
    drag.subject = function(_2) {
      return arguments.length ? (subject = typeof _2 === "function" ? _2 : constant_default2(_2), drag) : subject;
    };
    drag.touchable = function(_2) {
      return arguments.length ? (touchable = typeof _2 === "function" ? _2 : constant_default2(!!_2), drag) : touchable;
    };
    drag.on = function() {
      var value = listeners.on.apply(listeners, arguments);
      return value === listeners ? drag : value;
    };
    drag.clickDistance = function(_2) {
      return arguments.length ? (clickDistance2 = (_2 = +_2) * _2, drag) : Math.sqrt(clickDistance2);
    };
    return drag;
  }

  // node_modules/d3-color/src/define.js
  function define_default(constructor, factory, prototype) {
    constructor.prototype = factory.prototype = prototype;
    prototype.constructor = constructor;
  }
  function extend(parent2, definition) {
    var prototype = Object.create(parent2.prototype);
    for (var key in definition)
      prototype[key] = definition[key];
    return prototype;
  }

  // node_modules/d3-color/src/color.js
  function Color() {
  }
  var darker = 0.7;
  var brighter = 1 / darker;
  var reI = "\\s*([+-]?\\d+)\\s*";
  var reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*";
  var reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
  var reHex = /^#([0-9a-f]{3,8})$/;
  var reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`);
  var reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`);
  var reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`);
  var reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`);
  var reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`);
  var reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);
  var named = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
  };
  define_default(Color, color, {
    copy(channels) {
      return Object.assign(new this.constructor(), this, channels);
    },
    displayable() {
      return this.rgb().displayable();
    },
    hex: color_formatHex,
    formatHex: color_formatHex,
    formatHex8: color_formatHex8,
    formatHsl: color_formatHsl,
    formatRgb: color_formatRgb,
    toString: color_formatRgb
  });
  function color_formatHex() {
    return this.rgb().formatHex();
  }
  function color_formatHex8() {
    return this.rgb().formatHex8();
  }
  function color_formatHsl() {
    return hslConvert(this).formatHsl();
  }
  function color_formatRgb() {
    return this.rgb().formatRgb();
  }
  function color(format2) {
    var m2, l;
    format2 = (format2 + "").trim().toLowerCase();
    return (m2 = reHex.exec(format2)) ? (l = m2[1].length, m2 = parseInt(m2[1], 16), l === 6 ? rgbn(m2) : l === 3 ? new Rgb(m2 >> 8 & 15 | m2 >> 4 & 240, m2 >> 4 & 15 | m2 & 240, (m2 & 15) << 4 | m2 & 15, 1) : l === 8 ? rgba(m2 >> 24 & 255, m2 >> 16 & 255, m2 >> 8 & 255, (m2 & 255) / 255) : l === 4 ? rgba(m2 >> 12 & 15 | m2 >> 8 & 240, m2 >> 8 & 15 | m2 >> 4 & 240, m2 >> 4 & 15 | m2 & 240, ((m2 & 15) << 4 | m2 & 15) / 255) : null) : (m2 = reRgbInteger.exec(format2)) ? new Rgb(m2[1], m2[2], m2[3], 1) : (m2 = reRgbPercent.exec(format2)) ? new Rgb(m2[1] * 255 / 100, m2[2] * 255 / 100, m2[3] * 255 / 100, 1) : (m2 = reRgbaInteger.exec(format2)) ? rgba(m2[1], m2[2], m2[3], m2[4]) : (m2 = reRgbaPercent.exec(format2)) ? rgba(m2[1] * 255 / 100, m2[2] * 255 / 100, m2[3] * 255 / 100, m2[4]) : (m2 = reHslPercent.exec(format2)) ? hsla(m2[1], m2[2] / 100, m2[3] / 100, 1) : (m2 = reHslaPercent.exec(format2)) ? hsla(m2[1], m2[2] / 100, m2[3] / 100, m2[4]) : named.hasOwnProperty(format2) ? rgbn(named[format2]) : format2 === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
  }
  function rgbn(n) {
    return new Rgb(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
  }
  function rgba(r, g, b, a2) {
    if (a2 <= 0)
      r = g = b = NaN;
    return new Rgb(r, g, b, a2);
  }
  function rgbConvert(o) {
    if (!(o instanceof Color))
      o = color(o);
    if (!o)
      return new Rgb();
    o = o.rgb();
    return new Rgb(o.r, o.g, o.b, o.opacity);
  }
  function rgb(r, g, b, opacity) {
    return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
  }
  function Rgb(r, g, b, opacity) {
    this.r = +r;
    this.g = +g;
    this.b = +b;
    this.opacity = +opacity;
  }
  define_default(Rgb, rgb, extend(Color, {
    brighter(k) {
      k = k == null ? brighter : Math.pow(brighter, k);
      return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
    },
    darker(k) {
      k = k == null ? darker : Math.pow(darker, k);
      return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
    },
    rgb() {
      return this;
    },
    clamp() {
      return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
    },
    displayable() {
      return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
    },
    hex: rgb_formatHex,
    formatHex: rgb_formatHex,
    formatHex8: rgb_formatHex8,
    formatRgb: rgb_formatRgb,
    toString: rgb_formatRgb
  }));
  function rgb_formatHex() {
    return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
  }
  function rgb_formatHex8() {
    return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
  }
  function rgb_formatRgb() {
    const a2 = clampa(this.opacity);
    return `${a2 === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a2 === 1 ? ")" : `, ${a2})`}`;
  }
  function clampa(opacity) {
    return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
  }
  function clampi(value) {
    return Math.max(0, Math.min(255, Math.round(value) || 0));
  }
  function hex(value) {
    value = clampi(value);
    return (value < 16 ? "0" : "") + value.toString(16);
  }
  function hsla(h, s, l, a2) {
    if (a2 <= 0)
      h = s = l = NaN;
    else if (l <= 0 || l >= 1)
      h = s = NaN;
    else if (s <= 0)
      h = NaN;
    return new Hsl(h, s, l, a2);
  }
  function hslConvert(o) {
    if (o instanceof Hsl)
      return new Hsl(o.h, o.s, o.l, o.opacity);
    if (!(o instanceof Color))
      o = color(o);
    if (!o)
      return new Hsl();
    if (o instanceof Hsl)
      return o;
    o = o.rgb();
    var r = o.r / 255, g = o.g / 255, b = o.b / 255, min2 = Math.min(r, g, b), max2 = Math.max(r, g, b), h = NaN, s = max2 - min2, l = (max2 + min2) / 2;
    if (s) {
      if (r === max2)
        h = (g - b) / s + (g < b) * 6;
      else if (g === max2)
        h = (b - r) / s + 2;
      else
        h = (r - g) / s + 4;
      s /= l < 0.5 ? max2 + min2 : 2 - max2 - min2;
      h *= 60;
    } else {
      s = l > 0 && l < 1 ? 0 : h;
    }
    return new Hsl(h, s, l, o.opacity);
  }
  function hsl(h, s, l, opacity) {
    return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
  }
  function Hsl(h, s, l, opacity) {
    this.h = +h;
    this.s = +s;
    this.l = +l;
    this.opacity = +opacity;
  }
  define_default(Hsl, hsl, extend(Color, {
    brighter(k) {
      k = k == null ? brighter : Math.pow(brighter, k);
      return new Hsl(this.h, this.s, this.l * k, this.opacity);
    },
    darker(k) {
      k = k == null ? darker : Math.pow(darker, k);
      return new Hsl(this.h, this.s, this.l * k, this.opacity);
    },
    rgb() {
      var h = this.h % 360 + (this.h < 0) * 360, s = isNaN(h) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < 0.5 ? l : 1 - l) * s, m1 = 2 * l - m2;
      return new Rgb(
        hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
        hsl2rgb(h, m1, m2),
        hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
        this.opacity
      );
    },
    clamp() {
      return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
    },
    displayable() {
      return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
    },
    formatHsl() {
      const a2 = clampa(this.opacity);
      return `${a2 === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a2 === 1 ? ")" : `, ${a2})`}`;
    }
  }));
  function clamph(value) {
    value = (value || 0) % 360;
    return value < 0 ? value + 360 : value;
  }
  function clampt(value) {
    return Math.max(0, Math.min(1, value || 0));
  }
  function hsl2rgb(h, m1, m2) {
    return (h < 60 ? m1 + (m2 - m1) * h / 60 : h < 180 ? m2 : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60 : m1) * 255;
  }

  // node_modules/d3-interpolate/src/basis.js
  function basis(t1, v0, v1, v2, v3) {
    var t2 = t1 * t1, t3 = t2 * t1;
    return ((1 - 3 * t1 + 3 * t2 - t3) * v0 + (4 - 6 * t2 + 3 * t3) * v1 + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2 + t3 * v3) / 6;
  }
  function basis_default(values) {
    var n = values.length - 1;
    return function(t) {
      var i = t <= 0 ? t = 0 : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n), v1 = values[i], v2 = values[i + 1], v0 = i > 0 ? values[i - 1] : 2 * v1 - v2, v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
      return basis((t - i / n) * n, v0, v1, v2, v3);
    };
  }

  // node_modules/d3-interpolate/src/basisClosed.js
  function basisClosed_default(values) {
    var n = values.length;
    return function(t) {
      var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n), v0 = values[(i + n - 1) % n], v1 = values[i % n], v2 = values[(i + 1) % n], v3 = values[(i + 2) % n];
      return basis((t - i / n) * n, v0, v1, v2, v3);
    };
  }

  // node_modules/d3-interpolate/src/constant.js
  var constant_default3 = (x3) => () => x3;

  // node_modules/d3-interpolate/src/color.js
  function linear(a2, d) {
    return function(t) {
      return a2 + t * d;
    };
  }
  function exponential(a2, b, y3) {
    return a2 = Math.pow(a2, y3), b = Math.pow(b, y3) - a2, y3 = 1 / y3, function(t) {
      return Math.pow(a2 + t * b, y3);
    };
  }
  function gamma(y3) {
    return (y3 = +y3) === 1 ? nogamma : function(a2, b) {
      return b - a2 ? exponential(a2, b, y3) : constant_default3(isNaN(a2) ? b : a2);
    };
  }
  function nogamma(a2, b) {
    var d = b - a2;
    return d ? linear(a2, d) : constant_default3(isNaN(a2) ? b : a2);
  }

  // node_modules/d3-interpolate/src/rgb.js
  var rgb_default = function rgbGamma(y3) {
    var color2 = gamma(y3);
    function rgb2(start2, end) {
      var r = color2((start2 = rgb(start2)).r, (end = rgb(end)).r), g = color2(start2.g, end.g), b = color2(start2.b, end.b), opacity = nogamma(start2.opacity, end.opacity);
      return function(t) {
        start2.r = r(t);
        start2.g = g(t);
        start2.b = b(t);
        start2.opacity = opacity(t);
        return start2 + "";
      };
    }
    rgb2.gamma = rgbGamma;
    return rgb2;
  }(1);
  function rgbSpline(spline) {
    return function(colors) {
      var n = colors.length, r = new Array(n), g = new Array(n), b = new Array(n), i, color2;
      for (i = 0; i < n; ++i) {
        color2 = rgb(colors[i]);
        r[i] = color2.r || 0;
        g[i] = color2.g || 0;
        b[i] = color2.b || 0;
      }
      r = spline(r);
      g = spline(g);
      b = spline(b);
      color2.opacity = 1;
      return function(t) {
        color2.r = r(t);
        color2.g = g(t);
        color2.b = b(t);
        return color2 + "";
      };
    };
  }
  var rgbBasis = rgbSpline(basis_default);
  var rgbBasisClosed = rgbSpline(basisClosed_default);

  // node_modules/d3-interpolate/src/number.js
  function number_default(a2, b) {
    return a2 = +a2, b = +b, function(t) {
      return a2 * (1 - t) + b * t;
    };
  }

  // node_modules/d3-interpolate/src/string.js
  var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
  var reB = new RegExp(reA.source, "g");
  function zero(b) {
    return function() {
      return b;
    };
  }
  function one(b) {
    return function(t) {
      return b(t) + "";
    };
  }
  function string_default(a2, b) {
    var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i = -1, s = [], q = [];
    a2 = a2 + "", b = b + "";
    while ((am = reA.exec(a2)) && (bm = reB.exec(b))) {
      if ((bs = bm.index) > bi) {
        bs = b.slice(bi, bs);
        if (s[i])
          s[i] += bs;
        else
          s[++i] = bs;
      }
      if ((am = am[0]) === (bm = bm[0])) {
        if (s[i])
          s[i] += bm;
        else
          s[++i] = bm;
      } else {
        s[++i] = null;
        q.push({ i, x: number_default(am, bm) });
      }
      bi = reB.lastIndex;
    }
    if (bi < b.length) {
      bs = b.slice(bi);
      if (s[i])
        s[i] += bs;
      else
        s[++i] = bs;
    }
    return s.length < 2 ? q[0] ? one(q[0].x) : zero(b) : (b = q.length, function(t) {
      for (var i2 = 0, o; i2 < b; ++i2)
        s[(o = q[i2]).i] = o.x(t);
      return s.join("");
    });
  }

  // node_modules/d3-interpolate/src/transform/decompose.js
  var degrees = 180 / Math.PI;
  var identity = {
    translateX: 0,
    translateY: 0,
    rotate: 0,
    skewX: 0,
    scaleX: 1,
    scaleY: 1
  };
  function decompose_default(a2, b, c2, d, e, f) {
    var scaleX, scaleY, skewX;
    if (scaleX = Math.sqrt(a2 * a2 + b * b))
      a2 /= scaleX, b /= scaleX;
    if (skewX = a2 * c2 + b * d)
      c2 -= a2 * skewX, d -= b * skewX;
    if (scaleY = Math.sqrt(c2 * c2 + d * d))
      c2 /= scaleY, d /= scaleY, skewX /= scaleY;
    if (a2 * d < b * c2)
      a2 = -a2, b = -b, skewX = -skewX, scaleX = -scaleX;
    return {
      translateX: e,
      translateY: f,
      rotate: Math.atan2(b, a2) * degrees,
      skewX: Math.atan(skewX) * degrees,
      scaleX,
      scaleY
    };
  }

  // node_modules/d3-interpolate/src/transform/parse.js
  var svgNode;
  function parseCss(value) {
    const m2 = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
    return m2.isIdentity ? identity : decompose_default(m2.a, m2.b, m2.c, m2.d, m2.e, m2.f);
  }
  function parseSvg(value) {
    if (value == null)
      return identity;
    if (!svgNode)
      svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
    svgNode.setAttribute("transform", value);
    if (!(value = svgNode.transform.baseVal.consolidate()))
      return identity;
    value = value.matrix;
    return decompose_default(value.a, value.b, value.c, value.d, value.e, value.f);
  }

  // node_modules/d3-interpolate/src/transform/index.js
  function interpolateTransform(parse2, pxComma, pxParen, degParen) {
    function pop(s) {
      return s.length ? s.pop() + " " : "";
    }
    function translate(xa, ya, xb, yb, s, q) {
      if (xa !== xb || ya !== yb) {
        var i = s.push("translate(", null, pxComma, null, pxParen);
        q.push({ i: i - 4, x: number_default(xa, xb) }, { i: i - 2, x: number_default(ya, yb) });
      } else if (xb || yb) {
        s.push("translate(" + xb + pxComma + yb + pxParen);
      }
    }
    function rotate(a2, b, s, q) {
      if (a2 !== b) {
        if (a2 - b > 180)
          b += 360;
        else if (b - a2 > 180)
          a2 += 360;
        q.push({ i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: number_default(a2, b) });
      } else if (b) {
        s.push(pop(s) + "rotate(" + b + degParen);
      }
    }
    function skewX(a2, b, s, q) {
      if (a2 !== b) {
        q.push({ i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: number_default(a2, b) });
      } else if (b) {
        s.push(pop(s) + "skewX(" + b + degParen);
      }
    }
    function scale(xa, ya, xb, yb, s, q) {
      if (xa !== xb || ya !== yb) {
        var i = s.push(pop(s) + "scale(", null, ",", null, ")");
        q.push({ i: i - 4, x: number_default(xa, xb) }, { i: i - 2, x: number_default(ya, yb) });
      } else if (xb !== 1 || yb !== 1) {
        s.push(pop(s) + "scale(" + xb + "," + yb + ")");
      }
    }
    return function(a2, b) {
      var s = [], q = [];
      a2 = parse2(a2), b = parse2(b);
      translate(a2.translateX, a2.translateY, b.translateX, b.translateY, s, q);
      rotate(a2.rotate, b.rotate, s, q);
      skewX(a2.skewX, b.skewX, s, q);
      scale(a2.scaleX, a2.scaleY, b.scaleX, b.scaleY, s, q);
      a2 = b = null;
      return function(t) {
        var i = -1, n = q.length, o;
        while (++i < n)
          s[(o = q[i]).i] = o.x(t);
        return s.join("");
      };
    };
  }
  var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
  var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

  // node_modules/d3-timer/src/timer.js
  var frame = 0;
  var timeout = 0;
  var interval = 0;
  var pokeDelay = 1e3;
  var taskHead;
  var taskTail;
  var clockLast = 0;
  var clockNow = 0;
  var clockSkew = 0;
  var clock = typeof performance === "object" && performance.now ? performance : Date;
  var setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) {
    setTimeout(f, 17);
  };
  function now() {
    return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
  }
  function clearNow() {
    clockNow = 0;
  }
  function Timer() {
    this._call = this._time = this._next = null;
  }
  Timer.prototype = timer.prototype = {
    constructor: Timer,
    restart: function(callback, delay, time) {
      if (typeof callback !== "function")
        throw new TypeError("callback is not a function");
      time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
      if (!this._next && taskTail !== this) {
        if (taskTail)
          taskTail._next = this;
        else
          taskHead = this;
        taskTail = this;
      }
      this._call = callback;
      this._time = time;
      sleep();
    },
    stop: function() {
      if (this._call) {
        this._call = null;
        this._time = Infinity;
        sleep();
      }
    }
  };
  function timer(callback, delay, time) {
    var t = new Timer();
    t.restart(callback, delay, time);
    return t;
  }
  function timerFlush() {
    now();
    ++frame;
    var t = taskHead, e;
    while (t) {
      if ((e = clockNow - t._time) >= 0)
        t._call.call(void 0, e);
      t = t._next;
    }
    --frame;
  }
  function wake() {
    clockNow = (clockLast = clock.now()) + clockSkew;
    frame = timeout = 0;
    try {
      timerFlush();
    } finally {
      frame = 0;
      nap();
      clockNow = 0;
    }
  }
  function poke() {
    var now2 = clock.now(), delay = now2 - clockLast;
    if (delay > pokeDelay)
      clockSkew -= delay, clockLast = now2;
  }
  function nap() {
    var t0, t1 = taskHead, t2, time = Infinity;
    while (t1) {
      if (t1._call) {
        if (time > t1._time)
          time = t1._time;
        t0 = t1, t1 = t1._next;
      } else {
        t2 = t1._next, t1._next = null;
        t1 = t0 ? t0._next = t2 : taskHead = t2;
      }
    }
    taskTail = t0;
    sleep(time);
  }
  function sleep(time) {
    if (frame)
      return;
    if (timeout)
      timeout = clearTimeout(timeout);
    var delay = time - clockNow;
    if (delay > 24) {
      if (time < Infinity)
        timeout = setTimeout(wake, time - clock.now() - clockSkew);
      if (interval)
        interval = clearInterval(interval);
    } else {
      if (!interval)
        clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
      frame = 1, setFrame(wake);
    }
  }

  // node_modules/d3-timer/src/timeout.js
  function timeout_default(callback, delay, time) {
    var t = new Timer();
    delay = delay == null ? 0 : +delay;
    t.restart((elapsed) => {
      t.stop();
      callback(elapsed + delay);
    }, delay, time);
    return t;
  }

  // node_modules/d3-transition/src/transition/schedule.js
  var emptyOn = dispatch_default("start", "end", "cancel", "interrupt");
  var emptyTween = [];
  var CREATED = 0;
  var SCHEDULED = 1;
  var STARTING = 2;
  var STARTED = 3;
  var RUNNING = 4;
  var ENDING = 5;
  var ENDED = 6;
  function schedule_default(node, name, id2, index2, group, timing) {
    var schedules = node.__transition;
    if (!schedules)
      node.__transition = {};
    else if (id2 in schedules)
      return;
    create(node, id2, {
      name,
      index: index2,
      group,
      on: emptyOn,
      tween: emptyTween,
      time: timing.time,
      delay: timing.delay,
      duration: timing.duration,
      ease: timing.ease,
      timer: null,
      state: CREATED
    });
  }
  function init(node, id2) {
    var schedule = get2(node, id2);
    if (schedule.state > CREATED)
      throw new Error("too late; already scheduled");
    return schedule;
  }
  function set2(node, id2) {
    var schedule = get2(node, id2);
    if (schedule.state > STARTED)
      throw new Error("too late; already running");
    return schedule;
  }
  function get2(node, id2) {
    var schedule = node.__transition;
    if (!schedule || !(schedule = schedule[id2]))
      throw new Error("transition not found");
    return schedule;
  }
  function create(node, id2, self2) {
    var schedules = node.__transition, tween;
    schedules[id2] = self2;
    self2.timer = timer(schedule, 0, self2.time);
    function schedule(elapsed) {
      self2.state = SCHEDULED;
      self2.timer.restart(start2, self2.delay, self2.time);
      if (self2.delay <= elapsed)
        start2(elapsed - self2.delay);
    }
    function start2(elapsed) {
      var i, j, n, o;
      if (self2.state !== SCHEDULED)
        return stop();
      for (i in schedules) {
        o = schedules[i];
        if (o.name !== self2.name)
          continue;
        if (o.state === STARTED)
          return timeout_default(start2);
        if (o.state === RUNNING) {
          o.state = ENDED;
          o.timer.stop();
          o.on.call("interrupt", node, node.__data__, o.index, o.group);
          delete schedules[i];
        } else if (+i < id2) {
          o.state = ENDED;
          o.timer.stop();
          o.on.call("cancel", node, node.__data__, o.index, o.group);
          delete schedules[i];
        }
      }
      timeout_default(function() {
        if (self2.state === STARTED) {
          self2.state = RUNNING;
          self2.timer.restart(tick, self2.delay, self2.time);
          tick(elapsed);
        }
      });
      self2.state = STARTING;
      self2.on.call("start", node, node.__data__, self2.index, self2.group);
      if (self2.state !== STARTING)
        return;
      self2.state = STARTED;
      tween = new Array(n = self2.tween.length);
      for (i = 0, j = -1; i < n; ++i) {
        if (o = self2.tween[i].value.call(node, node.__data__, self2.index, self2.group)) {
          tween[++j] = o;
        }
      }
      tween.length = j + 1;
    }
    function tick(elapsed) {
      var t = elapsed < self2.duration ? self2.ease.call(null, elapsed / self2.duration) : (self2.timer.restart(stop), self2.state = ENDING, 1), i = -1, n = tween.length;
      while (++i < n) {
        tween[i].call(node, t);
      }
      if (self2.state === ENDING) {
        self2.on.call("end", node, node.__data__, self2.index, self2.group);
        stop();
      }
    }
    function stop() {
      self2.state = ENDED;
      self2.timer.stop();
      delete schedules[id2];
      for (var i in schedules)
        return;
      delete node.__transition;
    }
  }

  // node_modules/d3-transition/src/interrupt.js
  function interrupt_default(node, name) {
    var schedules = node.__transition, schedule, active, empty2 = true, i;
    if (!schedules)
      return;
    name = name == null ? null : name + "";
    for (i in schedules) {
      if ((schedule = schedules[i]).name !== name) {
        empty2 = false;
        continue;
      }
      active = schedule.state > STARTING && schedule.state < ENDING;
      schedule.state = ENDED;
      schedule.timer.stop();
      schedule.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule.index, schedule.group);
      delete schedules[i];
    }
    if (empty2)
      delete node.__transition;
  }

  // node_modules/d3-transition/src/selection/interrupt.js
  function interrupt_default2(name) {
    return this.each(function() {
      interrupt_default(this, name);
    });
  }

  // node_modules/d3-transition/src/transition/tween.js
  function tweenRemove(id2, name) {
    var tween0, tween1;
    return function() {
      var schedule = set2(this, id2), tween = schedule.tween;
      if (tween !== tween0) {
        tween1 = tween0 = tween;
        for (var i = 0, n = tween1.length; i < n; ++i) {
          if (tween1[i].name === name) {
            tween1 = tween1.slice();
            tween1.splice(i, 1);
            break;
          }
        }
      }
      schedule.tween = tween1;
    };
  }
  function tweenFunction(id2, name, value) {
    var tween0, tween1;
    if (typeof value !== "function")
      throw new Error();
    return function() {
      var schedule = set2(this, id2), tween = schedule.tween;
      if (tween !== tween0) {
        tween1 = (tween0 = tween).slice();
        for (var t = { name, value }, i = 0, n = tween1.length; i < n; ++i) {
          if (tween1[i].name === name) {
            tween1[i] = t;
            break;
          }
        }
        if (i === n)
          tween1.push(t);
      }
      schedule.tween = tween1;
    };
  }
  function tween_default(name, value) {
    var id2 = this._id;
    name += "";
    if (arguments.length < 2) {
      var tween = get2(this.node(), id2).tween;
      for (var i = 0, n = tween.length, t; i < n; ++i) {
        if ((t = tween[i]).name === name) {
          return t.value;
        }
      }
      return null;
    }
    return this.each((value == null ? tweenRemove : tweenFunction)(id2, name, value));
  }
  function tweenValue(transition2, name, value) {
    var id2 = transition2._id;
    transition2.each(function() {
      var schedule = set2(this, id2);
      (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
    });
    return function(node) {
      return get2(node, id2).value[name];
    };
  }

  // node_modules/d3-transition/src/transition/interpolate.js
  function interpolate_default(a2, b) {
    var c2;
    return (typeof b === "number" ? number_default : b instanceof color ? rgb_default : (c2 = color(b)) ? (b = c2, rgb_default) : string_default)(a2, b);
  }

  // node_modules/d3-transition/src/transition/attr.js
  function attrRemove2(name) {
    return function() {
      this.removeAttribute(name);
    };
  }
  function attrRemoveNS2(fullname) {
    return function() {
      this.removeAttributeNS(fullname.space, fullname.local);
    };
  }
  function attrConstant2(name, interpolate, value1) {
    var string00, string1 = value1 + "", interpolate0;
    return function() {
      var string0 = this.getAttribute(name);
      return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
    };
  }
  function attrConstantNS2(fullname, interpolate, value1) {
    var string00, string1 = value1 + "", interpolate0;
    return function() {
      var string0 = this.getAttributeNS(fullname.space, fullname.local);
      return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
    };
  }
  function attrFunction2(name, interpolate, value) {
    var string00, string10, interpolate0;
    return function() {
      var string0, value1 = value(this), string1;
      if (value1 == null)
        return void this.removeAttribute(name);
      string0 = this.getAttribute(name);
      string1 = value1 + "";
      return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
    };
  }
  function attrFunctionNS2(fullname, interpolate, value) {
    var string00, string10, interpolate0;
    return function() {
      var string0, value1 = value(this), string1;
      if (value1 == null)
        return void this.removeAttributeNS(fullname.space, fullname.local);
      string0 = this.getAttributeNS(fullname.space, fullname.local);
      string1 = value1 + "";
      return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
    };
  }
  function attr_default2(name, value) {
    var fullname = namespace_default(name), i = fullname === "transform" ? interpolateTransformSvg : interpolate_default;
    return this.attrTween(name, typeof value === "function" ? (fullname.local ? attrFunctionNS2 : attrFunction2)(fullname, i, tweenValue(this, "attr." + name, value)) : value == null ? (fullname.local ? attrRemoveNS2 : attrRemove2)(fullname) : (fullname.local ? attrConstantNS2 : attrConstant2)(fullname, i, value));
  }

  // node_modules/d3-transition/src/transition/attrTween.js
  function attrInterpolate(name, i) {
    return function(t) {
      this.setAttribute(name, i.call(this, t));
    };
  }
  function attrInterpolateNS(fullname, i) {
    return function(t) {
      this.setAttributeNS(fullname.space, fullname.local, i.call(this, t));
    };
  }
  function attrTweenNS(fullname, value) {
    var t0, i0;
    function tween() {
      var i = value.apply(this, arguments);
      if (i !== i0)
        t0 = (i0 = i) && attrInterpolateNS(fullname, i);
      return t0;
    }
    tween._value = value;
    return tween;
  }
  function attrTween(name, value) {
    var t0, i0;
    function tween() {
      var i = value.apply(this, arguments);
      if (i !== i0)
        t0 = (i0 = i) && attrInterpolate(name, i);
      return t0;
    }
    tween._value = value;
    return tween;
  }
  function attrTween_default(name, value) {
    var key = "attr." + name;
    if (arguments.length < 2)
      return (key = this.tween(key)) && key._value;
    if (value == null)
      return this.tween(key, null);
    if (typeof value !== "function")
      throw new Error();
    var fullname = namespace_default(name);
    return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
  }

  // node_modules/d3-transition/src/transition/delay.js
  function delayFunction(id2, value) {
    return function() {
      init(this, id2).delay = +value.apply(this, arguments);
    };
  }
  function delayConstant(id2, value) {
    return value = +value, function() {
      init(this, id2).delay = value;
    };
  }
  function delay_default(value) {
    var id2 = this._id;
    return arguments.length ? this.each((typeof value === "function" ? delayFunction : delayConstant)(id2, value)) : get2(this.node(), id2).delay;
  }

  // node_modules/d3-transition/src/transition/duration.js
  function durationFunction(id2, value) {
    return function() {
      set2(this, id2).duration = +value.apply(this, arguments);
    };
  }
  function durationConstant(id2, value) {
    return value = +value, function() {
      set2(this, id2).duration = value;
    };
  }
  function duration_default(value) {
    var id2 = this._id;
    return arguments.length ? this.each((typeof value === "function" ? durationFunction : durationConstant)(id2, value)) : get2(this.node(), id2).duration;
  }

  // node_modules/d3-transition/src/transition/ease.js
  function easeConstant(id2, value) {
    if (typeof value !== "function")
      throw new Error();
    return function() {
      set2(this, id2).ease = value;
    };
  }
  function ease_default(value) {
    var id2 = this._id;
    return arguments.length ? this.each(easeConstant(id2, value)) : get2(this.node(), id2).ease;
  }

  // node_modules/d3-transition/src/transition/easeVarying.js
  function easeVarying(id2, value) {
    return function() {
      var v = value.apply(this, arguments);
      if (typeof v !== "function")
        throw new Error();
      set2(this, id2).ease = v;
    };
  }
  function easeVarying_default(value) {
    if (typeof value !== "function")
      throw new Error();
    return this.each(easeVarying(this._id, value));
  }

  // node_modules/d3-transition/src/transition/filter.js
  function filter_default2(match) {
    if (typeof match !== "function")
      match = matcher_default(match);
    for (var groups = this._groups, m2 = groups.length, subgroups = new Array(m2), j = 0; j < m2; ++j) {
      for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
        if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
          subgroup.push(node);
        }
      }
    }
    return new Transition(subgroups, this._parents, this._name, this._id);
  }

  // node_modules/d3-transition/src/transition/merge.js
  function merge_default2(transition2) {
    if (transition2._id !== this._id)
      throw new Error();
    for (var groups0 = this._groups, groups1 = transition2._groups, m0 = groups0.length, m1 = groups1.length, m2 = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m2; ++j) {
      for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
        if (node = group0[i] || group1[i]) {
          merge[i] = node;
        }
      }
    }
    for (; j < m0; ++j) {
      merges[j] = groups0[j];
    }
    return new Transition(merges, this._parents, this._name, this._id);
  }

  // node_modules/d3-transition/src/transition/on.js
  function start(name) {
    return (name + "").trim().split(/^|\s+/).every(function(t) {
      var i = t.indexOf(".");
      if (i >= 0)
        t = t.slice(0, i);
      return !t || t === "start";
    });
  }
  function onFunction(id2, name, listener) {
    var on0, on1, sit = start(name) ? init : set2;
    return function() {
      var schedule = sit(this, id2), on = schedule.on;
      if (on !== on0)
        (on1 = (on0 = on).copy()).on(name, listener);
      schedule.on = on1;
    };
  }
  function on_default2(name, listener) {
    var id2 = this._id;
    return arguments.length < 2 ? get2(this.node(), id2).on.on(name) : this.each(onFunction(id2, name, listener));
  }

  // node_modules/d3-transition/src/transition/remove.js
  function removeFunction(id2) {
    return function() {
      var parent2 = this.parentNode;
      for (var i in this.__transition)
        if (+i !== id2)
          return;
      if (parent2)
        parent2.removeChild(this);
    };
  }
  function remove_default2() {
    return this.on("end.remove", removeFunction(this._id));
  }

  // node_modules/d3-transition/src/transition/select.js
  function select_default3(select) {
    var name = this._name, id2 = this._id;
    if (typeof select !== "function")
      select = selector_default(select);
    for (var groups = this._groups, m2 = groups.length, subgroups = new Array(m2), j = 0; j < m2; ++j) {
      for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
        if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
          if ("__data__" in node)
            subnode.__data__ = node.__data__;
          subgroup[i] = subnode;
          schedule_default(subgroup[i], name, id2, i, subgroup, get2(node, id2));
        }
      }
    }
    return new Transition(subgroups, this._parents, name, id2);
  }

  // node_modules/d3-transition/src/transition/selectAll.js
  function selectAll_default2(select) {
    var name = this._name, id2 = this._id;
    if (typeof select !== "function")
      select = selectorAll_default(select);
    for (var groups = this._groups, m2 = groups.length, subgroups = [], parents = [], j = 0; j < m2; ++j) {
      for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
        if (node = group[i]) {
          for (var children2 = select.call(node, node.__data__, i, group), child, inherit2 = get2(node, id2), k = 0, l = children2.length; k < l; ++k) {
            if (child = children2[k]) {
              schedule_default(child, name, id2, k, children2, inherit2);
            }
          }
          subgroups.push(children2);
          parents.push(node);
        }
      }
    }
    return new Transition(subgroups, parents, name, id2);
  }

  // node_modules/d3-transition/src/transition/selection.js
  var Selection2 = selection_default.prototype.constructor;
  function selection_default2() {
    return new Selection2(this._groups, this._parents);
  }

  // node_modules/d3-transition/src/transition/style.js
  function styleNull(name, interpolate) {
    var string00, string10, interpolate0;
    return function() {
      var string0 = styleValue(this, name), string1 = (this.style.removeProperty(name), styleValue(this, name));
      return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : interpolate0 = interpolate(string00 = string0, string10 = string1);
    };
  }
  function styleRemove2(name) {
    return function() {
      this.style.removeProperty(name);
    };
  }
  function styleConstant2(name, interpolate, value1) {
    var string00, string1 = value1 + "", interpolate0;
    return function() {
      var string0 = styleValue(this, name);
      return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
    };
  }
  function styleFunction2(name, interpolate, value) {
    var string00, string10, interpolate0;
    return function() {
      var string0 = styleValue(this, name), value1 = value(this), string1 = value1 + "";
      if (value1 == null)
        string1 = value1 = (this.style.removeProperty(name), styleValue(this, name));
      return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
    };
  }
  function styleMaybeRemove(id2, name) {
    var on0, on1, listener0, key = "style." + name, event = "end." + key, remove2;
    return function() {
      var schedule = set2(this, id2), on = schedule.on, listener = schedule.value[key] == null ? remove2 || (remove2 = styleRemove2(name)) : void 0;
      if (on !== on0 || listener0 !== listener)
        (on1 = (on0 = on).copy()).on(event, listener0 = listener);
      schedule.on = on1;
    };
  }
  function style_default2(name, value, priority) {
    var i = (name += "") === "transform" ? interpolateTransformCss : interpolate_default;
    return value == null ? this.styleTween(name, styleNull(name, i)).on("end.style." + name, styleRemove2(name)) : typeof value === "function" ? this.styleTween(name, styleFunction2(name, i, tweenValue(this, "style." + name, value))).each(styleMaybeRemove(this._id, name)) : this.styleTween(name, styleConstant2(name, i, value), priority).on("end.style." + name, null);
  }

  // node_modules/d3-transition/src/transition/styleTween.js
  function styleInterpolate(name, i, priority) {
    return function(t) {
      this.style.setProperty(name, i.call(this, t), priority);
    };
  }
  function styleTween(name, value, priority) {
    var t, i0;
    function tween() {
      var i = value.apply(this, arguments);
      if (i !== i0)
        t = (i0 = i) && styleInterpolate(name, i, priority);
      return t;
    }
    tween._value = value;
    return tween;
  }
  function styleTween_default(name, value, priority) {
    var key = "style." + (name += "");
    if (arguments.length < 2)
      return (key = this.tween(key)) && key._value;
    if (value == null)
      return this.tween(key, null);
    if (typeof value !== "function")
      throw new Error();
    return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
  }

  // node_modules/d3-transition/src/transition/text.js
  function textConstant2(value) {
    return function() {
      this.textContent = value;
    };
  }
  function textFunction2(value) {
    return function() {
      var value1 = value(this);
      this.textContent = value1 == null ? "" : value1;
    };
  }
  function text_default2(value) {
    return this.tween("text", typeof value === "function" ? textFunction2(tweenValue(this, "text", value)) : textConstant2(value == null ? "" : value + ""));
  }

  // node_modules/d3-transition/src/transition/textTween.js
  function textInterpolate(i) {
    return function(t) {
      this.textContent = i.call(this, t);
    };
  }
  function textTween(value) {
    var t0, i0;
    function tween() {
      var i = value.apply(this, arguments);
      if (i !== i0)
        t0 = (i0 = i) && textInterpolate(i);
      return t0;
    }
    tween._value = value;
    return tween;
  }
  function textTween_default(value) {
    var key = "text";
    if (arguments.length < 1)
      return (key = this.tween(key)) && key._value;
    if (value == null)
      return this.tween(key, null);
    if (typeof value !== "function")
      throw new Error();
    return this.tween(key, textTween(value));
  }

  // node_modules/d3-transition/src/transition/transition.js
  function transition_default() {
    var name = this._name, id0 = this._id, id1 = newId();
    for (var groups = this._groups, m2 = groups.length, j = 0; j < m2; ++j) {
      for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
        if (node = group[i]) {
          var inherit2 = get2(node, id0);
          schedule_default(node, name, id1, i, group, {
            time: inherit2.time + inherit2.delay + inherit2.duration,
            delay: 0,
            duration: inherit2.duration,
            ease: inherit2.ease
          });
        }
      }
    }
    return new Transition(groups, this._parents, name, id1);
  }

  // node_modules/d3-transition/src/transition/end.js
  function end_default() {
    var on0, on1, that = this, id2 = that._id, size = that.size();
    return new Promise(function(resolve2, reject) {
      var cancel = { value: reject }, end = { value: function() {
        if (--size === 0)
          resolve2();
      } };
      that.each(function() {
        var schedule = set2(this, id2), on = schedule.on;
        if (on !== on0) {
          on1 = (on0 = on).copy();
          on1._.cancel.push(cancel);
          on1._.interrupt.push(cancel);
          on1._.end.push(end);
        }
        schedule.on = on1;
      });
      if (size === 0)
        resolve2();
    });
  }

  // node_modules/d3-transition/src/transition/index.js
  var id = 0;
  function Transition(groups, parents, name, id2) {
    this._groups = groups;
    this._parents = parents;
    this._name = name;
    this._id = id2;
  }
  function transition(name) {
    return selection_default().transition(name);
  }
  function newId() {
    return ++id;
  }
  var selection_prototype = selection_default.prototype;
  Transition.prototype = transition.prototype = {
    constructor: Transition,
    select: select_default3,
    selectAll: selectAll_default2,
    selectChild: selection_prototype.selectChild,
    selectChildren: selection_prototype.selectChildren,
    filter: filter_default2,
    merge: merge_default2,
    selection: selection_default2,
    transition: transition_default,
    call: selection_prototype.call,
    nodes: selection_prototype.nodes,
    node: selection_prototype.node,
    size: selection_prototype.size,
    empty: selection_prototype.empty,
    each: selection_prototype.each,
    on: on_default2,
    attr: attr_default2,
    attrTween: attrTween_default,
    style: style_default2,
    styleTween: styleTween_default,
    text: text_default2,
    textTween: textTween_default,
    remove: remove_default2,
    tween: tween_default,
    delay: delay_default,
    duration: duration_default,
    ease: ease_default,
    easeVarying: easeVarying_default,
    end: end_default,
    [Symbol.iterator]: selection_prototype[Symbol.iterator]
  };

  // node_modules/d3-ease/src/cubic.js
  function cubicInOut(t) {
    return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
  }

  // node_modules/d3-transition/src/selection/transition.js
  var defaultTiming = {
    time: null,
    delay: 0,
    duration: 250,
    ease: cubicInOut
  };
  function inherit(node, id2) {
    var timing;
    while (!(timing = node.__transition) || !(timing = timing[id2])) {
      if (!(node = node.parentNode)) {
        throw new Error(`transition ${id2} not found`);
      }
    }
    return timing;
  }
  function transition_default2(name) {
    var id2, timing;
    if (name instanceof Transition) {
      id2 = name._id, name = name._name;
    } else {
      id2 = newId(), (timing = defaultTiming).time = now(), name = name == null ? null : name + "";
    }
    for (var groups = this._groups, m2 = groups.length, j = 0; j < m2; ++j) {
      for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
        if (node = group[i]) {
          schedule_default(node, name, id2, i, group, timing || inherit(node, id2));
        }
      }
    }
    return new Transition(groups, this._parents, name, id2);
  }

  // node_modules/d3-transition/src/selection/index.js
  selection_default.prototype.interrupt = interrupt_default2;
  selection_default.prototype.transition = transition_default2;

  // node_modules/d3-brush/src/brush.js
  var { abs, max, min } = Math;
  function number1(e) {
    return [+e[0], +e[1]];
  }
  function number2(e) {
    return [number1(e[0]), number1(e[1])];
  }
  var X = {
    name: "x",
    handles: ["w", "e"].map(type),
    input: function(x3, e) {
      return x3 == null ? null : [[+x3[0], e[0][1]], [+x3[1], e[1][1]]];
    },
    output: function(xy) {
      return xy && [xy[0][0], xy[1][0]];
    }
  };
  var Y = {
    name: "y",
    handles: ["n", "s"].map(type),
    input: function(y3, e) {
      return y3 == null ? null : [[e[0][0], +y3[0]], [e[1][0], +y3[1]]];
    },
    output: function(xy) {
      return xy && [xy[0][1], xy[1][1]];
    }
  };
  var XY = {
    name: "xy",
    handles: ["n", "w", "e", "s", "nw", "ne", "sw", "se"].map(type),
    input: function(xy) {
      return xy == null ? null : number2(xy);
    },
    output: function(xy) {
      return xy;
    }
  };
  function type(t) {
    return { type: t };
  }

  // node_modules/d3-quadtree/src/add.js
  function add_default(d) {
    const x3 = +this._x.call(null, d), y3 = +this._y.call(null, d);
    return add(this.cover(x3, y3), x3, y3, d);
  }
  function add(tree, x3, y3, d) {
    if (isNaN(x3) || isNaN(y3))
      return tree;
    var parent2, node = tree._root, leaf = { data: d }, x0 = tree._x0, y0 = tree._y0, x1 = tree._x1, y1 = tree._y1, xm, ym, xp, yp, right, bottom, i, j;
    if (!node)
      return tree._root = leaf, tree;
    while (node.length) {
      if (right = x3 >= (xm = (x0 + x1) / 2))
        x0 = xm;
      else
        x1 = xm;
      if (bottom = y3 >= (ym = (y0 + y1) / 2))
        y0 = ym;
      else
        y1 = ym;
      if (parent2 = node, !(node = node[i = bottom << 1 | right]))
        return parent2[i] = leaf, tree;
    }
    xp = +tree._x.call(null, node.data);
    yp = +tree._y.call(null, node.data);
    if (x3 === xp && y3 === yp)
      return leaf.next = node, parent2 ? parent2[i] = leaf : tree._root = leaf, tree;
    do {
      parent2 = parent2 ? parent2[i] = new Array(4) : tree._root = new Array(4);
      if (right = x3 >= (xm = (x0 + x1) / 2))
        x0 = xm;
      else
        x1 = xm;
      if (bottom = y3 >= (ym = (y0 + y1) / 2))
        y0 = ym;
      else
        y1 = ym;
    } while ((i = bottom << 1 | right) === (j = (yp >= ym) << 1 | xp >= xm));
    return parent2[j] = node, parent2[i] = leaf, tree;
  }
  function addAll(data) {
    var d, i, n = data.length, x3, y3, xz = new Array(n), yz = new Array(n), x0 = Infinity, y0 = Infinity, x1 = -Infinity, y1 = -Infinity;
    for (i = 0; i < n; ++i) {
      if (isNaN(x3 = +this._x.call(null, d = data[i])) || isNaN(y3 = +this._y.call(null, d)))
        continue;
      xz[i] = x3;
      yz[i] = y3;
      if (x3 < x0)
        x0 = x3;
      if (x3 > x1)
        x1 = x3;
      if (y3 < y0)
        y0 = y3;
      if (y3 > y1)
        y1 = y3;
    }
    if (x0 > x1 || y0 > y1)
      return this;
    this.cover(x0, y0).cover(x1, y1);
    for (i = 0; i < n; ++i) {
      add(this, xz[i], yz[i], data[i]);
    }
    return this;
  }

  // node_modules/d3-quadtree/src/cover.js
  function cover_default(x3, y3) {
    if (isNaN(x3 = +x3) || isNaN(y3 = +y3))
      return this;
    var x0 = this._x0, y0 = this._y0, x1 = this._x1, y1 = this._y1;
    if (isNaN(x0)) {
      x1 = (x0 = Math.floor(x3)) + 1;
      y1 = (y0 = Math.floor(y3)) + 1;
    } else {
      var z = x1 - x0 || 1, node = this._root, parent2, i;
      while (x0 > x3 || x3 >= x1 || y0 > y3 || y3 >= y1) {
        i = (y3 < y0) << 1 | x3 < x0;
        parent2 = new Array(4), parent2[i] = node, node = parent2, z *= 2;
        switch (i) {
          case 0:
            x1 = x0 + z, y1 = y0 + z;
            break;
          case 1:
            x0 = x1 - z, y1 = y0 + z;
            break;
          case 2:
            x1 = x0 + z, y0 = y1 - z;
            break;
          case 3:
            x0 = x1 - z, y0 = y1 - z;
            break;
        }
      }
      if (this._root && this._root.length)
        this._root = node;
    }
    this._x0 = x0;
    this._y0 = y0;
    this._x1 = x1;
    this._y1 = y1;
    return this;
  }

  // node_modules/d3-quadtree/src/data.js
  function data_default2() {
    var data = [];
    this.visit(function(node) {
      if (!node.length)
        do
          data.push(node.data);
        while (node = node.next);
    });
    return data;
  }

  // node_modules/d3-quadtree/src/extent.js
  function extent_default(_2) {
    return arguments.length ? this.cover(+_2[0][0], +_2[0][1]).cover(+_2[1][0], +_2[1][1]) : isNaN(this._x0) ? void 0 : [[this._x0, this._y0], [this._x1, this._y1]];
  }

  // node_modules/d3-quadtree/src/quad.js
  function quad_default(node, x0, y0, x1, y1) {
    this.node = node;
    this.x0 = x0;
    this.y0 = y0;
    this.x1 = x1;
    this.y1 = y1;
  }

  // node_modules/d3-quadtree/src/find.js
  function find_default(x3, y3, radius) {
    var data, x0 = this._x0, y0 = this._y0, x1, y1, x22, y22, x32 = this._x1, y32 = this._y1, quads = [], node = this._root, q, i;
    if (node)
      quads.push(new quad_default(node, x0, y0, x32, y32));
    if (radius == null)
      radius = Infinity;
    else {
      x0 = x3 - radius, y0 = y3 - radius;
      x32 = x3 + radius, y32 = y3 + radius;
      radius *= radius;
    }
    while (q = quads.pop()) {
      if (!(node = q.node) || (x1 = q.x0) > x32 || (y1 = q.y0) > y32 || (x22 = q.x1) < x0 || (y22 = q.y1) < y0)
        continue;
      if (node.length) {
        var xm = (x1 + x22) / 2, ym = (y1 + y22) / 2;
        quads.push(
          new quad_default(node[3], xm, ym, x22, y22),
          new quad_default(node[2], x1, ym, xm, y22),
          new quad_default(node[1], xm, y1, x22, ym),
          new quad_default(node[0], x1, y1, xm, ym)
        );
        if (i = (y3 >= ym) << 1 | x3 >= xm) {
          q = quads[quads.length - 1];
          quads[quads.length - 1] = quads[quads.length - 1 - i];
          quads[quads.length - 1 - i] = q;
        }
      } else {
        var dx = x3 - +this._x.call(null, node.data), dy = y3 - +this._y.call(null, node.data), d2 = dx * dx + dy * dy;
        if (d2 < radius) {
          var d = Math.sqrt(radius = d2);
          x0 = x3 - d, y0 = y3 - d;
          x32 = x3 + d, y32 = y3 + d;
          data = node.data;
        }
      }
    }
    return data;
  }

  // node_modules/d3-quadtree/src/remove.js
  function remove_default3(d) {
    if (isNaN(x3 = +this._x.call(null, d)) || isNaN(y3 = +this._y.call(null, d)))
      return this;
    var parent2, node = this._root, retainer, previous, next, x0 = this._x0, y0 = this._y0, x1 = this._x1, y1 = this._y1, x3, y3, xm, ym, right, bottom, i, j;
    if (!node)
      return this;
    if (node.length)
      while (true) {
        if (right = x3 >= (xm = (x0 + x1) / 2))
          x0 = xm;
        else
          x1 = xm;
        if (bottom = y3 >= (ym = (y0 + y1) / 2))
          y0 = ym;
        else
          y1 = ym;
        if (!(parent2 = node, node = node[i = bottom << 1 | right]))
          return this;
        if (!node.length)
          break;
        if (parent2[i + 1 & 3] || parent2[i + 2 & 3] || parent2[i + 3 & 3])
          retainer = parent2, j = i;
      }
    while (node.data !== d)
      if (!(previous = node, node = node.next))
        return this;
    if (next = node.next)
      delete node.next;
    if (previous)
      return next ? previous.next = next : delete previous.next, this;
    if (!parent2)
      return this._root = next, this;
    next ? parent2[i] = next : delete parent2[i];
    if ((node = parent2[0] || parent2[1] || parent2[2] || parent2[3]) && node === (parent2[3] || parent2[2] || parent2[1] || parent2[0]) && !node.length) {
      if (retainer)
        retainer[j] = node;
      else
        this._root = node;
    }
    return this;
  }
  function removeAll(data) {
    for (var i = 0, n = data.length; i < n; ++i)
      this.remove(data[i]);
    return this;
  }

  // node_modules/d3-quadtree/src/root.js
  function root_default() {
    return this._root;
  }

  // node_modules/d3-quadtree/src/size.js
  function size_default2() {
    var size = 0;
    this.visit(function(node) {
      if (!node.length)
        do
          ++size;
        while (node = node.next);
    });
    return size;
  }

  // node_modules/d3-quadtree/src/visit.js
  function visit_default(callback) {
    var quads = [], q, node = this._root, child, x0, y0, x1, y1;
    if (node)
      quads.push(new quad_default(node, this._x0, this._y0, this._x1, this._y1));
    while (q = quads.pop()) {
      if (!callback(node = q.node, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1) && node.length) {
        var xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
        if (child = node[3])
          quads.push(new quad_default(child, xm, ym, x1, y1));
        if (child = node[2])
          quads.push(new quad_default(child, x0, ym, xm, y1));
        if (child = node[1])
          quads.push(new quad_default(child, xm, y0, x1, ym));
        if (child = node[0])
          quads.push(new quad_default(child, x0, y0, xm, ym));
      }
    }
    return this;
  }

  // node_modules/d3-quadtree/src/visitAfter.js
  function visitAfter_default(callback) {
    var quads = [], next = [], q;
    if (this._root)
      quads.push(new quad_default(this._root, this._x0, this._y0, this._x1, this._y1));
    while (q = quads.pop()) {
      var node = q.node;
      if (node.length) {
        var child, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1, xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
        if (child = node[0])
          quads.push(new quad_default(child, x0, y0, xm, ym));
        if (child = node[1])
          quads.push(new quad_default(child, xm, y0, x1, ym));
        if (child = node[2])
          quads.push(new quad_default(child, x0, ym, xm, y1));
        if (child = node[3])
          quads.push(new quad_default(child, xm, ym, x1, y1));
      }
      next.push(q);
    }
    while (q = next.pop()) {
      callback(q.node, q.x0, q.y0, q.x1, q.y1);
    }
    return this;
  }

  // node_modules/d3-quadtree/src/x.js
  function defaultX(d) {
    return d[0];
  }
  function x_default(_2) {
    return arguments.length ? (this._x = _2, this) : this._x;
  }

  // node_modules/d3-quadtree/src/y.js
  function defaultY(d) {
    return d[1];
  }
  function y_default(_2) {
    return arguments.length ? (this._y = _2, this) : this._y;
  }

  // node_modules/d3-quadtree/src/quadtree.js
  function quadtree(nodes, x3, y3) {
    var tree = new Quadtree(x3 == null ? defaultX : x3, y3 == null ? defaultY : y3, NaN, NaN, NaN, NaN);
    return nodes == null ? tree : tree.addAll(nodes);
  }
  function Quadtree(x3, y3, x0, y0, x1, y1) {
    this._x = x3;
    this._y = y3;
    this._x0 = x0;
    this._y0 = y0;
    this._x1 = x1;
    this._y1 = y1;
    this._root = void 0;
  }
  function leaf_copy(leaf) {
    var copy = { data: leaf.data }, next = copy;
    while (leaf = leaf.next)
      next = next.next = { data: leaf.data };
    return copy;
  }
  var treeProto = quadtree.prototype = Quadtree.prototype;
  treeProto.copy = function() {
    var copy = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1), node = this._root, nodes, child;
    if (!node)
      return copy;
    if (!node.length)
      return copy._root = leaf_copy(node), copy;
    nodes = [{ source: node, target: copy._root = new Array(4) }];
    while (node = nodes.pop()) {
      for (var i = 0; i < 4; ++i) {
        if (child = node.source[i]) {
          if (child.length)
            nodes.push({ source: child, target: node.target[i] = new Array(4) });
          else
            node.target[i] = leaf_copy(child);
        }
      }
    }
    return copy;
  };
  treeProto.add = add_default;
  treeProto.addAll = addAll;
  treeProto.cover = cover_default;
  treeProto.data = data_default2;
  treeProto.extent = extent_default;
  treeProto.find = find_default;
  treeProto.remove = remove_default3;
  treeProto.removeAll = removeAll;
  treeProto.root = root_default;
  treeProto.size = size_default2;
  treeProto.visit = visit_default;
  treeProto.visitAfter = visitAfter_default;
  treeProto.x = x_default;
  treeProto.y = y_default;

  // node_modules/d3-force/src/constant.js
  function constant_default5(x3) {
    return function() {
      return x3;
    };
  }

  // node_modules/d3-force/src/jiggle.js
  function jiggle_default(random) {
    return (random() - 0.5) * 1e-6;
  }

  // node_modules/d3-force/src/collide.js
  function x(d) {
    return d.x + d.vx;
  }
  function y(d) {
    return d.y + d.vy;
  }
  function collide_default(radius) {
    var nodes, radii, random, strength = 1, iterations = 1;
    if (typeof radius !== "function")
      radius = constant_default5(radius == null ? 1 : +radius);
    function force() {
      var i, n = nodes.length, tree, node, xi, yi, ri, ri2;
      for (var k = 0; k < iterations; ++k) {
        tree = quadtree(nodes, x, y).visitAfter(prepare);
        for (i = 0; i < n; ++i) {
          node = nodes[i];
          ri = radii[node.index], ri2 = ri * ri;
          xi = node.x + node.vx;
          yi = node.y + node.vy;
          tree.visit(apply);
        }
      }
      function apply(quad, x0, y0, x1, y1) {
        var data = quad.data, rj = quad.r, r = ri + rj;
        if (data) {
          if (data.index > node.index) {
            var x3 = xi - data.x - data.vx, y3 = yi - data.y - data.vy, l = x3 * x3 + y3 * y3;
            if (l < r * r) {
              if (x3 === 0)
                x3 = jiggle_default(random), l += x3 * x3;
              if (y3 === 0)
                y3 = jiggle_default(random), l += y3 * y3;
              l = (r - (l = Math.sqrt(l))) / l * strength;
              node.vx += (x3 *= l) * (r = (rj *= rj) / (ri2 + rj));
              node.vy += (y3 *= l) * r;
              data.vx -= x3 * (r = 1 - r);
              data.vy -= y3 * r;
            }
          }
          return;
        }
        return x0 > xi + r || x1 < xi - r || y0 > yi + r || y1 < yi - r;
      }
    }
    function prepare(quad) {
      if (quad.data)
        return quad.r = radii[quad.data.index];
      for (var i = quad.r = 0; i < 4; ++i) {
        if (quad[i] && quad[i].r > quad.r) {
          quad.r = quad[i].r;
        }
      }
    }
    function initialize() {
      if (!nodes)
        return;
      var i, n = nodes.length, node;
      radii = new Array(n);
      for (i = 0; i < n; ++i)
        node = nodes[i], radii[node.index] = +radius(node, i, nodes);
    }
    force.initialize = function(_nodes, _random) {
      nodes = _nodes;
      random = _random;
      initialize();
    };
    force.iterations = function(_2) {
      return arguments.length ? (iterations = +_2, force) : iterations;
    };
    force.strength = function(_2) {
      return arguments.length ? (strength = +_2, force) : strength;
    };
    force.radius = function(_2) {
      return arguments.length ? (radius = typeof _2 === "function" ? _2 : constant_default5(+_2), initialize(), force) : radius;
    };
    return force;
  }

  // node_modules/d3-force/src/link.js
  function index(d) {
    return d.index;
  }
  function find2(nodeById, nodeId) {
    var node = nodeById.get(nodeId);
    if (!node)
      throw new Error("node not found: " + nodeId);
    return node;
  }
  function link_default(links) {
    var id2 = index, strength = defaultStrength, strengths, distance = constant_default5(30), distances, nodes, count, bias, random, iterations = 1;
    if (links == null)
      links = [];
    function defaultStrength(link) {
      return 1 / Math.min(count[link.source.index], count[link.target.index]);
    }
    function force(alpha) {
      for (var k = 0, n = links.length; k < iterations; ++k) {
        for (var i = 0, link, source, target, x3, y3, l, b; i < n; ++i) {
          link = links[i], source = link.source, target = link.target;
          x3 = target.x + target.vx - source.x - source.vx || jiggle_default(random);
          y3 = target.y + target.vy - source.y - source.vy || jiggle_default(random);
          l = Math.sqrt(x3 * x3 + y3 * y3);
          l = (l - distances[i]) / l * alpha * strengths[i];
          x3 *= l, y3 *= l;
          target.vx -= x3 * (b = bias[i]);
          target.vy -= y3 * b;
          source.vx += x3 * (b = 1 - b);
          source.vy += y3 * b;
        }
      }
    }
    function initialize() {
      if (!nodes)
        return;
      var i, n = nodes.length, m2 = links.length, nodeById = new Map(nodes.map((d, i2) => [id2(d, i2, nodes), d])), link;
      for (i = 0, count = new Array(n); i < m2; ++i) {
        link = links[i], link.index = i;
        if (typeof link.source !== "object")
          link.source = find2(nodeById, link.source);
        if (typeof link.target !== "object")
          link.target = find2(nodeById, link.target);
        count[link.source.index] = (count[link.source.index] || 0) + 1;
        count[link.target.index] = (count[link.target.index] || 0) + 1;
      }
      for (i = 0, bias = new Array(m2); i < m2; ++i) {
        link = links[i], bias[i] = count[link.source.index] / (count[link.source.index] + count[link.target.index]);
      }
      strengths = new Array(m2), initializeStrength();
      distances = new Array(m2), initializeDistance();
    }
    function initializeStrength() {
      if (!nodes)
        return;
      for (var i = 0, n = links.length; i < n; ++i) {
        strengths[i] = +strength(links[i], i, links);
      }
    }
    function initializeDistance() {
      if (!nodes)
        return;
      for (var i = 0, n = links.length; i < n; ++i) {
        distances[i] = +distance(links[i], i, links);
      }
    }
    force.initialize = function(_nodes, _random) {
      nodes = _nodes;
      random = _random;
      initialize();
    };
    force.links = function(_2) {
      return arguments.length ? (links = _2, initialize(), force) : links;
    };
    force.id = function(_2) {
      return arguments.length ? (id2 = _2, force) : id2;
    };
    force.iterations = function(_2) {
      return arguments.length ? (iterations = +_2, force) : iterations;
    };
    force.strength = function(_2) {
      return arguments.length ? (strength = typeof _2 === "function" ? _2 : constant_default5(+_2), initializeStrength(), force) : strength;
    };
    force.distance = function(_2) {
      return arguments.length ? (distance = typeof _2 === "function" ? _2 : constant_default5(+_2), initializeDistance(), force) : distance;
    };
    return force;
  }

  // node_modules/d3-force/src/lcg.js
  var a = 1664525;
  var c = 1013904223;
  var m = 4294967296;
  function lcg_default() {
    let s = 1;
    return () => (s = (a * s + c) % m) / m;
  }

  // node_modules/d3-force/src/simulation.js
  function x2(d) {
    return d.x;
  }
  function y2(d) {
    return d.y;
  }
  var initialRadius = 10;
  var initialAngle = Math.PI * (3 - Math.sqrt(5));
  function simulation_default(nodes) {
    var simulation, alpha = 1, alphaMin = 1e-3, alphaDecay = 1 - Math.pow(alphaMin, 1 / 300), alphaTarget = 0, velocityDecay = 0.6, forces = /* @__PURE__ */ new Map(), stepper = timer(step), event = dispatch_default("tick", "end"), random = lcg_default();
    if (nodes == null)
      nodes = [];
    function step() {
      tick();
      event.call("tick", simulation);
      if (alpha < alphaMin) {
        stepper.stop();
        event.call("end", simulation);
      }
    }
    function tick(iterations) {
      var i, n = nodes.length, node;
      if (iterations === void 0)
        iterations = 1;
      for (var k = 0; k < iterations; ++k) {
        alpha += (alphaTarget - alpha) * alphaDecay;
        forces.forEach(function(force) {
          force(alpha);
        });
        for (i = 0; i < n; ++i) {
          node = nodes[i];
          if (node.fx == null)
            node.x += node.vx *= velocityDecay;
          else
            node.x = node.fx, node.vx = 0;
          if (node.fy == null)
            node.y += node.vy *= velocityDecay;
          else
            node.y = node.fy, node.vy = 0;
        }
      }
      return simulation;
    }
    function initializeNodes() {
      for (var i = 0, n = nodes.length, node; i < n; ++i) {
        node = nodes[i], node.index = i;
        if (node.fx != null)
          node.x = node.fx;
        if (node.fy != null)
          node.y = node.fy;
        if (isNaN(node.x) || isNaN(node.y)) {
          var radius = initialRadius * Math.sqrt(0.5 + i), angle = i * initialAngle;
          node.x = radius * Math.cos(angle);
          node.y = radius * Math.sin(angle);
        }
        if (isNaN(node.vx) || isNaN(node.vy)) {
          node.vx = node.vy = 0;
        }
      }
    }
    function initializeForce(force) {
      if (force.initialize)
        force.initialize(nodes, random);
      return force;
    }
    initializeNodes();
    return simulation = {
      tick,
      restart: function() {
        return stepper.restart(step), simulation;
      },
      stop: function() {
        return stepper.stop(), simulation;
      },
      nodes: function(_2) {
        return arguments.length ? (nodes = _2, initializeNodes(), forces.forEach(initializeForce), simulation) : nodes;
      },
      alpha: function(_2) {
        return arguments.length ? (alpha = +_2, simulation) : alpha;
      },
      alphaMin: function(_2) {
        return arguments.length ? (alphaMin = +_2, simulation) : alphaMin;
      },
      alphaDecay: function(_2) {
        return arguments.length ? (alphaDecay = +_2, simulation) : +alphaDecay;
      },
      alphaTarget: function(_2) {
        return arguments.length ? (alphaTarget = +_2, simulation) : alphaTarget;
      },
      velocityDecay: function(_2) {
        return arguments.length ? (velocityDecay = 1 - _2, simulation) : 1 - velocityDecay;
      },
      randomSource: function(_2) {
        return arguments.length ? (random = _2, forces.forEach(initializeForce), simulation) : random;
      },
      force: function(name, _2) {
        return arguments.length > 1 ? (_2 == null ? forces.delete(name) : forces.set(name, initializeForce(_2)), simulation) : forces.get(name);
      },
      find: function(x3, y3, radius) {
        var i = 0, n = nodes.length, dx, dy, d2, node, closest;
        if (radius == null)
          radius = Infinity;
        else
          radius *= radius;
        for (i = 0; i < n; ++i) {
          node = nodes[i];
          dx = x3 - node.x;
          dy = y3 - node.y;
          d2 = dx * dx + dy * dy;
          if (d2 < radius)
            closest = node, radius = d2;
        }
        return closest;
      },
      on: function(name, _2) {
        return arguments.length > 1 ? (event.on(name, _2), simulation) : event.on(name);
      }
    };
  }

  // node_modules/d3-force/src/manyBody.js
  function manyBody_default() {
    var nodes, node, random, alpha, strength = constant_default5(-30), strengths, distanceMin2 = 1, distanceMax2 = Infinity, theta2 = 0.81;
    function force(_2) {
      var i, n = nodes.length, tree = quadtree(nodes, x2, y2).visitAfter(accumulate);
      for (alpha = _2, i = 0; i < n; ++i)
        node = nodes[i], tree.visit(apply);
    }
    function initialize() {
      if (!nodes)
        return;
      var i, n = nodes.length, node2;
      strengths = new Array(n);
      for (i = 0; i < n; ++i)
        node2 = nodes[i], strengths[node2.index] = +strength(node2, i, nodes);
    }
    function accumulate(quad) {
      var strength2 = 0, q, c2, weight = 0, x3, y3, i;
      if (quad.length) {
        for (x3 = y3 = i = 0; i < 4; ++i) {
          if ((q = quad[i]) && (c2 = Math.abs(q.value))) {
            strength2 += q.value, weight += c2, x3 += c2 * q.x, y3 += c2 * q.y;
          }
        }
        quad.x = x3 / weight;
        quad.y = y3 / weight;
      } else {
        q = quad;
        q.x = q.data.x;
        q.y = q.data.y;
        do
          strength2 += strengths[q.data.index];
        while (q = q.next);
      }
      quad.value = strength2;
    }
    function apply(quad, x1, _2, x22) {
      if (!quad.value)
        return true;
      var x3 = quad.x - node.x, y3 = quad.y - node.y, w = x22 - x1, l = x3 * x3 + y3 * y3;
      if (w * w / theta2 < l) {
        if (l < distanceMax2) {
          if (x3 === 0)
            x3 = jiggle_default(random), l += x3 * x3;
          if (y3 === 0)
            y3 = jiggle_default(random), l += y3 * y3;
          if (l < distanceMin2)
            l = Math.sqrt(distanceMin2 * l);
          node.vx += x3 * quad.value * alpha / l;
          node.vy += y3 * quad.value * alpha / l;
        }
        return true;
      } else if (quad.length || l >= distanceMax2)
        return;
      if (quad.data !== node || quad.next) {
        if (x3 === 0)
          x3 = jiggle_default(random), l += x3 * x3;
        if (y3 === 0)
          y3 = jiggle_default(random), l += y3 * y3;
        if (l < distanceMin2)
          l = Math.sqrt(distanceMin2 * l);
      }
      do
        if (quad.data !== node) {
          w = strengths[quad.data.index] * alpha / l;
          node.vx += x3 * w;
          node.vy += y3 * w;
        }
      while (quad = quad.next);
    }
    force.initialize = function(_nodes, _random) {
      nodes = _nodes;
      random = _random;
      initialize();
    };
    force.strength = function(_2) {
      return arguments.length ? (strength = typeof _2 === "function" ? _2 : constant_default5(+_2), initialize(), force) : strength;
    };
    force.distanceMin = function(_2) {
      return arguments.length ? (distanceMin2 = _2 * _2, force) : Math.sqrt(distanceMin2);
    };
    force.distanceMax = function(_2) {
      return arguments.length ? (distanceMax2 = _2 * _2, force) : Math.sqrt(distanceMax2);
    };
    force.theta = function(_2) {
      return arguments.length ? (theta2 = _2 * _2, force) : Math.sqrt(theta2);
    };
    return force;
  }

  // node_modules/d3-force/src/radial.js
  function radial_default(radius, x3, y3) {
    var nodes, strength = constant_default5(0.1), strengths, radiuses;
    if (typeof radius !== "function")
      radius = constant_default5(+radius);
    if (x3 == null)
      x3 = 0;
    if (y3 == null)
      y3 = 0;
    function force(alpha) {
      for (var i = 0, n = nodes.length; i < n; ++i) {
        var node = nodes[i], dx = node.x - x3 || 1e-6, dy = node.y - y3 || 1e-6, r = Math.sqrt(dx * dx + dy * dy), k = (radiuses[i] - r) * strengths[i] * alpha / r;
        node.vx += dx * k;
        node.vy += dy * k;
      }
    }
    function initialize() {
      if (!nodes)
        return;
      var i, n = nodes.length;
      strengths = new Array(n);
      radiuses = new Array(n);
      for (i = 0; i < n; ++i) {
        radiuses[i] = +radius(nodes[i], i, nodes);
        strengths[i] = isNaN(radiuses[i]) ? 0 : +strength(nodes[i], i, nodes);
      }
    }
    force.initialize = function(_2) {
      nodes = _2, initialize();
    };
    force.strength = function(_2) {
      return arguments.length ? (strength = typeof _2 === "function" ? _2 : constant_default5(+_2), initialize(), force) : strength;
    };
    force.radius = function(_2) {
      return arguments.length ? (radius = typeof _2 === "function" ? _2 : constant_default5(+_2), initialize(), force) : radius;
    };
    force.x = function(_2) {
      return arguments.length ? (x3 = +_2, force) : x3;
    };
    force.y = function(_2) {
      return arguments.length ? (y3 = +_2, force) : y3;
    };
    return force;
  }

  // node_modules/d3-force/src/x.js
  function x_default2(x3) {
    var strength = constant_default5(0.1), nodes, strengths, xz;
    if (typeof x3 !== "function")
      x3 = constant_default5(x3 == null ? 0 : +x3);
    function force(alpha) {
      for (var i = 0, n = nodes.length, node; i < n; ++i) {
        node = nodes[i], node.vx += (xz[i] - node.x) * strengths[i] * alpha;
      }
    }
    function initialize() {
      if (!nodes)
        return;
      var i, n = nodes.length;
      strengths = new Array(n);
      xz = new Array(n);
      for (i = 0; i < n; ++i) {
        strengths[i] = isNaN(xz[i] = +x3(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
      }
    }
    force.initialize = function(_2) {
      nodes = _2;
      initialize();
    };
    force.strength = function(_2) {
      return arguments.length ? (strength = typeof _2 === "function" ? _2 : constant_default5(+_2), initialize(), force) : strength;
    };
    force.x = function(_2) {
      return arguments.length ? (x3 = typeof _2 === "function" ? _2 : constant_default5(+_2), initialize(), force) : x3;
    };
    return force;
  }

  // node_modules/d3-force/src/y.js
  function y_default2(y3) {
    var strength = constant_default5(0.1), nodes, strengths, yz;
    if (typeof y3 !== "function")
      y3 = constant_default5(y3 == null ? 0 : +y3);
    function force(alpha) {
      for (var i = 0, n = nodes.length, node; i < n; ++i) {
        node = nodes[i], node.vy += (yz[i] - node.y) * strengths[i] * alpha;
      }
    }
    function initialize() {
      if (!nodes)
        return;
      var i, n = nodes.length;
      strengths = new Array(n);
      yz = new Array(n);
      for (i = 0; i < n; ++i) {
        strengths[i] = isNaN(yz[i] = +y3(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
      }
    }
    force.initialize = function(_2) {
      nodes = _2;
      initialize();
    };
    force.strength = function(_2) {
      return arguments.length ? (strength = typeof _2 === "function" ? _2 : constant_default5(+_2), initialize(), force) : strength;
    };
    force.y = function(_2) {
      return arguments.length ? (y3 = typeof _2 === "function" ? _2 : constant_default5(+_2), initialize(), force) : y3;
    };
    return force;
  }

  // node_modules/d3-zoom/src/transform.js
  function Transform(k, x3, y3) {
    this.k = k;
    this.x = x3;
    this.y = y3;
  }
  Transform.prototype = {
    constructor: Transform,
    scale: function(k) {
      return k === 1 ? this : new Transform(this.k * k, this.x, this.y);
    },
    translate: function(x3, y3) {
      return x3 === 0 & y3 === 0 ? this : new Transform(this.k, this.x + this.k * x3, this.y + this.k * y3);
    },
    apply: function(point) {
      return [point[0] * this.k + this.x, point[1] * this.k + this.y];
    },
    applyX: function(x3) {
      return x3 * this.k + this.x;
    },
    applyY: function(y3) {
      return y3 * this.k + this.y;
    },
    invert: function(location) {
      return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
    },
    invertX: function(x3) {
      return (x3 - this.x) / this.k;
    },
    invertY: function(y3) {
      return (y3 - this.y) / this.k;
    },
    rescaleX: function(x3) {
      return x3.copy().domain(x3.range().map(this.invertX, this).map(x3.invert, x3));
    },
    rescaleY: function(y3) {
      return y3.copy().domain(y3.range().map(this.invertY, this).map(y3.invert, y3));
    },
    toString: function() {
      return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
    }
  };
  var identity2 = new Transform(1, 0, 0);
  transform.prototype = Transform.prototype;
  function transform(node) {
    while (!node.__zoom)
      if (!(node = node.parentNode))
        return identity2;
    return node.__zoom;
  }

  // node_modules/pixijs/constants/index.mjs
  var ENV = /* @__PURE__ */ ((ENV2) => {
    ENV2[ENV2["WEBGL_LEGACY"] = 0] = "WEBGL_LEGACY";
    ENV2[ENV2["WEBGL"] = 1] = "WEBGL";
    ENV2[ENV2["WEBGL2"] = 2] = "WEBGL2";
    return ENV2;
  })(ENV || {});
  var BUFFER_BITS = /* @__PURE__ */ ((BUFFER_BITS2) => {
    BUFFER_BITS2[BUFFER_BITS2["COLOR"] = 16384] = "COLOR";
    BUFFER_BITS2[BUFFER_BITS2["DEPTH"] = 256] = "DEPTH";
    BUFFER_BITS2[BUFFER_BITS2["STENCIL"] = 1024] = "STENCIL";
    return BUFFER_BITS2;
  })(BUFFER_BITS || {});
  var BLEND_MODES = /* @__PURE__ */ ((BLEND_MODES2) => {
    BLEND_MODES2[BLEND_MODES2["NORMAL"] = 0] = "NORMAL";
    BLEND_MODES2[BLEND_MODES2["ADD"] = 1] = "ADD";
    BLEND_MODES2[BLEND_MODES2["MULTIPLY"] = 2] = "MULTIPLY";
    BLEND_MODES2[BLEND_MODES2["SCREEN"] = 3] = "SCREEN";
    BLEND_MODES2[BLEND_MODES2["OVERLAY"] = 4] = "OVERLAY";
    BLEND_MODES2[BLEND_MODES2["DARKEN"] = 5] = "DARKEN";
    BLEND_MODES2[BLEND_MODES2["LIGHTEN"] = 6] = "LIGHTEN";
    BLEND_MODES2[BLEND_MODES2["COLOR_DODGE"] = 7] = "COLOR_DODGE";
    BLEND_MODES2[BLEND_MODES2["COLOR_BURN"] = 8] = "COLOR_BURN";
    BLEND_MODES2[BLEND_MODES2["HARD_LIGHT"] = 9] = "HARD_LIGHT";
    BLEND_MODES2[BLEND_MODES2["SOFT_LIGHT"] = 10] = "SOFT_LIGHT";
    BLEND_MODES2[BLEND_MODES2["DIFFERENCE"] = 11] = "DIFFERENCE";
    BLEND_MODES2[BLEND_MODES2["EXCLUSION"] = 12] = "EXCLUSION";
    BLEND_MODES2[BLEND_MODES2["HUE"] = 13] = "HUE";
    BLEND_MODES2[BLEND_MODES2["SATURATION"] = 14] = "SATURATION";
    BLEND_MODES2[BLEND_MODES2["COLOR"] = 15] = "COLOR";
    BLEND_MODES2[BLEND_MODES2["LUMINOSITY"] = 16] = "LUMINOSITY";
    BLEND_MODES2[BLEND_MODES2["NORMAL_NPM"] = 17] = "NORMAL_NPM";
    BLEND_MODES2[BLEND_MODES2["ADD_NPM"] = 18] = "ADD_NPM";
    BLEND_MODES2[BLEND_MODES2["SCREEN_NPM"] = 19] = "SCREEN_NPM";
    BLEND_MODES2[BLEND_MODES2["NONE"] = 20] = "NONE";
    BLEND_MODES2[BLEND_MODES2["SRC_OVER"] = 0] = "SRC_OVER";
    BLEND_MODES2[BLEND_MODES2["SRC_IN"] = 21] = "SRC_IN";
    BLEND_MODES2[BLEND_MODES2["SRC_OUT"] = 22] = "SRC_OUT";
    BLEND_MODES2[BLEND_MODES2["SRC_ATOP"] = 23] = "SRC_ATOP";
    BLEND_MODES2[BLEND_MODES2["DST_OVER"] = 24] = "DST_OVER";
    BLEND_MODES2[BLEND_MODES2["DST_IN"] = 25] = "DST_IN";
    BLEND_MODES2[BLEND_MODES2["DST_OUT"] = 26] = "DST_OUT";
    BLEND_MODES2[BLEND_MODES2["DST_ATOP"] = 27] = "DST_ATOP";
    BLEND_MODES2[BLEND_MODES2["ERASE"] = 26] = "ERASE";
    BLEND_MODES2[BLEND_MODES2["SUBTRACT"] = 28] = "SUBTRACT";
    BLEND_MODES2[BLEND_MODES2["XOR"] = 29] = "XOR";
    return BLEND_MODES2;
  })(BLEND_MODES || {});
  var DRAW_MODES = /* @__PURE__ */ ((DRAW_MODES2) => {
    DRAW_MODES2[DRAW_MODES2["POINTS"] = 0] = "POINTS";
    DRAW_MODES2[DRAW_MODES2["LINES"] = 1] = "LINES";
    DRAW_MODES2[DRAW_MODES2["LINE_LOOP"] = 2] = "LINE_LOOP";
    DRAW_MODES2[DRAW_MODES2["LINE_STRIP"] = 3] = "LINE_STRIP";
    DRAW_MODES2[DRAW_MODES2["TRIANGLES"] = 4] = "TRIANGLES";
    DRAW_MODES2[DRAW_MODES2["TRIANGLE_STRIP"] = 5] = "TRIANGLE_STRIP";
    DRAW_MODES2[DRAW_MODES2["TRIANGLE_FAN"] = 6] = "TRIANGLE_FAN";
    return DRAW_MODES2;
  })(DRAW_MODES || {});
  var FORMATS = /* @__PURE__ */ ((FORMATS2) => {
    FORMATS2[FORMATS2["RGBA"] = 6408] = "RGBA";
    FORMATS2[FORMATS2["RGB"] = 6407] = "RGB";
    FORMATS2[FORMATS2["RG"] = 33319] = "RG";
    FORMATS2[FORMATS2["RED"] = 6403] = "RED";
    FORMATS2[FORMATS2["RGBA_INTEGER"] = 36249] = "RGBA_INTEGER";
    FORMATS2[FORMATS2["RGB_INTEGER"] = 36248] = "RGB_INTEGER";
    FORMATS2[FORMATS2["RG_INTEGER"] = 33320] = "RG_INTEGER";
    FORMATS2[FORMATS2["RED_INTEGER"] = 36244] = "RED_INTEGER";
    FORMATS2[FORMATS2["ALPHA"] = 6406] = "ALPHA";
    FORMATS2[FORMATS2["LUMINANCE"] = 6409] = "LUMINANCE";
    FORMATS2[FORMATS2["LUMINANCE_ALPHA"] = 6410] = "LUMINANCE_ALPHA";
    FORMATS2[FORMATS2["DEPTH_COMPONENT"] = 6402] = "DEPTH_COMPONENT";
    FORMATS2[FORMATS2["DEPTH_STENCIL"] = 34041] = "DEPTH_STENCIL";
    return FORMATS2;
  })(FORMATS || {});
  var TARGETS = /* @__PURE__ */ ((TARGETS2) => {
    TARGETS2[TARGETS2["TEXTURE_2D"] = 3553] = "TEXTURE_2D";
    TARGETS2[TARGETS2["TEXTURE_CUBE_MAP"] = 34067] = "TEXTURE_CUBE_MAP";
    TARGETS2[TARGETS2["TEXTURE_2D_ARRAY"] = 35866] = "TEXTURE_2D_ARRAY";
    TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_X"] = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X";
    TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_X"] = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X";
    TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Y"] = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y";
    TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Y"] = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y";
    TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Z"] = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z";
    TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Z"] = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
    return TARGETS2;
  })(TARGETS || {});
  var TYPES = /* @__PURE__ */ ((TYPES2) => {
    TYPES2[TYPES2["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
    TYPES2[TYPES2["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
    TYPES2[TYPES2["UNSIGNED_SHORT_5_6_5"] = 33635] = "UNSIGNED_SHORT_5_6_5";
    TYPES2[TYPES2["UNSIGNED_SHORT_4_4_4_4"] = 32819] = "UNSIGNED_SHORT_4_4_4_4";
    TYPES2[TYPES2["UNSIGNED_SHORT_5_5_5_1"] = 32820] = "UNSIGNED_SHORT_5_5_5_1";
    TYPES2[TYPES2["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
    TYPES2[TYPES2["UNSIGNED_INT_10F_11F_11F_REV"] = 35899] = "UNSIGNED_INT_10F_11F_11F_REV";
    TYPES2[TYPES2["UNSIGNED_INT_2_10_10_10_REV"] = 33640] = "UNSIGNED_INT_2_10_10_10_REV";
    TYPES2[TYPES2["UNSIGNED_INT_24_8"] = 34042] = "UNSIGNED_INT_24_8";
    TYPES2[TYPES2["UNSIGNED_INT_5_9_9_9_REV"] = 35902] = "UNSIGNED_INT_5_9_9_9_REV";
    TYPES2[TYPES2["BYTE"] = 5120] = "BYTE";
    TYPES2[TYPES2["SHORT"] = 5122] = "SHORT";
    TYPES2[TYPES2["INT"] = 5124] = "INT";
    TYPES2[TYPES2["FLOAT"] = 5126] = "FLOAT";
    TYPES2[TYPES2["FLOAT_32_UNSIGNED_INT_24_8_REV"] = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV";
    TYPES2[TYPES2["HALF_FLOAT"] = 36193] = "HALF_FLOAT";
    return TYPES2;
  })(TYPES || {});
  var SAMPLER_TYPES = /* @__PURE__ */ ((SAMPLER_TYPES2) => {
    SAMPLER_TYPES2[SAMPLER_TYPES2["FLOAT"] = 0] = "FLOAT";
    SAMPLER_TYPES2[SAMPLER_TYPES2["INT"] = 1] = "INT";
    SAMPLER_TYPES2[SAMPLER_TYPES2["UINT"] = 2] = "UINT";
    return SAMPLER_TYPES2;
  })(SAMPLER_TYPES || {});
  var SCALE_MODES = /* @__PURE__ */ ((SCALE_MODES2) => {
    SCALE_MODES2[SCALE_MODES2["NEAREST"] = 0] = "NEAREST";
    SCALE_MODES2[SCALE_MODES2["LINEAR"] = 1] = "LINEAR";
    return SCALE_MODES2;
  })(SCALE_MODES || {});
  var WRAP_MODES = /* @__PURE__ */ ((WRAP_MODES2) => {
    WRAP_MODES2[WRAP_MODES2["CLAMP"] = 33071] = "CLAMP";
    WRAP_MODES2[WRAP_MODES2["REPEAT"] = 10497] = "REPEAT";
    WRAP_MODES2[WRAP_MODES2["MIRRORED_REPEAT"] = 33648] = "MIRRORED_REPEAT";
    return WRAP_MODES2;
  })(WRAP_MODES || {});
  var MIPMAP_MODES = /* @__PURE__ */ ((MIPMAP_MODES2) => {
    MIPMAP_MODES2[MIPMAP_MODES2["OFF"] = 0] = "OFF";
    MIPMAP_MODES2[MIPMAP_MODES2["POW2"] = 1] = "POW2";
    MIPMAP_MODES2[MIPMAP_MODES2["ON"] = 2] = "ON";
    MIPMAP_MODES2[MIPMAP_MODES2["ON_MANUAL"] = 3] = "ON_MANUAL";
    return MIPMAP_MODES2;
  })(MIPMAP_MODES || {});
  var ALPHA_MODES = /* @__PURE__ */ ((ALPHA_MODES2) => {
    ALPHA_MODES2[ALPHA_MODES2["NPM"] = 0] = "NPM";
    ALPHA_MODES2[ALPHA_MODES2["UNPACK"] = 1] = "UNPACK";
    ALPHA_MODES2[ALPHA_MODES2["PMA"] = 2] = "PMA";
    ALPHA_MODES2[ALPHA_MODES2["NO_PREMULTIPLIED_ALPHA"] = 0] = "NO_PREMULTIPLIED_ALPHA";
    ALPHA_MODES2[ALPHA_MODES2["PREMULTIPLY_ON_UPLOAD"] = 1] = "PREMULTIPLY_ON_UPLOAD";
    ALPHA_MODES2[ALPHA_MODES2["PREMULTIPLIED_ALPHA"] = 2] = "PREMULTIPLIED_ALPHA";
    return ALPHA_MODES2;
  })(ALPHA_MODES || {});
  var CLEAR_MODES = /* @__PURE__ */ ((CLEAR_MODES2) => {
    CLEAR_MODES2[CLEAR_MODES2["NO"] = 0] = "NO";
    CLEAR_MODES2[CLEAR_MODES2["YES"] = 1] = "YES";
    CLEAR_MODES2[CLEAR_MODES2["AUTO"] = 2] = "AUTO";
    CLEAR_MODES2[CLEAR_MODES2["BLEND"] = 0] = "BLEND";
    CLEAR_MODES2[CLEAR_MODES2["CLEAR"] = 1] = "CLEAR";
    CLEAR_MODES2[CLEAR_MODES2["BLIT"] = 2] = "BLIT";
    return CLEAR_MODES2;
  })(CLEAR_MODES || {});
  var GC_MODES = /* @__PURE__ */ ((GC_MODES2) => {
    GC_MODES2[GC_MODES2["AUTO"] = 0] = "AUTO";
    GC_MODES2[GC_MODES2["MANUAL"] = 1] = "MANUAL";
    return GC_MODES2;
  })(GC_MODES || {});
  var PRECISION = /* @__PURE__ */ ((PRECISION2) => {
    PRECISION2["LOW"] = "lowp";
    PRECISION2["MEDIUM"] = "mediump";
    PRECISION2["HIGH"] = "highp";
    return PRECISION2;
  })(PRECISION || {});
  var MASK_TYPES = /* @__PURE__ */ ((MASK_TYPES2) => {
    MASK_TYPES2[MASK_TYPES2["NONE"] = 0] = "NONE";
    MASK_TYPES2[MASK_TYPES2["SCISSOR"] = 1] = "SCISSOR";
    MASK_TYPES2[MASK_TYPES2["STENCIL"] = 2] = "STENCIL";
    MASK_TYPES2[MASK_TYPES2["SPRITE"] = 3] = "SPRITE";
    MASK_TYPES2[MASK_TYPES2["COLOR"] = 4] = "COLOR";
    return MASK_TYPES2;
  })(MASK_TYPES || {});
  var MSAA_QUALITY = /* @__PURE__ */ ((MSAA_QUALITY2) => {
    MSAA_QUALITY2[MSAA_QUALITY2["NONE"] = 0] = "NONE";
    MSAA_QUALITY2[MSAA_QUALITY2["LOW"] = 2] = "LOW";
    MSAA_QUALITY2[MSAA_QUALITY2["MEDIUM"] = 4] = "MEDIUM";
    MSAA_QUALITY2[MSAA_QUALITY2["HIGH"] = 8] = "HIGH";
    return MSAA_QUALITY2;
  })(MSAA_QUALITY || {});
  var BUFFER_TYPE = /* @__PURE__ */ ((BUFFER_TYPE2) => {
    BUFFER_TYPE2[BUFFER_TYPE2["ELEMENT_ARRAY_BUFFER"] = 34963] = "ELEMENT_ARRAY_BUFFER";
    BUFFER_TYPE2[BUFFER_TYPE2["ARRAY_BUFFER"] = 34962] = "ARRAY_BUFFER";
    BUFFER_TYPE2[BUFFER_TYPE2["UNIFORM_BUFFER"] = 35345] = "UNIFORM_BUFFER";
    return BUFFER_TYPE2;
  })(BUFFER_TYPE || {});

  // node_modules/pixijs/settings/adapter.mjs
  var BrowserAdapter = {
    createCanvas: (width, height) => {
      const canvas = document.createElement("canvas");
      canvas.width = width;
      canvas.height = height;
      return canvas;
    },
    getCanvasRenderingContext2D: () => CanvasRenderingContext2D,
    getWebGLRenderingContext: () => WebGLRenderingContext,
    getNavigator: () => navigator,
    getBaseUrl: () => {
      var _a;
      return (_a = document.baseURI) != null ? _a : window.location.href;
    },
    getFontFaceSet: () => document.fonts,
    fetch: (url2, options) => fetch(url2, options),
    parseXML: (xml) => {
      const parser = new DOMParser();
      return parser.parseFromString(xml, "text/xml");
    }
  };

  // node_modules/pixijs/settings/settings.mjs
  var settings = {
    ADAPTER: BrowserAdapter,
    RESOLUTION: 1,
    RENDER_OPTIONS: {
      view: null,
      antialias: false,
      autoDensity: false,
      backgroundColor: 0,
      backgroundAlpha: 1,
      premultipliedAlpha: true,
      clearBeforeRender: true,
      preserveDrawingBuffer: false,
      width: 800,
      height: 600,
      legacy: false,
      hello: false
    },
    CREATE_IMAGE_BITMAP: false,
    ROUND_PIXELS: false
  };

  // node_modules/pixijs/settings/external/ismobilejs/esm/isMobile.mjs
  var appleIphone = /iPhone/i;
  var appleIpod = /iPod/i;
  var appleTablet = /iPad/i;
  var appleUniversal = /\biOS-universal(?:.+)Mac\b/i;
  var androidPhone = /\bAndroid(?:.+)Mobile\b/i;
  var androidTablet = /Android/i;
  var amazonPhone = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i;
  var amazonTablet = /Silk/i;
  var windowsPhone = /Windows Phone/i;
  var windowsTablet = /\bWindows(?:.+)ARM\b/i;
  var otherBlackBerry = /BlackBerry/i;
  var otherBlackBerry10 = /BB10/i;
  var otherOpera = /Opera Mini/i;
  var otherChrome = /\b(CriOS|Chrome)(?:.+)Mobile/i;
  var otherFirefox = /Mobile(?:.+)Firefox\b/i;
  var isAppleTabletOnIos13 = function(navigator2) {
    return typeof navigator2 !== "undefined" && navigator2.platform === "MacIntel" && typeof navigator2.maxTouchPoints === "number" && navigator2.maxTouchPoints > 1 && typeof MSStream === "undefined";
  };
  function createMatch(userAgent) {
    return function(regex) {
      return regex.test(userAgent);
    };
  }
  function isMobile(param) {
    var nav = {
      userAgent: "",
      platform: "",
      maxTouchPoints: 0
    };
    if (!param && typeof navigator !== "undefined") {
      nav = {
        userAgent: navigator.userAgent,
        platform: navigator.platform,
        maxTouchPoints: navigator.maxTouchPoints || 0
      };
    } else if (typeof param === "string") {
      nav.userAgent = param;
    } else if (param && param.userAgent) {
      nav = {
        userAgent: param.userAgent,
        platform: param.platform,
        maxTouchPoints: param.maxTouchPoints || 0
      };
    }
    var userAgent = nav.userAgent;
    var tmp = userAgent.split("[FBAN");
    if (typeof tmp[1] !== "undefined") {
      userAgent = tmp[0];
    }
    tmp = userAgent.split("Twitter");
    if (typeof tmp[1] !== "undefined") {
      userAgent = tmp[0];
    }
    var match = createMatch(userAgent);
    var result = {
      apple: {
        phone: match(appleIphone) && !match(windowsPhone),
        ipod: match(appleIpod),
        tablet: !match(appleIphone) && (match(appleTablet) || isAppleTabletOnIos13(nav)) && !match(windowsPhone),
        universal: match(appleUniversal),
        device: (match(appleIphone) || match(appleIpod) || match(appleTablet) || match(appleUniversal) || isAppleTabletOnIos13(nav)) && !match(windowsPhone)
      },
      amazon: {
        phone: match(amazonPhone),
        tablet: !match(amazonPhone) && match(amazonTablet),
        device: match(amazonPhone) || match(amazonTablet)
      },
      android: {
        phone: !match(windowsPhone) && match(amazonPhone) || !match(windowsPhone) && match(androidPhone),
        tablet: !match(windowsPhone) && !match(amazonPhone) && !match(androidPhone) && (match(amazonTablet) || match(androidTablet)),
        device: !match(windowsPhone) && (match(amazonPhone) || match(amazonTablet) || match(androidPhone) || match(androidTablet)) || match(/\bokhttp\b/i)
      },
      windows: {
        phone: match(windowsPhone),
        tablet: match(windowsTablet),
        device: match(windowsPhone) || match(windowsTablet)
      },
      other: {
        blackberry: match(otherBlackBerry),
        blackberry10: match(otherBlackBerry10),
        opera: match(otherOpera),
        firefox: match(otherFirefox),
        chrome: match(otherChrome),
        device: match(otherBlackBerry) || match(otherBlackBerry10) || match(otherOpera) || match(otherFirefox) || match(otherChrome)
      },
      any: false,
      phone: false,
      tablet: false
    };
    result.any = result.apple.device || result.android.device || result.windows.device || result.other.device;
    result.phone = result.apple.phone || result.android.phone || result.windows.phone;
    result.tablet = result.apple.tablet || result.android.tablet || result.windows.tablet;
    return result;
  }

  // node_modules/pixijs/settings/utils/isMobile.mjs
  var isMobile2 = isMobile(globalThis.navigator);

  // node_modules/pixijs/utils/index.mjs
  var utils_exports = {};
  __export(utils_exports, {
    BaseTextureCache: () => BaseTextureCache,
    BoundingBox: () => BoundingBox,
    CanvasRenderTarget: () => CanvasRenderTarget,
    DATA_URI: () => DATA_URI,
    EventEmitter: () => import_eventemitter3.default,
    ProgramCache: () => ProgramCache,
    TextureCache: () => TextureCache,
    clearTextureCache: () => clearTextureCache,
    correctBlendMode: () => correctBlendMode,
    createIndicesForQuads: () => createIndicesForQuads,
    decomposeDataUri: () => decomposeDataUri,
    deprecation: () => deprecation,
    destroyTextureCache: () => destroyTextureCache,
    determineCrossOrigin: () => determineCrossOrigin,
    earcut: () => import_earcut.default,
    getBufferType: () => getBufferType,
    getCanvasBoundingBox: () => getCanvasBoundingBox,
    getResolutionOfUrl: () => getResolutionOfUrl,
    hex2rgb: () => hex2rgb,
    hex2string: () => hex2string,
    interleaveTypedArrays: () => interleaveTypedArrays,
    isMobile: () => isMobile2,
    isPow2: () => isPow2,
    isWebGLSupported: () => isWebGLSupported,
    log2: () => log2,
    nextPow2: () => nextPow2,
    path: () => path,
    premultiplyBlendMode: () => premultiplyBlendMode,
    premultiplyRgba: () => premultiplyRgba,
    premultiplyTint: () => premultiplyTint,
    premultiplyTintToRgba: () => premultiplyTintToRgba,
    removeItems: () => removeItems,
    rgb2hex: () => rgb2hex,
    sayHello: () => sayHello,
    sign: () => sign,
    skipHello: () => skipHello,
    string2hex: () => string2hex,
    trimCanvas: () => trimCanvas,
    uid: () => uid,
    url: () => url
  });

  // node_modules/pixijs/utils/settings.mjs
  settings.RETINA_PREFIX = /@([0-9\.]+)x/;
  settings.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT = false;

  // node_modules/pixijs/utils/index.mjs
  var import_eventemitter3 = __toESM(require_eventemitter3(), 1);
  var import_earcut = __toESM(require_earcut(), 1);

  // node_modules/pixijs/utils/url.mjs
  var import_url = __toESM(require_url(), 1);
  var url = {
    parse: import_url.parse,
    format: import_url.format,
    resolve: import_url.resolve
  };

  // node_modules/pixijs/utils/path.mjs
  function assertPath(path2) {
    if (typeof path2 !== "string") {
      throw new TypeError(`Path must be a string. Received ${JSON.stringify(path2)}`);
    }
  }
  function removeUrlParams(url2) {
    const re = url2.split("?")[0];
    return re.split("#")[0];
  }
  function escapeRegExp(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }
  function replaceAll(str, find3, replace) {
    return str.replace(new RegExp(escapeRegExp(find3), "g"), replace);
  }
  function normalizeStringPosix(path2, allowAboveRoot) {
    let res = "";
    let lastSegmentLength = 0;
    let lastSlash = -1;
    let dots = 0;
    let code = -1;
    for (let i = 0; i <= path2.length; ++i) {
      if (i < path2.length) {
        code = path2.charCodeAt(i);
      } else if (code === 47) {
        break;
      } else {
        code = 47;
      }
      if (code === 47) {
        if (lastSlash === i - 1 || dots === 1) {
        } else if (lastSlash !== i - 1 && dots === 2) {
          if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
            if (res.length > 2) {
              const lastSlashIndex = res.lastIndexOf("/");
              if (lastSlashIndex !== res.length - 1) {
                if (lastSlashIndex === -1) {
                  res = "";
                  lastSegmentLength = 0;
                } else {
                  res = res.slice(0, lastSlashIndex);
                  lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
                }
                lastSlash = i;
                dots = 0;
                continue;
              }
            } else if (res.length === 2 || res.length === 1) {
              res = "";
              lastSegmentLength = 0;
              lastSlash = i;
              dots = 0;
              continue;
            }
          }
          if (allowAboveRoot) {
            if (res.length > 0) {
              res += "/..";
            } else {
              res = "..";
            }
            lastSegmentLength = 2;
          }
        } else {
          if (res.length > 0) {
            res += `/${path2.slice(lastSlash + 1, i)}`;
          } else {
            res = path2.slice(lastSlash + 1, i);
          }
          lastSegmentLength = i - lastSlash - 1;
        }
        lastSlash = i;
        dots = 0;
      } else if (code === 46 && dots !== -1) {
        ++dots;
      } else {
        dots = -1;
      }
    }
    return res;
  }
  var path = {
    toPosix(path2) {
      return replaceAll(path2, "\\", "/");
    },
    isUrl(path2) {
      return /^https?:/.test(this.toPosix(path2));
    },
    isDataUrl(path2) {
      return /^data:([a-z]+\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@\/?%\s<>]*?)$/i.test(path2);
    },
    hasProtocol(path2) {
      return /^[^/:]+:\//.test(this.toPosix(path2));
    },
    getProtocol(path2) {
      assertPath(path2);
      path2 = this.toPosix(path2);
      let protocol = "";
      const isFile = /^file:\/\/\//.exec(path2);
      const isHttp = /^[^/:]+:\/\//.exec(path2);
      const isWindows = /^[^/:]+:\//.exec(path2);
      if (isFile || isHttp || isWindows) {
        const arr = (isFile == null ? void 0 : isFile[0]) || (isHttp == null ? void 0 : isHttp[0]) || (isWindows == null ? void 0 : isWindows[0]);
        protocol = arr;
        path2 = path2.slice(arr.length);
      }
      return protocol;
    },
    toAbsolute(url2, customBaseUrl, customRootUrl) {
      if (this.isDataUrl(url2))
        return url2;
      const baseUrl = removeUrlParams(this.toPosix(customBaseUrl != null ? customBaseUrl : settings.ADAPTER.getBaseUrl()));
      const rootUrl = removeUrlParams(this.toPosix(customRootUrl != null ? customRootUrl : this.rootname(baseUrl)));
      assertPath(url2);
      url2 = this.toPosix(url2);
      if (url2.startsWith("/")) {
        return path.join(rootUrl, url2.slice(1));
      }
      const absolutePath = this.isAbsolute(url2) ? url2 : this.join(baseUrl, url2);
      return absolutePath;
    },
    normalize(path2) {
      path2 = this.toPosix(path2);
      assertPath(path2);
      if (path2.length === 0)
        return ".";
      let protocol = "";
      const isAbsolute = path2.startsWith("/");
      if (this.hasProtocol(path2)) {
        protocol = this.rootname(path2);
        path2 = path2.slice(protocol.length);
      }
      const trailingSeparator = path2.endsWith("/");
      path2 = normalizeStringPosix(path2, false);
      if (path2.length > 0 && trailingSeparator)
        path2 += "/";
      if (isAbsolute)
        return `/${path2}`;
      return protocol + path2;
    },
    isAbsolute(path2) {
      assertPath(path2);
      path2 = this.toPosix(path2);
      if (this.hasProtocol(path2))
        return true;
      return path2.startsWith("/");
    },
    join(...segments) {
      var _a;
      if (segments.length === 0) {
        return ".";
      }
      let joined;
      for (let i = 0; i < segments.length; ++i) {
        const arg = segments[i];
        assertPath(arg);
        if (arg.length > 0) {
          if (joined === void 0)
            joined = arg;
          else {
            const prevArg = (_a = segments[i - 1]) != null ? _a : "";
            if (this.extname(prevArg)) {
              joined += `/../${arg}`;
            } else {
              joined += `/${arg}`;
            }
          }
        }
      }
      if (joined === void 0) {
        return ".";
      }
      return this.normalize(joined);
    },
    dirname(path2) {
      assertPath(path2);
      if (path2.length === 0)
        return ".";
      path2 = this.toPosix(path2);
      let code = path2.charCodeAt(0);
      const hasRoot = code === 47;
      let end = -1;
      let matchedSlash = true;
      const proto = this.getProtocol(path2);
      const origpath = path2;
      path2 = path2.slice(proto.length);
      for (let i = path2.length - 1; i >= 1; --i) {
        code = path2.charCodeAt(i);
        if (code === 47) {
          if (!matchedSlash) {
            end = i;
            break;
          }
        } else {
          matchedSlash = false;
        }
      }
      if (end === -1)
        return hasRoot ? "/" : this.isUrl(origpath) ? proto + path2 : proto;
      if (hasRoot && end === 1)
        return "//";
      return proto + path2.slice(0, end);
    },
    rootname(path2) {
      assertPath(path2);
      path2 = this.toPosix(path2);
      let root2 = "";
      if (path2.startsWith("/"))
        root2 = "/";
      else {
        root2 = this.getProtocol(path2);
      }
      if (this.isUrl(path2)) {
        const index2 = path2.indexOf("/", root2.length);
        if (index2 !== -1) {
          root2 = path2.slice(0, index2);
        } else
          root2 = path2;
        if (!root2.endsWith("/"))
          root2 += "/";
      }
      return root2;
    },
    basename(path2, ext) {
      assertPath(path2);
      if (ext)
        assertPath(ext);
      path2 = removeUrlParams(this.toPosix(path2));
      let start2 = 0;
      let end = -1;
      let matchedSlash = true;
      let i;
      if (ext !== void 0 && ext.length > 0 && ext.length <= path2.length) {
        if (ext.length === path2.length && ext === path2)
          return "";
        let extIdx = ext.length - 1;
        let firstNonSlashEnd = -1;
        for (i = path2.length - 1; i >= 0; --i) {
          const code = path2.charCodeAt(i);
          if (code === 47) {
            if (!matchedSlash) {
              start2 = i + 1;
              break;
            }
          } else {
            if (firstNonSlashEnd === -1) {
              matchedSlash = false;
              firstNonSlashEnd = i + 1;
            }
            if (extIdx >= 0) {
              if (code === ext.charCodeAt(extIdx)) {
                if (--extIdx === -1) {
                  end = i;
                }
              } else {
                extIdx = -1;
                end = firstNonSlashEnd;
              }
            }
          }
        }
        if (start2 === end)
          end = firstNonSlashEnd;
        else if (end === -1)
          end = path2.length;
        return path2.slice(start2, end);
      }
      for (i = path2.length - 1; i >= 0; --i) {
        if (path2.charCodeAt(i) === 47) {
          if (!matchedSlash) {
            start2 = i + 1;
            break;
          }
        } else if (end === -1) {
          matchedSlash = false;
          end = i + 1;
        }
      }
      if (end === -1)
        return "";
      return path2.slice(start2, end);
    },
    extname(path2) {
      assertPath(path2);
      path2 = removeUrlParams(this.toPosix(path2));
      let startDot = -1;
      let startPart = 0;
      let end = -1;
      let matchedSlash = true;
      let preDotState = 0;
      for (let i = path2.length - 1; i >= 0; --i) {
        const code = path2.charCodeAt(i);
        if (code === 47) {
          if (!matchedSlash) {
            startPart = i + 1;
            break;
          }
          continue;
        }
        if (end === -1) {
          matchedSlash = false;
          end = i + 1;
        }
        if (code === 46) {
          if (startDot === -1)
            startDot = i;
          else if (preDotState !== 1)
            preDotState = 1;
        } else if (startDot !== -1) {
          preDotState = -1;
        }
      }
      if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
      }
      return path2.slice(startDot, end);
    },
    parse(path2) {
      assertPath(path2);
      const ret = { root: "", dir: "", base: "", ext: "", name: "" };
      if (path2.length === 0)
        return ret;
      path2 = removeUrlParams(this.toPosix(path2));
      let code = path2.charCodeAt(0);
      const isAbsolute = this.isAbsolute(path2);
      let start2;
      const protocol = "";
      ret.root = this.rootname(path2);
      if (isAbsolute || this.hasProtocol(path2)) {
        start2 = 1;
      } else {
        start2 = 0;
      }
      let startDot = -1;
      let startPart = 0;
      let end = -1;
      let matchedSlash = true;
      let i = path2.length - 1;
      let preDotState = 0;
      for (; i >= start2; --i) {
        code = path2.charCodeAt(i);
        if (code === 47) {
          if (!matchedSlash) {
            startPart = i + 1;
            break;
          }
          continue;
        }
        if (end === -1) {
          matchedSlash = false;
          end = i + 1;
        }
        if (code === 46) {
          if (startDot === -1)
            startDot = i;
          else if (preDotState !== 1)
            preDotState = 1;
        } else if (startDot !== -1) {
          preDotState = -1;
        }
      }
      if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
          if (startPart === 0 && isAbsolute)
            ret.base = ret.name = path2.slice(1, end);
          else
            ret.base = ret.name = path2.slice(startPart, end);
        }
      } else {
        if (startPart === 0 && isAbsolute) {
          ret.name = path2.slice(1, startDot);
          ret.base = path2.slice(1, end);
        } else {
          ret.name = path2.slice(startPart, startDot);
          ret.base = path2.slice(startPart, end);
        }
        ret.ext = path2.slice(startDot, end);
      }
      ret.dir = this.dirname(path2);
      if (protocol)
        ret.dir = protocol + ret.dir;
      return ret;
    },
    sep: "/",
    delimiter: ":"
  };

  // node_modules/pixijs/utils/logging/deprecation.mjs
  var warnings = {};
  function deprecation(version, message, ignoreDepth = 3) {
    if (warnings[message]) {
      return;
    }
    let stack = new Error().stack;
    if (typeof stack === "undefined") {
      console.warn("PixiJS Deprecation Warning: ", `${message}
Deprecated since v${version}`);
    } else {
      stack = stack.split("\n").splice(ignoreDepth).join("\n");
      if (console.groupCollapsed) {
        console.groupCollapsed("%cPixiJS Deprecation Warning: %c%s", "color:#614108;background:#fffbe6", "font-weight:normal;color:#614108;background:#fffbe6", `${message}
Deprecated since v${version}`);
        console.warn(stack);
        console.groupEnd();
      } else {
        console.warn("PixiJS Deprecation Warning: ", `${message}
Deprecated since v${version}`);
        console.warn(stack);
      }
    }
    warnings[message] = true;
  }

  // node_modules/pixijs/utils/browser/hello.mjs
  function skipHello() {
    deprecation("7.0.0", "skipHello is deprecated, please use settings.RENDER_OPTIONS.hello");
  }
  function sayHello() {
    deprecation("7.0.0", `sayHello is deprecated, please use Renderer's "hello" option`);
  }

  // node_modules/pixijs/utils/browser/isWebGLSupported.mjs
  var supported;
  function isWebGLSupported() {
    if (typeof supported === "undefined") {
      supported = function supported2() {
        var _a;
        const contextOptions = {
          stencil: true,
          failIfMajorPerformanceCaveat: settings.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT
        };
        try {
          if (!settings.ADAPTER.getWebGLRenderingContext()) {
            return false;
          }
          const canvas = settings.ADAPTER.createCanvas();
          let gl = canvas.getContext("webgl", contextOptions) || canvas.getContext("experimental-webgl", contextOptions);
          const success = !!((_a = gl == null ? void 0 : gl.getContextAttributes()) == null ? void 0 : _a.stencil);
          if (gl) {
            const loseContext = gl.getExtension("WEBGL_lose_context");
            if (loseContext) {
              loseContext.loseContext();
            }
          }
          gl = null;
          return success;
        } catch (e) {
          return false;
        }
      }();
    }
    return supported;
  }

  // node_modules/pixijs/utils/external/css-color-names/css-color-names.mjs
  var aliceblue = "#f0f8ff";
  var antiquewhite = "#faebd7";
  var aqua = "#00ffff";
  var aquamarine = "#7fffd4";
  var azure = "#f0ffff";
  var beige = "#f5f5dc";
  var bisque = "#ffe4c4";
  var black = "#000000";
  var blanchedalmond = "#ffebcd";
  var blue = "#0000ff";
  var blueviolet = "#8a2be2";
  var brown = "#a52a2a";
  var burlywood = "#deb887";
  var cadetblue = "#5f9ea0";
  var chartreuse = "#7fff00";
  var chocolate = "#d2691e";
  var coral = "#ff7f50";
  var cornflowerblue = "#6495ed";
  var cornsilk = "#fff8dc";
  var crimson = "#dc143c";
  var cyan = "#00ffff";
  var darkblue = "#00008b";
  var darkcyan = "#008b8b";
  var darkgoldenrod = "#b8860b";
  var darkgray = "#a9a9a9";
  var darkgreen = "#006400";
  var darkgrey = "#a9a9a9";
  var darkkhaki = "#bdb76b";
  var darkmagenta = "#8b008b";
  var darkolivegreen = "#556b2f";
  var darkorange = "#ff8c00";
  var darkorchid = "#9932cc";
  var darkred = "#8b0000";
  var darksalmon = "#e9967a";
  var darkseagreen = "#8fbc8f";
  var darkslateblue = "#483d8b";
  var darkslategray = "#2f4f4f";
  var darkslategrey = "#2f4f4f";
  var darkturquoise = "#00ced1";
  var darkviolet = "#9400d3";
  var deeppink = "#ff1493";
  var deepskyblue = "#00bfff";
  var dimgray = "#696969";
  var dimgrey = "#696969";
  var dodgerblue = "#1e90ff";
  var firebrick = "#b22222";
  var floralwhite = "#fffaf0";
  var forestgreen = "#228b22";
  var fuchsia = "#ff00ff";
  var gainsboro = "#dcdcdc";
  var ghostwhite = "#f8f8ff";
  var goldenrod = "#daa520";
  var gold = "#ffd700";
  var gray = "#808080";
  var green = "#008000";
  var greenyellow = "#adff2f";
  var grey = "#808080";
  var honeydew = "#f0fff0";
  var hotpink = "#ff69b4";
  var indianred = "#cd5c5c";
  var indigo = "#4b0082";
  var ivory = "#fffff0";
  var khaki = "#f0e68c";
  var lavenderblush = "#fff0f5";
  var lavender = "#e6e6fa";
  var lawngreen = "#7cfc00";
  var lemonchiffon = "#fffacd";
  var lightblue = "#add8e6";
  var lightcoral = "#f08080";
  var lightcyan = "#e0ffff";
  var lightgoldenrodyellow = "#fafad2";
  var lightgray = "#d3d3d3";
  var lightgreen = "#90ee90";
  var lightgrey = "#d3d3d3";
  var lightpink = "#ffb6c1";
  var lightsalmon = "#ffa07a";
  var lightseagreen = "#20b2aa";
  var lightskyblue = "#87cefa";
  var lightslategray = "#778899";
  var lightslategrey = "#778899";
  var lightsteelblue = "#b0c4de";
  var lightyellow = "#ffffe0";
  var lime = "#00ff00";
  var limegreen = "#32cd32";
  var linen = "#faf0e6";
  var magenta = "#ff00ff";
  var maroon = "#800000";
  var mediumaquamarine = "#66cdaa";
  var mediumblue = "#0000cd";
  var mediumorchid = "#ba55d3";
  var mediumpurple = "#9370db";
  var mediumseagreen = "#3cb371";
  var mediumslateblue = "#7b68ee";
  var mediumspringgreen = "#00fa9a";
  var mediumturquoise = "#48d1cc";
  var mediumvioletred = "#c71585";
  var midnightblue = "#191970";
  var mintcream = "#f5fffa";
  var mistyrose = "#ffe4e1";
  var moccasin = "#ffe4b5";
  var navajowhite = "#ffdead";
  var navy = "#000080";
  var oldlace = "#fdf5e6";
  var olive = "#808000";
  var olivedrab = "#6b8e23";
  var orange = "#ffa500";
  var orangered = "#ff4500";
  var orchid = "#da70d6";
  var palegoldenrod = "#eee8aa";
  var palegreen = "#98fb98";
  var paleturquoise = "#afeeee";
  var palevioletred = "#db7093";
  var papayawhip = "#ffefd5";
  var peachpuff = "#ffdab9";
  var peru = "#cd853f";
  var pink = "#ffc0cb";
  var plum = "#dda0dd";
  var powderblue = "#b0e0e6";
  var purple = "#800080";
  var rebeccapurple = "#663399";
  var red = "#ff0000";
  var rosybrown = "#bc8f8f";
  var royalblue = "#4169e1";
  var saddlebrown = "#8b4513";
  var salmon = "#fa8072";
  var sandybrown = "#f4a460";
  var seagreen = "#2e8b57";
  var seashell = "#fff5ee";
  var sienna = "#a0522d";
  var silver = "#c0c0c0";
  var skyblue = "#87ceeb";
  var slateblue = "#6a5acd";
  var slategray = "#708090";
  var slategrey = "#708090";
  var snow = "#fffafa";
  var springgreen = "#00ff7f";
  var steelblue = "#4682b4";
  var tan = "#d2b48c";
  var teal = "#008080";
  var thistle = "#d8bfd8";
  var tomato = "#ff6347";
  var turquoise = "#40e0d0";
  var violet = "#ee82ee";
  var wheat = "#f5deb3";
  var white = "#ffffff";
  var whitesmoke = "#f5f5f5";
  var yellow = "#ffff00";
  var yellowgreen = "#9acd32";
  var cssColorNames = {
    aliceblue,
    antiquewhite,
    aqua,
    aquamarine,
    azure,
    beige,
    bisque,
    black,
    blanchedalmond,
    blue,
    blueviolet,
    brown,
    burlywood,
    cadetblue,
    chartreuse,
    chocolate,
    coral,
    cornflowerblue,
    cornsilk,
    crimson,
    cyan,
    darkblue,
    darkcyan,
    darkgoldenrod,
    darkgray,
    darkgreen,
    darkgrey,
    darkkhaki,
    darkmagenta,
    darkolivegreen,
    darkorange,
    darkorchid,
    darkred,
    darksalmon,
    darkseagreen,
    darkslateblue,
    darkslategray,
    darkslategrey,
    darkturquoise,
    darkviolet,
    deeppink,
    deepskyblue,
    dimgray,
    dimgrey,
    dodgerblue,
    firebrick,
    floralwhite,
    forestgreen,
    fuchsia,
    gainsboro,
    ghostwhite,
    goldenrod,
    gold,
    gray,
    green,
    greenyellow,
    grey,
    honeydew,
    hotpink,
    indianred,
    indigo,
    ivory,
    khaki,
    lavenderblush,
    lavender,
    lawngreen,
    lemonchiffon,
    lightblue,
    lightcoral,
    lightcyan,
    lightgoldenrodyellow,
    lightgray,
    lightgreen,
    lightgrey,
    lightpink,
    lightsalmon,
    lightseagreen,
    lightskyblue,
    lightslategray,
    lightslategrey,
    lightsteelblue,
    lightyellow,
    lime,
    limegreen,
    linen,
    magenta,
    maroon,
    mediumaquamarine,
    mediumblue,
    mediumorchid,
    mediumpurple,
    mediumseagreen,
    mediumslateblue,
    mediumspringgreen,
    mediumturquoise,
    mediumvioletred,
    midnightblue,
    mintcream,
    mistyrose,
    moccasin,
    navajowhite,
    navy,
    oldlace,
    olive,
    olivedrab,
    orange,
    orangered,
    orchid,
    palegoldenrod,
    palegreen,
    paleturquoise,
    palevioletred,
    papayawhip,
    peachpuff,
    peru,
    pink,
    plum,
    powderblue,
    purple,
    rebeccapurple,
    red,
    rosybrown,
    royalblue,
    saddlebrown,
    salmon,
    sandybrown,
    seagreen,
    seashell,
    sienna,
    silver,
    skyblue,
    slateblue,
    slategray,
    slategrey,
    snow,
    springgreen,
    steelblue,
    tan,
    teal,
    thistle,
    tomato,
    turquoise,
    violet,
    wheat,
    white,
    whitesmoke,
    yellow,
    yellowgreen
  };

  // node_modules/pixijs/utils/color/hex.mjs
  function hex2rgb(hex2, out = []) {
    out[0] = (hex2 >> 16 & 255) / 255;
    out[1] = (hex2 >> 8 & 255) / 255;
    out[2] = (hex2 & 255) / 255;
    return out;
  }
  function hex2string(hex2) {
    let hexString = hex2.toString(16);
    hexString = "000000".substring(0, 6 - hexString.length) + hexString;
    return `#${hexString}`;
  }
  function string2hex(string) {
    if (typeof string === "string") {
      string = cssColorNames[string.toLowerCase()] || string;
      if (string[0] === "#") {
        string = string.slice(1);
      }
      if (string.length === 3) {
        const [r, g, b] = string;
        string = r + r + g + g + b + b;
      }
    }
    return parseInt(string, 16);
  }
  function rgb2hex(rgb2) {
    return (rgb2[0] * 255 << 16) + (rgb2[1] * 255 << 8) + (rgb2[2] * 255 | 0);
  }

  // node_modules/pixijs/utils/color/premultiply.mjs
  function mapPremultipliedBlendModes() {
    const pm = [];
    const npm = [];
    for (let i = 0; i < 32; i++) {
      pm[i] = i;
      npm[i] = i;
    }
    pm[BLEND_MODES.NORMAL_NPM] = BLEND_MODES.NORMAL;
    pm[BLEND_MODES.ADD_NPM] = BLEND_MODES.ADD;
    pm[BLEND_MODES.SCREEN_NPM] = BLEND_MODES.SCREEN;
    npm[BLEND_MODES.NORMAL] = BLEND_MODES.NORMAL_NPM;
    npm[BLEND_MODES.ADD] = BLEND_MODES.ADD_NPM;
    npm[BLEND_MODES.SCREEN] = BLEND_MODES.SCREEN_NPM;
    const array2 = [];
    array2.push(npm);
    array2.push(pm);
    return array2;
  }
  var premultiplyBlendMode = mapPremultipliedBlendModes();
  function correctBlendMode(blendMode, premultiplied) {
    return premultiplyBlendMode[premultiplied ? 1 : 0][blendMode];
  }
  function premultiplyRgba(rgb2, alpha, out, premultiply) {
    out = out || new Float32Array(4);
    if (premultiply || premultiply === void 0) {
      out[0] = rgb2[0] * alpha;
      out[1] = rgb2[1] * alpha;
      out[2] = rgb2[2] * alpha;
    } else {
      out[0] = rgb2[0];
      out[1] = rgb2[1];
      out[2] = rgb2[2];
    }
    out[3] = alpha;
    return out;
  }
  function premultiplyTint(tint, alpha) {
    if (alpha === 1) {
      return (alpha * 255 << 24) + tint;
    }
    if (alpha === 0) {
      return 0;
    }
    let R = tint >> 16 & 255;
    let G = tint >> 8 & 255;
    let B = tint & 255;
    R = R * alpha + 0.5 | 0;
    G = G * alpha + 0.5 | 0;
    B = B * alpha + 0.5 | 0;
    return (alpha * 255 << 24) + (R << 16) + (G << 8) + B;
  }
  function premultiplyTintToRgba(tint, alpha, out, premultiply) {
    out = out || new Float32Array(4);
    out[0] = (tint >> 16 & 255) / 255;
    out[1] = (tint >> 8 & 255) / 255;
    out[2] = (tint & 255) / 255;
    if (premultiply || premultiply === void 0) {
      out[0] *= alpha;
      out[1] *= alpha;
      out[2] *= alpha;
    }
    out[3] = alpha;
    return out;
  }

  // node_modules/pixijs/utils/const.mjs
  var DATA_URI = /^\s*data:(?:([\w-]+)\/([\w+.-]+))?(?:;charset=([\w-]+))?(?:;(base64))?,(.*)/i;

  // node_modules/pixijs/utils/data/createIndicesForQuads.mjs
  function createIndicesForQuads(size, outBuffer = null) {
    const totalIndices = size * 6;
    outBuffer = outBuffer || new Uint16Array(totalIndices);
    if (outBuffer.length !== totalIndices) {
      throw new Error(`Out buffer length is incorrect, got ${outBuffer.length} and expected ${totalIndices}`);
    }
    for (let i = 0, j = 0; i < totalIndices; i += 6, j += 4) {
      outBuffer[i + 0] = j + 0;
      outBuffer[i + 1] = j + 1;
      outBuffer[i + 2] = j + 2;
      outBuffer[i + 3] = j + 0;
      outBuffer[i + 4] = j + 2;
      outBuffer[i + 5] = j + 3;
    }
    return outBuffer;
  }

  // node_modules/pixijs/utils/data/getBufferType.mjs
  function getBufferType(array2) {
    if (array2.BYTES_PER_ELEMENT === 4) {
      if (array2 instanceof Float32Array) {
        return "Float32Array";
      } else if (array2 instanceof Uint32Array) {
        return "Uint32Array";
      }
      return "Int32Array";
    } else if (array2.BYTES_PER_ELEMENT === 2) {
      if (array2 instanceof Uint16Array) {
        return "Uint16Array";
      }
    } else if (array2.BYTES_PER_ELEMENT === 1) {
      if (array2 instanceof Uint8Array) {
        return "Uint8Array";
      }
    }
    return null;
  }

  // node_modules/pixijs/utils/data/interleaveTypedArrays.mjs
  var map = { Float32Array, Uint32Array, Int32Array, Uint8Array };
  function interleaveTypedArrays(arrays, sizes) {
    let outSize = 0;
    let stride = 0;
    const views = {};
    for (let i = 0; i < arrays.length; i++) {
      stride += sizes[i];
      outSize += arrays[i].length;
    }
    const buffer = new ArrayBuffer(outSize * 4);
    let out = null;
    let littleOffset = 0;
    for (let i = 0; i < arrays.length; i++) {
      const size = sizes[i];
      const array2 = arrays[i];
      const type2 = getBufferType(array2);
      if (!views[type2]) {
        views[type2] = new map[type2](buffer);
      }
      out = views[type2];
      for (let j = 0; j < array2.length; j++) {
        const indexStart = (j / size | 0) * stride + littleOffset;
        const index2 = j % size;
        out[indexStart + index2] = array2[j];
      }
      littleOffset += size;
    }
    return new Float32Array(buffer);
  }

  // node_modules/pixijs/utils/data/pow2.mjs
  function nextPow2(v) {
    v += v === 0 ? 1 : 0;
    --v;
    v |= v >>> 1;
    v |= v >>> 2;
    v |= v >>> 4;
    v |= v >>> 8;
    v |= v >>> 16;
    return v + 1;
  }
  function isPow2(v) {
    return !(v & v - 1) && !!v;
  }
  function log2(v) {
    let r = (v > 65535 ? 1 : 0) << 4;
    v >>>= r;
    let shift = (v > 255 ? 1 : 0) << 3;
    v >>>= shift;
    r |= shift;
    shift = (v > 15 ? 1 : 0) << 2;
    v >>>= shift;
    r |= shift;
    shift = (v > 3 ? 1 : 0) << 1;
    v >>>= shift;
    r |= shift;
    return r | v >> 1;
  }

  // node_modules/pixijs/utils/data/removeItems.mjs
  function removeItems(arr, startIdx, removeCount) {
    const length = arr.length;
    let i;
    if (startIdx >= length || removeCount === 0) {
      return;
    }
    removeCount = startIdx + removeCount > length ? length - startIdx : removeCount;
    const len = length - removeCount;
    for (i = startIdx; i < len; ++i) {
      arr[i] = arr[i + removeCount];
    }
    arr.length = len;
  }

  // node_modules/pixijs/utils/data/sign.mjs
  function sign(n) {
    if (n === 0)
      return 0;
    return n < 0 ? -1 : 1;
  }

  // node_modules/pixijs/utils/data/uid.mjs
  var nextUid = 0;
  function uid() {
    return ++nextUid;
  }

  // node_modules/pixijs/utils/media/BoundingBox.mjs
  var _BoundingBox = class {
    constructor(left, top, right, bottom) {
      this.left = left;
      this.top = top;
      this.right = right;
      this.bottom = bottom;
    }
    get width() {
      return this.right - this.left;
    }
    get height() {
      return this.bottom - this.top;
    }
    isEmpty() {
      return this.left === this.right || this.top === this.bottom;
    }
  };
  var BoundingBox = _BoundingBox;
  BoundingBox.EMPTY = new _BoundingBox(0, 0, 0, 0);

  // node_modules/pixijs/utils/media/caches.mjs
  var ProgramCache = {};
  var TextureCache = /* @__PURE__ */ Object.create(null);
  var BaseTextureCache = /* @__PURE__ */ Object.create(null);
  function destroyTextureCache() {
    let key;
    for (key in TextureCache) {
      TextureCache[key].destroy();
    }
    for (key in BaseTextureCache) {
      BaseTextureCache[key].destroy();
    }
  }
  function clearTextureCache() {
    let key;
    for (key in TextureCache) {
      delete TextureCache[key];
    }
    for (key in BaseTextureCache) {
      delete BaseTextureCache[key];
    }
  }

  // node_modules/pixijs/utils/media/CanvasRenderTarget.mjs
  var CanvasRenderTarget = class {
    constructor(width, height, resolution) {
      this._canvas = settings.ADAPTER.createCanvas();
      this._context = this._canvas.getContext("2d");
      this.resolution = resolution || settings.RESOLUTION;
      this.resize(width, height);
    }
    clear() {
      this._checkDestroyed();
      this._context.setTransform(1, 0, 0, 1, 0, 0);
      this._context.clearRect(0, 0, this._canvas.width, this._canvas.height);
    }
    resize(desiredWidth, desiredHeight) {
      this._checkDestroyed();
      this._canvas.width = Math.round(desiredWidth * this.resolution);
      this._canvas.height = Math.round(desiredHeight * this.resolution);
    }
    destroy() {
      this._context = null;
      this._canvas = null;
    }
    get width() {
      this._checkDestroyed();
      return this._canvas.width;
    }
    set width(val) {
      this._checkDestroyed();
      this._canvas.width = Math.round(val);
    }
    get height() {
      this._checkDestroyed();
      return this._canvas.height;
    }
    set height(val) {
      this._checkDestroyed();
      this._canvas.height = Math.round(val);
    }
    get canvas() {
      this._checkDestroyed();
      return this._canvas;
    }
    get context() {
      this._checkDestroyed();
      return this._context;
    }
    _checkDestroyed() {
      if (this._canvas === null) {
        throw new TypeError("The CanvasRenderTarget has already been destroyed");
      }
    }
  };

  // node_modules/pixijs/utils/media/getCanvasBoundingBox.mjs
  function checkRow(data, width, y3) {
    for (let x3 = 0, index2 = 4 * y3 * width; x3 < width; ++x3, index2 += 4) {
      if (data[index2 + 3] !== 0)
        return false;
    }
    return true;
  }
  function checkColumn(data, width, x3, top, bottom) {
    const stride = 4 * width;
    for (let y3 = top, index2 = top * stride + 4 * x3; y3 <= bottom; ++y3, index2 += stride) {
      if (data[index2 + 3] !== 0)
        return false;
    }
    return true;
  }
  function getCanvasBoundingBox(canvas) {
    const { width, height } = canvas;
    const context2 = canvas.getContext("2d", {
      willReadFrequently: true
    });
    if (context2 === null) {
      throw new TypeError("Failed to get canvas 2D context");
    }
    const imageData = context2.getImageData(0, 0, width, height);
    const data = imageData.data;
    let left = 0;
    let top = 0;
    let right = width - 1;
    let bottom = height - 1;
    while (top < height && checkRow(data, width, top))
      ++top;
    if (top === height)
      return BoundingBox.EMPTY;
    while (checkRow(data, width, bottom))
      --bottom;
    while (checkColumn(data, width, left, top, bottom))
      ++left;
    while (checkColumn(data, width, right, top, bottom))
      --right;
    ++right;
    ++bottom;
    return new BoundingBox(left, top, right, bottom);
  }

  // node_modules/pixijs/utils/media/trimCanvas.mjs
  function trimCanvas(canvas) {
    const boundingBox = getCanvasBoundingBox(canvas);
    const { width, height } = boundingBox;
    let data = null;
    if (!boundingBox.isEmpty()) {
      const context2 = canvas.getContext("2d");
      if (context2 === null) {
        throw new TypeError("Failed to get canvas 2D context");
      }
      data = context2.getImageData(boundingBox.left, boundingBox.top, width, height);
    }
    return { width, height, data };
  }

  // node_modules/pixijs/utils/network/decomposeDataUri.mjs
  function decomposeDataUri(dataUri) {
    const dataUriMatch = DATA_URI.exec(dataUri);
    if (dataUriMatch) {
      return {
        mediaType: dataUriMatch[1] ? dataUriMatch[1].toLowerCase() : void 0,
        subType: dataUriMatch[2] ? dataUriMatch[2].toLowerCase() : void 0,
        charset: dataUriMatch[3] ? dataUriMatch[3].toLowerCase() : void 0,
        encoding: dataUriMatch[4] ? dataUriMatch[4].toLowerCase() : void 0,
        data: dataUriMatch[5]
      };
    }
    return void 0;
  }

  // node_modules/pixijs/utils/network/determineCrossOrigin.mjs
  var tempAnchor;
  function determineCrossOrigin(url$1, loc = globalThis.location) {
    if (url$1.startsWith("data:")) {
      return "";
    }
    loc = loc || globalThis.location;
    if (!tempAnchor) {
      tempAnchor = document.createElement("a");
    }
    tempAnchor.href = url$1;
    const parsedUrl = url.parse(tempAnchor.href);
    const samePort = !parsedUrl.port && loc.port === "" || parsedUrl.port === loc.port;
    if (parsedUrl.hostname !== loc.hostname || !samePort || parsedUrl.protocol !== loc.protocol) {
      return "anonymous";
    }
    return "";
  }

  // node_modules/pixijs/utils/network/getResolutionOfUrl.mjs
  function getResolutionOfUrl(url2, defaultValue2 = 1) {
    var _a;
    const resolution = (_a = settings.RETINA_PREFIX) == null ? void 0 : _a.exec(url2);
    if (resolution) {
      return parseFloat(resolution[1]);
    }
    return defaultValue2;
  }

  // node_modules/pixijs/extensions/index.mjs
  var ExtensionType = /* @__PURE__ */ ((ExtensionType2) => {
    ExtensionType2["Renderer"] = "renderer";
    ExtensionType2["Application"] = "application";
    ExtensionType2["RendererSystem"] = "renderer-webgl-system";
    ExtensionType2["RendererPlugin"] = "renderer-webgl-plugin";
    ExtensionType2["CanvasRendererSystem"] = "renderer-canvas-system";
    ExtensionType2["CanvasRendererPlugin"] = "renderer-canvas-plugin";
    ExtensionType2["Asset"] = "asset";
    ExtensionType2["LoadParser"] = "load-parser";
    ExtensionType2["ResolveParser"] = "resolve-parser";
    ExtensionType2["CacheParser"] = "cache-parser";
    ExtensionType2["DetectionParser"] = "detection-parser";
    return ExtensionType2;
  })(ExtensionType || {});
  var normalizeExtension = (ext) => {
    if (typeof ext === "function" || typeof ext === "object" && ext.extension) {
      if (!ext.extension) {
        throw new Error("Extension class must have an extension object");
      }
      const metadata = typeof ext.extension !== "object" ? { type: ext.extension } : ext.extension;
      ext = __spreadProps(__spreadValues({}, metadata), { ref: ext });
    }
    if (typeof ext === "object") {
      ext = __spreadValues({}, ext);
    } else {
      throw new Error("Invalid extension type");
    }
    if (typeof ext.type === "string") {
      ext.type = [ext.type];
    }
    return ext;
  };
  var normalizePriority = (ext, defaultPriority) => {
    var _a;
    return (_a = normalizeExtension(ext).priority) != null ? _a : defaultPriority;
  };
  var extensions = {
    _addHandlers: {},
    _removeHandlers: {},
    _queue: {},
    remove(...extensions22) {
      extensions22.map(normalizeExtension).forEach((ext) => {
        ext.type.forEach((type2) => {
          var _a, _b;
          return (_b = (_a = this._removeHandlers)[type2]) == null ? void 0 : _b.call(_a, ext);
        });
      });
      return this;
    },
    add(...extensions22) {
      extensions22.map(normalizeExtension).forEach((ext) => {
        ext.type.forEach((type2) => {
          const handlers = this._addHandlers;
          const queue = this._queue;
          if (!handlers[type2]) {
            queue[type2] = queue[type2] || [];
            queue[type2].push(ext);
          } else {
            handlers[type2](ext);
          }
        });
      });
      return this;
    },
    handle(type2, onAdd2, onRemove2) {
      const addHandlers = this._addHandlers;
      const removeHandlers = this._removeHandlers;
      if (addHandlers[type2] || removeHandlers[type2]) {
        throw new Error(`Extension type ${type2} already has a handler`);
      }
      addHandlers[type2] = onAdd2;
      removeHandlers[type2] = onRemove2;
      const queue = this._queue;
      if (queue[type2]) {
        queue[type2].forEach((ext) => onAdd2(ext));
        delete queue[type2];
      }
      return this;
    },
    handleByMap(type2, map4) {
      return this.handle(type2, (extension) => {
        map4[extension.name] = extension.ref;
      }, (extension) => {
        delete map4[extension.name];
      });
    },
    handleByList(type2, list, defaultPriority = -1) {
      return this.handle(type2, (extension) => {
        if (list.includes(extension.ref)) {
          return;
        }
        list.push(extension.ref);
        list.sort((a2, b) => normalizePriority(b, defaultPriority) - normalizePriority(a2, defaultPriority));
      }, (extension) => {
        const index2 = list.indexOf(extension.ref);
        if (index2 !== -1) {
          list.splice(index2, 1);
        }
      });
    }
  };

  // node_modules/pixijs/core/geometry/ViewableBuffer.mjs
  var ViewableBuffer = class {
    constructor(sizeOrBuffer) {
      if (typeof sizeOrBuffer === "number") {
        this.rawBinaryData = new ArrayBuffer(sizeOrBuffer);
      } else if (sizeOrBuffer instanceof Uint8Array) {
        this.rawBinaryData = sizeOrBuffer.buffer;
      } else {
        this.rawBinaryData = sizeOrBuffer;
      }
      this.uint32View = new Uint32Array(this.rawBinaryData);
      this.float32View = new Float32Array(this.rawBinaryData);
    }
    get int8View() {
      if (!this._int8View) {
        this._int8View = new Int8Array(this.rawBinaryData);
      }
      return this._int8View;
    }
    get uint8View() {
      if (!this._uint8View) {
        this._uint8View = new Uint8Array(this.rawBinaryData);
      }
      return this._uint8View;
    }
    get int16View() {
      if (!this._int16View) {
        this._int16View = new Int16Array(this.rawBinaryData);
      }
      return this._int16View;
    }
    get uint16View() {
      if (!this._uint16View) {
        this._uint16View = new Uint16Array(this.rawBinaryData);
      }
      return this._uint16View;
    }
    get int32View() {
      if (!this._int32View) {
        this._int32View = new Int32Array(this.rawBinaryData);
      }
      return this._int32View;
    }
    view(type2) {
      return this[`${type2}View`];
    }
    destroy() {
      this.rawBinaryData = null;
      this._int8View = null;
      this._uint8View = null;
      this._int16View = null;
      this._uint16View = null;
      this._int32View = null;
      this.uint32View = null;
      this.float32View = null;
    }
    static sizeOf(type2) {
      switch (type2) {
        case "int8":
        case "uint8":
          return 1;
        case "int16":
        case "uint16":
          return 2;
        case "int32":
        case "uint32":
        case "float32":
          return 4;
        default:
          throw new Error(`${type2} isn't a valid view type`);
      }
    }
  };

  // node_modules/pixijs/core/shader/utils/checkMaxIfStatementsInShader.mjs
  var fragTemplate = [
    "precision mediump float;",
    "void main(void){",
    "float test = 0.1;",
    "%forloop%",
    "gl_FragColor = vec4(0.0);",
    "}"
  ].join("\n");
  function generateIfTestSrc(maxIfs) {
    let src = "";
    for (let i = 0; i < maxIfs; ++i) {
      if (i > 0) {
        src += "\nelse ";
      }
      if (i < maxIfs - 1) {
        src += `if(test == ${i}.0){}`;
      }
    }
    return src;
  }
  function checkMaxIfStatementsInShader(maxIfs, gl) {
    if (maxIfs === 0) {
      throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");
    }
    const shader = gl.createShader(gl.FRAGMENT_SHADER);
    while (true) {
      const fragmentSrc = fragTemplate.replace(/%forloop%/gi, generateIfTestSrc(maxIfs));
      gl.shaderSource(shader, fragmentSrc);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        maxIfs = maxIfs / 2 | 0;
      } else {
        break;
      }
    }
    return maxIfs;
  }

  // node_modules/pixijs/core/state/State.mjs
  var BLEND = 0;
  var OFFSET = 1;
  var CULLING = 2;
  var DEPTH_TEST = 3;
  var WINDING = 4;
  var DEPTH_MASK = 5;
  var State = class {
    constructor() {
      this.data = 0;
      this.blendMode = BLEND_MODES.NORMAL;
      this.polygonOffset = 0;
      this.blend = true;
      this.depthMask = true;
    }
    get blend() {
      return !!(this.data & 1 << BLEND);
    }
    set blend(value) {
      if (!!(this.data & 1 << BLEND) !== value) {
        this.data ^= 1 << BLEND;
      }
    }
    get offsets() {
      return !!(this.data & 1 << OFFSET);
    }
    set offsets(value) {
      if (!!(this.data & 1 << OFFSET) !== value) {
        this.data ^= 1 << OFFSET;
      }
    }
    get culling() {
      return !!(this.data & 1 << CULLING);
    }
    set culling(value) {
      if (!!(this.data & 1 << CULLING) !== value) {
        this.data ^= 1 << CULLING;
      }
    }
    get depthTest() {
      return !!(this.data & 1 << DEPTH_TEST);
    }
    set depthTest(value) {
      if (!!(this.data & 1 << DEPTH_TEST) !== value) {
        this.data ^= 1 << DEPTH_TEST;
      }
    }
    get depthMask() {
      return !!(this.data & 1 << DEPTH_MASK);
    }
    set depthMask(value) {
      if (!!(this.data & 1 << DEPTH_MASK) !== value) {
        this.data ^= 1 << DEPTH_MASK;
      }
    }
    get clockwiseFrontFace() {
      return !!(this.data & 1 << WINDING);
    }
    set clockwiseFrontFace(value) {
      if (!!(this.data & 1 << WINDING) !== value) {
        this.data ^= 1 << WINDING;
      }
    }
    get blendMode() {
      return this._blendMode;
    }
    set blendMode(value) {
      this.blend = value !== BLEND_MODES.NONE;
      this._blendMode = value;
    }
    get polygonOffset() {
      return this._polygonOffset;
    }
    set polygonOffset(value) {
      this.offsets = !!value;
      this._polygonOffset = value;
    }
    toString() {
      return `[pixijs/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`;
    }
    static for2d() {
      const state = new State();
      state.depthTest = false;
      state.blend = true;
      return state;
    }
  };

  // node_modules/pixijs/core/textures/resources/autoDetectResource.mjs
  var INSTALLED = [];
  function autoDetectResource(source, options) {
    if (!source) {
      return null;
    }
    let extension = "";
    if (typeof source === "string") {
      const result = /\.(\w{3,4})(?:$|\?|#)/i.exec(source);
      if (result) {
        extension = result[1].toLowerCase();
      }
    }
    for (let i = INSTALLED.length - 1; i >= 0; --i) {
      const ResourcePlugin = INSTALLED[i];
      if (ResourcePlugin.test && ResourcePlugin.test(source, extension)) {
        return new ResourcePlugin(source, options);
      }
    }
    throw new Error("Unrecognized source type to auto-detect Resource");
  }

  // node_modules/pixijs/runner/Runner.mjs
  var Runner = class {
    constructor(name) {
      this.items = [];
      this._name = name;
      this._aliasCount = 0;
    }
    emit(a0, a1, a2, a3, a4, a5, a6, a7) {
      if (arguments.length > 8) {
        throw new Error("max arguments reached");
      }
      const { name, items } = this;
      this._aliasCount++;
      for (let i = 0, len = items.length; i < len; i++) {
        items[i][name](a0, a1, a2, a3, a4, a5, a6, a7);
      }
      if (items === this.items) {
        this._aliasCount--;
      }
      return this;
    }
    ensureNonAliasedItems() {
      if (this._aliasCount > 0 && this.items.length > 1) {
        this._aliasCount = 0;
        this.items = this.items.slice(0);
      }
    }
    add(item) {
      if (item[this._name]) {
        this.ensureNonAliasedItems();
        this.remove(item);
        this.items.push(item);
      }
      return this;
    }
    remove(item) {
      const index2 = this.items.indexOf(item);
      if (index2 !== -1) {
        this.ensureNonAliasedItems();
        this.items.splice(index2, 1);
      }
      return this;
    }
    contains(item) {
      return this.items.includes(item);
    }
    removeAll() {
      this.ensureNonAliasedItems();
      this.items.length = 0;
      return this;
    }
    destroy() {
      this.removeAll();
      this.items = null;
      this._name = null;
    }
    get empty() {
      return this.items.length === 0;
    }
    get name() {
      return this._name;
    }
  };
  Object.defineProperties(Runner.prototype, {
    dispatch: { value: Runner.prototype.emit },
    run: { value: Runner.prototype.emit }
  });

  // node_modules/pixijs/core/textures/resources/Resource.mjs
  var Resource = class {
    constructor(width = 0, height = 0) {
      this._width = width;
      this._height = height;
      this.destroyed = false;
      this.internal = false;
      this.onResize = new Runner("setRealSize");
      this.onUpdate = new Runner("update");
      this.onError = new Runner("onError");
    }
    bind(baseTexture) {
      this.onResize.add(baseTexture);
      this.onUpdate.add(baseTexture);
      this.onError.add(baseTexture);
      if (this._width || this._height) {
        this.onResize.emit(this._width, this._height);
      }
    }
    unbind(baseTexture) {
      this.onResize.remove(baseTexture);
      this.onUpdate.remove(baseTexture);
      this.onError.remove(baseTexture);
    }
    resize(width, height) {
      if (width !== this._width || height !== this._height) {
        this._width = width;
        this._height = height;
        this.onResize.emit(width, height);
      }
    }
    get valid() {
      return !!this._width && !!this._height;
    }
    update() {
      if (!this.destroyed) {
        this.onUpdate.emit();
      }
    }
    load() {
      return Promise.resolve(this);
    }
    get width() {
      return this._width;
    }
    get height() {
      return this._height;
    }
    style(_renderer, _baseTexture, _glTexture) {
      return false;
    }
    dispose() {
    }
    destroy() {
      if (!this.destroyed) {
        this.destroyed = true;
        this.dispose();
        this.onError.removeAll();
        this.onError = null;
        this.onResize.removeAll();
        this.onResize = null;
        this.onUpdate.removeAll();
        this.onUpdate = null;
      }
    }
    static test(_source, _extension) {
      return false;
    }
  };

  // node_modules/pixijs/core/textures/resources/BufferResource.mjs
  var BufferResource = class extends Resource {
    constructor(source, options) {
      const { width, height } = options || {};
      if (!width || !height) {
        throw new Error("BufferResource width or height invalid");
      }
      super(width, height);
      this.data = source;
    }
    upload(renderer, baseTexture, glTexture) {
      const gl = renderer.gl;
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.alphaMode === ALPHA_MODES.UNPACK);
      const width = baseTexture.realWidth;
      const height = baseTexture.realHeight;
      if (glTexture.width === width && glTexture.height === height) {
        gl.texSubImage2D(baseTexture.target, 0, 0, 0, width, height, baseTexture.format, glTexture.type, this.data);
      } else {
        glTexture.width = width;
        glTexture.height = height;
        gl.texImage2D(baseTexture.target, 0, glTexture.internalFormat, width, height, 0, baseTexture.format, glTexture.type, this.data);
      }
      return true;
    }
    dispose() {
      this.data = null;
    }
    static test(source) {
      return source instanceof Float32Array || source instanceof Uint8Array || source instanceof Uint32Array;
    }
  };

  // node_modules/pixijs/core/textures/BaseTexture.mjs
  var defaultBufferOptions = {
    scaleMode: SCALE_MODES.NEAREST,
    format: FORMATS.RGBA,
    alphaMode: ALPHA_MODES.NPM
  };
  var _BaseTexture = class extends import_eventemitter3.default {
    constructor(resource = null, options = null) {
      super();
      options = Object.assign({}, _BaseTexture.defaultOptions, options);
      const {
        alphaMode,
        mipmap,
        anisotropicLevel,
        scaleMode,
        width,
        height,
        wrapMode,
        format: format2,
        type: type2,
        target,
        resolution,
        resourceOptions
      } = options;
      if (resource && !(resource instanceof Resource)) {
        resource = autoDetectResource(resource, resourceOptions);
        resource.internal = true;
      }
      this.resolution = resolution || settings.RESOLUTION;
      this.width = Math.round((width || 0) * this.resolution) / this.resolution;
      this.height = Math.round((height || 0) * this.resolution) / this.resolution;
      this._mipmap = mipmap;
      this.anisotropicLevel = anisotropicLevel;
      this._wrapMode = wrapMode;
      this._scaleMode = scaleMode;
      this.format = format2;
      this.type = type2;
      this.target = target;
      this.alphaMode = alphaMode;
      this.uid = uid();
      this.touched = 0;
      this.isPowerOfTwo = false;
      this._refreshPOT();
      this._glTextures = {};
      this.dirtyId = 0;
      this.dirtyStyleId = 0;
      this.cacheId = null;
      this.valid = width > 0 && height > 0;
      this.textureCacheIds = [];
      this.destroyed = false;
      this.resource = null;
      this._batchEnabled = 0;
      this._batchLocation = 0;
      this.parentTextureArray = null;
      this.setResource(resource);
    }
    get realWidth() {
      return Math.round(this.width * this.resolution);
    }
    get realHeight() {
      return Math.round(this.height * this.resolution);
    }
    get mipmap() {
      return this._mipmap;
    }
    set mipmap(value) {
      if (this._mipmap !== value) {
        this._mipmap = value;
        this.dirtyStyleId++;
      }
    }
    get scaleMode() {
      return this._scaleMode;
    }
    set scaleMode(value) {
      if (this._scaleMode !== value) {
        this._scaleMode = value;
        this.dirtyStyleId++;
      }
    }
    get wrapMode() {
      return this._wrapMode;
    }
    set wrapMode(value) {
      if (this._wrapMode !== value) {
        this._wrapMode = value;
        this.dirtyStyleId++;
      }
    }
    setStyle(scaleMode, mipmap) {
      let dirty;
      if (scaleMode !== void 0 && scaleMode !== this.scaleMode) {
        this.scaleMode = scaleMode;
        dirty = true;
      }
      if (mipmap !== void 0 && mipmap !== this.mipmap) {
        this.mipmap = mipmap;
        dirty = true;
      }
      if (dirty) {
        this.dirtyStyleId++;
      }
      return this;
    }
    setSize(desiredWidth, desiredHeight, resolution) {
      resolution = resolution || this.resolution;
      return this.setRealSize(desiredWidth * resolution, desiredHeight * resolution, resolution);
    }
    setRealSize(realWidth, realHeight, resolution) {
      this.resolution = resolution || this.resolution;
      this.width = Math.round(realWidth) / this.resolution;
      this.height = Math.round(realHeight) / this.resolution;
      this._refreshPOT();
      this.update();
      return this;
    }
    _refreshPOT() {
      this.isPowerOfTwo = isPow2(this.realWidth) && isPow2(this.realHeight);
    }
    setResolution(resolution) {
      const oldResolution = this.resolution;
      if (oldResolution === resolution) {
        return this;
      }
      this.resolution = resolution;
      if (this.valid) {
        this.width = Math.round(this.width * oldResolution) / resolution;
        this.height = Math.round(this.height * oldResolution) / resolution;
        this.emit("update", this);
      }
      this._refreshPOT();
      return this;
    }
    setResource(resource) {
      if (this.resource === resource) {
        return this;
      }
      if (this.resource) {
        throw new Error("Resource can be set only once");
      }
      resource.bind(this);
      this.resource = resource;
      return this;
    }
    update() {
      if (!this.valid) {
        if (this.width > 0 && this.height > 0) {
          this.valid = true;
          this.emit("loaded", this);
          this.emit("update", this);
        }
      } else {
        this.dirtyId++;
        this.dirtyStyleId++;
        this.emit("update", this);
      }
    }
    onError(event) {
      this.emit("error", this, event);
    }
    destroy() {
      if (this.resource) {
        this.resource.unbind(this);
        if (this.resource.internal) {
          this.resource.destroy();
        }
        this.resource = null;
      }
      if (this.cacheId) {
        delete BaseTextureCache[this.cacheId];
        delete TextureCache[this.cacheId];
        this.cacheId = null;
      }
      this.dispose();
      _BaseTexture.removeFromCache(this);
      this.textureCacheIds = null;
      this.destroyed = true;
    }
    dispose() {
      this.emit("dispose", this);
    }
    castToBaseTexture() {
      return this;
    }
    static from(source, options, strict = settings.STRICT_TEXTURE_CACHE) {
      const isFrame = typeof source === "string";
      let cacheId = null;
      if (isFrame) {
        cacheId = source;
      } else {
        if (!source._pixiId) {
          const prefix = (options == null ? void 0 : options.pixiIdPrefix) || "pixiid";
          source._pixiId = `${prefix}_${uid()}`;
        }
        cacheId = source._pixiId;
      }
      let baseTexture = BaseTextureCache[cacheId];
      if (isFrame && strict && !baseTexture) {
        throw new Error(`The cacheId "${cacheId}" does not exist in BaseTextureCache.`);
      }
      if (!baseTexture) {
        baseTexture = new _BaseTexture(source, options);
        baseTexture.cacheId = cacheId;
        _BaseTexture.addToCache(baseTexture, cacheId);
      }
      return baseTexture;
    }
    static fromBuffer(buffer, width, height, options) {
      buffer = buffer || new Float32Array(width * height * 4);
      const resource = new BufferResource(buffer, { width, height });
      const type2 = buffer instanceof Float32Array ? TYPES.FLOAT : TYPES.UNSIGNED_BYTE;
      return new _BaseTexture(resource, Object.assign({}, defaultBufferOptions, options || { width, height, type: type2 }));
    }
    static addToCache(baseTexture, id2) {
      if (id2) {
        if (!baseTexture.textureCacheIds.includes(id2)) {
          baseTexture.textureCacheIds.push(id2);
        }
        if (BaseTextureCache[id2] && BaseTextureCache[id2] !== baseTexture) {
          console.warn(`BaseTexture added to the cache with an id [${id2}] that already had an entry`);
        }
        BaseTextureCache[id2] = baseTexture;
      }
    }
    static removeFromCache(baseTexture) {
      if (typeof baseTexture === "string") {
        const baseTextureFromCache = BaseTextureCache[baseTexture];
        if (baseTextureFromCache) {
          const index2 = baseTextureFromCache.textureCacheIds.indexOf(baseTexture);
          if (index2 > -1) {
            baseTextureFromCache.textureCacheIds.splice(index2, 1);
          }
          delete BaseTextureCache[baseTexture];
          return baseTextureFromCache;
        }
      } else if (baseTexture == null ? void 0 : baseTexture.textureCacheIds) {
        for (let i = 0; i < baseTexture.textureCacheIds.length; ++i) {
          delete BaseTextureCache[baseTexture.textureCacheIds[i]];
        }
        baseTexture.textureCacheIds.length = 0;
        return baseTexture;
      }
      return null;
    }
  };
  var BaseTexture = _BaseTexture;
  BaseTexture.defaultOptions = {
    mipmap: MIPMAP_MODES.POW2,
    anisotropicLevel: 0,
    scaleMode: SCALE_MODES.LINEAR,
    wrapMode: WRAP_MODES.CLAMP,
    alphaMode: ALPHA_MODES.UNPACK,
    target: TARGETS.TEXTURE_2D,
    format: FORMATS.RGBA,
    type: TYPES.UNSIGNED_BYTE
  };
  BaseTexture._globalBatch = 0;

  // node_modules/pixijs/core/batch/BatchDrawCall.mjs
  var BatchDrawCall = class {
    constructor() {
      this.texArray = null;
      this.blend = 0;
      this.type = DRAW_MODES.TRIANGLES;
      this.start = 0;
      this.size = 0;
      this.data = null;
    }
  };

  // node_modules/pixijs/core/geometry/Buffer.mjs
  var UID = 0;
  var Buffer2 = class {
    constructor(data, _static = true, index2 = false) {
      this.data = data || new Float32Array(1);
      this._glBuffers = {};
      this._updateID = 0;
      this.index = index2;
      this.static = _static;
      this.id = UID++;
      this.disposeRunner = new Runner("disposeBuffer");
    }
    update(data) {
      if (data instanceof Array) {
        data = new Float32Array(data);
      }
      this.data = data || this.data;
      this._updateID++;
    }
    dispose() {
      this.disposeRunner.emit(this, false);
    }
    destroy() {
      this.dispose();
      this.data = null;
    }
    set index(value) {
      this.type = value ? BUFFER_TYPE.ELEMENT_ARRAY_BUFFER : BUFFER_TYPE.ARRAY_BUFFER;
    }
    get index() {
      return this.type === BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;
    }
    static from(data) {
      if (data instanceof Array) {
        data = new Float32Array(data);
      }
      return new Buffer2(data);
    }
  };

  // node_modules/pixijs/core/geometry/Attribute.mjs
  var Attribute = class {
    constructor(buffer, size = 0, normalized = false, type2 = TYPES.FLOAT, stride, start2, instance, divisor = 1) {
      this.buffer = buffer;
      this.size = size;
      this.normalized = normalized;
      this.type = type2;
      this.stride = stride;
      this.start = start2;
      this.instance = instance;
      this.divisor = divisor;
    }
    destroy() {
      this.buffer = null;
    }
    static from(buffer, size, normalized, type2, stride) {
      return new Attribute(buffer, size, normalized, type2, stride);
    }
  };

  // node_modules/pixijs/core/geometry/utils/interleaveTypedArrays.mjs
  var map2 = {
    Float32Array,
    Uint32Array,
    Int32Array,
    Uint8Array
  };
  function interleaveTypedArrays2(arrays, sizes) {
    let outSize = 0;
    let stride = 0;
    const views = {};
    for (let i = 0; i < arrays.length; i++) {
      stride += sizes[i];
      outSize += arrays[i].length;
    }
    const buffer = new ArrayBuffer(outSize * 4);
    let out = null;
    let littleOffset = 0;
    for (let i = 0; i < arrays.length; i++) {
      const size = sizes[i];
      const array2 = arrays[i];
      const type2 = getBufferType(array2);
      if (!views[type2]) {
        views[type2] = new map2[type2](buffer);
      }
      out = views[type2];
      for (let j = 0; j < array2.length; j++) {
        const indexStart = (j / size | 0) * stride + littleOffset;
        const index2 = j % size;
        out[indexStart + index2] = array2[j];
      }
      littleOffset += size;
    }
    return new Float32Array(buffer);
  }

  // node_modules/pixijs/core/geometry/Geometry.mjs
  var byteSizeMap = { 5126: 4, 5123: 2, 5121: 1 };
  var UID2 = 0;
  var map3 = {
    Float32Array,
    Uint32Array,
    Int32Array,
    Uint8Array,
    Uint16Array
  };
  var Geometry = class {
    constructor(buffers = [], attributes = {}) {
      this.buffers = buffers;
      this.indexBuffer = null;
      this.attributes = attributes;
      this.glVertexArrayObjects = {};
      this.id = UID2++;
      this.instanced = false;
      this.instanceCount = 1;
      this.disposeRunner = new Runner("disposeGeometry");
      this.refCount = 0;
    }
    addAttribute(id2, buffer, size = 0, normalized = false, type2, stride, start2, instance = false) {
      if (!buffer) {
        throw new Error("You must pass a buffer when creating an attribute");
      }
      if (!(buffer instanceof Buffer2)) {
        if (buffer instanceof Array) {
          buffer = new Float32Array(buffer);
        }
        buffer = new Buffer2(buffer);
      }
      const ids = id2.split("|");
      if (ids.length > 1) {
        for (let i = 0; i < ids.length; i++) {
          this.addAttribute(ids[i], buffer, size, normalized, type2);
        }
        return this;
      }
      let bufferIndex = this.buffers.indexOf(buffer);
      if (bufferIndex === -1) {
        this.buffers.push(buffer);
        bufferIndex = this.buffers.length - 1;
      }
      this.attributes[id2] = new Attribute(bufferIndex, size, normalized, type2, stride, start2, instance);
      this.instanced = this.instanced || instance;
      return this;
    }
    getAttribute(id2) {
      return this.attributes[id2];
    }
    getBuffer(id2) {
      return this.buffers[this.getAttribute(id2).buffer];
    }
    addIndex(buffer) {
      if (!(buffer instanceof Buffer2)) {
        if (buffer instanceof Array) {
          buffer = new Uint16Array(buffer);
        }
        buffer = new Buffer2(buffer);
      }
      buffer.type = BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;
      this.indexBuffer = buffer;
      if (!this.buffers.includes(buffer)) {
        this.buffers.push(buffer);
      }
      return this;
    }
    getIndex() {
      return this.indexBuffer;
    }
    interleave() {
      if (this.buffers.length === 1 || this.buffers.length === 2 && this.indexBuffer)
        return this;
      const arrays = [];
      const sizes = [];
      const interleavedBuffer = new Buffer2();
      let i;
      for (i in this.attributes) {
        const attribute = this.attributes[i];
        const buffer = this.buffers[attribute.buffer];
        arrays.push(buffer.data);
        sizes.push(attribute.size * byteSizeMap[attribute.type] / 4);
        attribute.buffer = 0;
      }
      interleavedBuffer.data = interleaveTypedArrays2(arrays, sizes);
      for (i = 0; i < this.buffers.length; i++) {
        if (this.buffers[i] !== this.indexBuffer) {
          this.buffers[i].destroy();
        }
      }
      this.buffers = [interleavedBuffer];
      if (this.indexBuffer) {
        this.buffers.push(this.indexBuffer);
      }
      return this;
    }
    getSize() {
      for (const i in this.attributes) {
        const attribute = this.attributes[i];
        const buffer = this.buffers[attribute.buffer];
        return buffer.data.length / (attribute.stride / 4 || attribute.size);
      }
      return 0;
    }
    dispose() {
      this.disposeRunner.emit(this, false);
    }
    destroy() {
      this.dispose();
      this.buffers = null;
      this.indexBuffer = null;
      this.attributes = null;
    }
    clone() {
      const geometry = new Geometry();
      for (let i = 0; i < this.buffers.length; i++) {
        geometry.buffers[i] = new Buffer2(this.buffers[i].data.slice(0));
      }
      for (const i in this.attributes) {
        const attrib = this.attributes[i];
        geometry.attributes[i] = new Attribute(attrib.buffer, attrib.size, attrib.normalized, attrib.type, attrib.stride, attrib.start, attrib.instance);
      }
      if (this.indexBuffer) {
        geometry.indexBuffer = geometry.buffers[this.buffers.indexOf(this.indexBuffer)];
        geometry.indexBuffer.type = BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;
      }
      return geometry;
    }
    static merge(geometries) {
      const geometryOut = new Geometry();
      const arrays = [];
      const sizes = [];
      const offsets = [];
      let geometry;
      for (let i = 0; i < geometries.length; i++) {
        geometry = geometries[i];
        for (let j = 0; j < geometry.buffers.length; j++) {
          sizes[j] = sizes[j] || 0;
          sizes[j] += geometry.buffers[j].data.length;
          offsets[j] = 0;
        }
      }
      for (let i = 0; i < geometry.buffers.length; i++) {
        arrays[i] = new map3[getBufferType(geometry.buffers[i].data)](sizes[i]);
        geometryOut.buffers[i] = new Buffer2(arrays[i]);
      }
      for (let i = 0; i < geometries.length; i++) {
        geometry = geometries[i];
        for (let j = 0; j < geometry.buffers.length; j++) {
          arrays[j].set(geometry.buffers[j].data, offsets[j]);
          offsets[j] += geometry.buffers[j].data.length;
        }
      }
      geometryOut.attributes = geometry.attributes;
      if (geometry.indexBuffer) {
        geometryOut.indexBuffer = geometryOut.buffers[geometry.buffers.indexOf(geometry.indexBuffer)];
        geometryOut.indexBuffer.type = BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;
        let offset = 0;
        let stride = 0;
        let offset2 = 0;
        let bufferIndexToCount = 0;
        for (let i = 0; i < geometry.buffers.length; i++) {
          if (geometry.buffers[i] !== geometry.indexBuffer) {
            bufferIndexToCount = i;
            break;
          }
        }
        for (const i in geometry.attributes) {
          const attribute = geometry.attributes[i];
          if ((attribute.buffer | 0) === bufferIndexToCount) {
            stride += attribute.size * byteSizeMap[attribute.type] / 4;
          }
        }
        for (let i = 0; i < geometries.length; i++) {
          const indexBufferData = geometries[i].indexBuffer.data;
          for (let j = 0; j < indexBufferData.length; j++) {
            geometryOut.indexBuffer.data[j + offset2] += offset;
          }
          offset += geometries[i].buffers[bufferIndexToCount].data.length / stride;
          offset2 += indexBufferData.length;
        }
      }
      return geometryOut;
    }
  };

  // node_modules/pixijs/core/batch/BatchGeometry.mjs
  var BatchGeometry = class extends Geometry {
    constructor(_static = false) {
      super();
      this._buffer = new Buffer2(null, _static, false);
      this._indexBuffer = new Buffer2(null, _static, true);
      this.addAttribute("aVertexPosition", this._buffer, 2, false, TYPES.FLOAT).addAttribute("aTextureCoord", this._buffer, 2, false, TYPES.FLOAT).addAttribute("aColor", this._buffer, 4, true, TYPES.UNSIGNED_BYTE).addAttribute("aTextureId", this._buffer, 1, true, TYPES.FLOAT).addIndex(this._indexBuffer);
    }
  };

  // node_modules/pixijs/math/const.mjs
  var PI_2 = Math.PI * 2;
  var RAD_TO_DEG = 180 / Math.PI;
  var DEG_TO_RAD = Math.PI / 180;
  var SHAPES = /* @__PURE__ */ ((SHAPES2) => {
    SHAPES2[SHAPES2["POLY"] = 0] = "POLY";
    SHAPES2[SHAPES2["RECT"] = 1] = "RECT";
    SHAPES2[SHAPES2["CIRC"] = 2] = "CIRC";
    SHAPES2[SHAPES2["ELIP"] = 3] = "ELIP";
    SHAPES2[SHAPES2["RREC"] = 4] = "RREC";
    return SHAPES2;
  })(SHAPES || {});

  // node_modules/pixijs/math/Point.mjs
  var Point = class {
    constructor(x3 = 0, y3 = 0) {
      this.x = 0;
      this.y = 0;
      this.x = x3;
      this.y = y3;
    }
    clone() {
      return new Point(this.x, this.y);
    }
    copyFrom(p) {
      this.set(p.x, p.y);
      return this;
    }
    copyTo(p) {
      p.set(this.x, this.y);
      return p;
    }
    equals(p) {
      return p.x === this.x && p.y === this.y;
    }
    set(x3 = 0, y3 = x3) {
      this.x = x3;
      this.y = y3;
      return this;
    }
    toString() {
      return `[pixijs/math:Point x=${this.x} y=${this.y}]`;
    }
  };

  // node_modules/pixijs/math/shapes/Rectangle.mjs
  var tempPoints = [new Point(), new Point(), new Point(), new Point()];
  var Rectangle = class {
    constructor(x3 = 0, y3 = 0, width = 0, height = 0) {
      this.x = Number(x3);
      this.y = Number(y3);
      this.width = Number(width);
      this.height = Number(height);
      this.type = SHAPES.RECT;
    }
    get left() {
      return this.x;
    }
    get right() {
      return this.x + this.width;
    }
    get top() {
      return this.y;
    }
    get bottom() {
      return this.y + this.height;
    }
    static get EMPTY() {
      return new Rectangle(0, 0, 0, 0);
    }
    clone() {
      return new Rectangle(this.x, this.y, this.width, this.height);
    }
    copyFrom(rectangle) {
      this.x = rectangle.x;
      this.y = rectangle.y;
      this.width = rectangle.width;
      this.height = rectangle.height;
      return this;
    }
    copyTo(rectangle) {
      rectangle.x = this.x;
      rectangle.y = this.y;
      rectangle.width = this.width;
      rectangle.height = this.height;
      return rectangle;
    }
    contains(x3, y3) {
      if (this.width <= 0 || this.height <= 0) {
        return false;
      }
      if (x3 >= this.x && x3 < this.x + this.width) {
        if (y3 >= this.y && y3 < this.y + this.height) {
          return true;
        }
      }
      return false;
    }
    intersects(other, transform2) {
      if (!transform2) {
        const x02 = this.x < other.x ? other.x : this.x;
        const x12 = this.right > other.right ? other.right : this.right;
        if (x12 <= x02) {
          return false;
        }
        const y02 = this.y < other.y ? other.y : this.y;
        const y12 = this.bottom > other.bottom ? other.bottom : this.bottom;
        return y12 > y02;
      }
      const x0 = this.left;
      const x1 = this.right;
      const y0 = this.top;
      const y1 = this.bottom;
      if (x1 <= x0 || y1 <= y0) {
        return false;
      }
      const lt = tempPoints[0].set(other.left, other.top);
      const lb = tempPoints[1].set(other.left, other.bottom);
      const rt = tempPoints[2].set(other.right, other.top);
      const rb = tempPoints[3].set(other.right, other.bottom);
      if (rt.x <= lt.x || lb.y <= lt.y) {
        return false;
      }
      const s = Math.sign(transform2.a * transform2.d - transform2.b * transform2.c);
      if (s === 0) {
        return false;
      }
      transform2.apply(lt, lt);
      transform2.apply(lb, lb);
      transform2.apply(rt, rt);
      transform2.apply(rb, rb);
      if (Math.max(lt.x, lb.x, rt.x, rb.x) <= x0 || Math.min(lt.x, lb.x, rt.x, rb.x) >= x1 || Math.max(lt.y, lb.y, rt.y, rb.y) <= y0 || Math.min(lt.y, lb.y, rt.y, rb.y) >= y1) {
        return false;
      }
      const nx = s * (lb.y - lt.y);
      const ny = s * (lt.x - lb.x);
      const n00 = nx * x0 + ny * y0;
      const n10 = nx * x1 + ny * y0;
      const n01 = nx * x0 + ny * y1;
      const n11 = nx * x1 + ny * y1;
      if (Math.max(n00, n10, n01, n11) <= nx * lt.x + ny * lt.y || Math.min(n00, n10, n01, n11) >= nx * rb.x + ny * rb.y) {
        return false;
      }
      const mx = s * (lt.y - rt.y);
      const my = s * (rt.x - lt.x);
      const m00 = mx * x0 + my * y0;
      const m10 = mx * x1 + my * y0;
      const m01 = mx * x0 + my * y1;
      const m11 = mx * x1 + my * y1;
      if (Math.max(m00, m10, m01, m11) <= mx * lt.x + my * lt.y || Math.min(m00, m10, m01, m11) >= mx * rb.x + my * rb.y) {
        return false;
      }
      return true;
    }
    pad(paddingX = 0, paddingY = paddingX) {
      this.x -= paddingX;
      this.y -= paddingY;
      this.width += paddingX * 2;
      this.height += paddingY * 2;
      return this;
    }
    fit(rectangle) {
      const x1 = Math.max(this.x, rectangle.x);
      const x22 = Math.min(this.x + this.width, rectangle.x + rectangle.width);
      const y1 = Math.max(this.y, rectangle.y);
      const y22 = Math.min(this.y + this.height, rectangle.y + rectangle.height);
      this.x = x1;
      this.width = Math.max(x22 - x1, 0);
      this.y = y1;
      this.height = Math.max(y22 - y1, 0);
      return this;
    }
    ceil(resolution = 1, eps = 1e-3) {
      const x22 = Math.ceil((this.x + this.width - eps) * resolution) / resolution;
      const y22 = Math.ceil((this.y + this.height - eps) * resolution) / resolution;
      this.x = Math.floor((this.x + eps) * resolution) / resolution;
      this.y = Math.floor((this.y + eps) * resolution) / resolution;
      this.width = x22 - this.x;
      this.height = y22 - this.y;
      return this;
    }
    enlarge(rectangle) {
      const x1 = Math.min(this.x, rectangle.x);
      const x22 = Math.max(this.x + this.width, rectangle.x + rectangle.width);
      const y1 = Math.min(this.y, rectangle.y);
      const y22 = Math.max(this.y + this.height, rectangle.y + rectangle.height);
      this.x = x1;
      this.width = x22 - x1;
      this.y = y1;
      this.height = y22 - y1;
      return this;
    }
    toString() {
      return `[pixijs/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;
    }
  };

  // node_modules/pixijs/math/shapes/Circle.mjs
  var Circle = class {
    constructor(x3 = 0, y3 = 0, radius = 0) {
      this.x = x3;
      this.y = y3;
      this.radius = radius;
      this.type = SHAPES.CIRC;
    }
    clone() {
      return new Circle(this.x, this.y, this.radius);
    }
    contains(x3, y3) {
      if (this.radius <= 0) {
        return false;
      }
      const r2 = this.radius * this.radius;
      let dx = this.x - x3;
      let dy = this.y - y3;
      dx *= dx;
      dy *= dy;
      return dx + dy <= r2;
    }
    getBounds() {
      return new Rectangle(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);
    }
    toString() {
      return `[pixijs/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`;
    }
  };

  // node_modules/pixijs/math/shapes/Ellipse.mjs
  var Ellipse = class {
    constructor(x3 = 0, y3 = 0, halfWidth = 0, halfHeight = 0) {
      this.x = x3;
      this.y = y3;
      this.width = halfWidth;
      this.height = halfHeight;
      this.type = SHAPES.ELIP;
    }
    clone() {
      return new Ellipse(this.x, this.y, this.width, this.height);
    }
    contains(x3, y3) {
      if (this.width <= 0 || this.height <= 0) {
        return false;
      }
      let normx = (x3 - this.x) / this.width;
      let normy = (y3 - this.y) / this.height;
      normx *= normx;
      normy *= normy;
      return normx + normy <= 1;
    }
    getBounds() {
      return new Rectangle(this.x - this.width, this.y - this.height, this.width, this.height);
    }
    toString() {
      return `[pixijs/math:Ellipse x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;
    }
  };

  // node_modules/pixijs/math/shapes/Polygon.mjs
  var Polygon = class {
    constructor(...points) {
      let flat = Array.isArray(points[0]) ? points[0] : points;
      if (typeof flat[0] !== "number") {
        const p = [];
        for (let i = 0, il = flat.length; i < il; i++) {
          p.push(flat[i].x, flat[i].y);
        }
        flat = p;
      }
      this.points = flat;
      this.type = SHAPES.POLY;
      this.closeStroke = true;
    }
    clone() {
      const points = this.points.slice();
      const polygon = new Polygon(points);
      polygon.closeStroke = this.closeStroke;
      return polygon;
    }
    contains(x3, y3) {
      let inside = false;
      const length = this.points.length / 2;
      for (let i = 0, j = length - 1; i < length; j = i++) {
        const xi = this.points[i * 2];
        const yi = this.points[i * 2 + 1];
        const xj = this.points[j * 2];
        const yj = this.points[j * 2 + 1];
        const intersect = yi > y3 !== yj > y3 && x3 < (xj - xi) * ((y3 - yi) / (yj - yi)) + xi;
        if (intersect) {
          inside = !inside;
        }
      }
      return inside;
    }
    toString() {
      return `[pixijs/math:PolygoncloseStroke=${this.closeStroke}points=${this.points.reduce((pointsDesc, currentPoint) => `${pointsDesc}, ${currentPoint}`, "")}]`;
    }
  };

  // node_modules/pixijs/math/shapes/RoundedRectangle.mjs
  var RoundedRectangle = class {
    constructor(x3 = 0, y3 = 0, width = 0, height = 0, radius = 20) {
      this.x = x3;
      this.y = y3;
      this.width = width;
      this.height = height;
      this.radius = radius;
      this.type = SHAPES.RREC;
    }
    clone() {
      return new RoundedRectangle(this.x, this.y, this.width, this.height, this.radius);
    }
    contains(x3, y3) {
      if (this.width <= 0 || this.height <= 0) {
        return false;
      }
      if (x3 >= this.x && x3 <= this.x + this.width) {
        if (y3 >= this.y && y3 <= this.y + this.height) {
          const radius = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));
          if (y3 >= this.y + radius && y3 <= this.y + this.height - radius || x3 >= this.x + radius && x3 <= this.x + this.width - radius) {
            return true;
          }
          let dx = x3 - (this.x + radius);
          let dy = y3 - (this.y + radius);
          const radius2 = radius * radius;
          if (dx * dx + dy * dy <= radius2) {
            return true;
          }
          dx = x3 - (this.x + this.width - radius);
          if (dx * dx + dy * dy <= radius2) {
            return true;
          }
          dy = y3 - (this.y + this.height - radius);
          if (dx * dx + dy * dy <= radius2) {
            return true;
          }
          dx = x3 - (this.x + radius);
          if (dx * dx + dy * dy <= radius2) {
            return true;
          }
        }
      }
      return false;
    }
    toString() {
      return `[pixijs/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`;
    }
  };

  // node_modules/pixijs/math/Matrix.mjs
  var Matrix = class {
    constructor(a2 = 1, b = 0, c2 = 0, d = 1, tx = 0, ty = 0) {
      this.array = null;
      this.a = a2;
      this.b = b;
      this.c = c2;
      this.d = d;
      this.tx = tx;
      this.ty = ty;
    }
    fromArray(array2) {
      this.a = array2[0];
      this.b = array2[1];
      this.c = array2[3];
      this.d = array2[4];
      this.tx = array2[2];
      this.ty = array2[5];
    }
    set(a2, b, c2, d, tx, ty) {
      this.a = a2;
      this.b = b;
      this.c = c2;
      this.d = d;
      this.tx = tx;
      this.ty = ty;
      return this;
    }
    toArray(transpose, out) {
      if (!this.array) {
        this.array = new Float32Array(9);
      }
      const array2 = out || this.array;
      if (transpose) {
        array2[0] = this.a;
        array2[1] = this.b;
        array2[2] = 0;
        array2[3] = this.c;
        array2[4] = this.d;
        array2[5] = 0;
        array2[6] = this.tx;
        array2[7] = this.ty;
        array2[8] = 1;
      } else {
        array2[0] = this.a;
        array2[1] = this.c;
        array2[2] = this.tx;
        array2[3] = this.b;
        array2[4] = this.d;
        array2[5] = this.ty;
        array2[6] = 0;
        array2[7] = 0;
        array2[8] = 1;
      }
      return array2;
    }
    apply(pos, newPos) {
      newPos = newPos || new Point();
      const x3 = pos.x;
      const y3 = pos.y;
      newPos.x = this.a * x3 + this.c * y3 + this.tx;
      newPos.y = this.b * x3 + this.d * y3 + this.ty;
      return newPos;
    }
    applyInverse(pos, newPos) {
      newPos = newPos || new Point();
      const id2 = 1 / (this.a * this.d + this.c * -this.b);
      const x3 = pos.x;
      const y3 = pos.y;
      newPos.x = this.d * id2 * x3 + -this.c * id2 * y3 + (this.ty * this.c - this.tx * this.d) * id2;
      newPos.y = this.a * id2 * y3 + -this.b * id2 * x3 + (-this.ty * this.a + this.tx * this.b) * id2;
      return newPos;
    }
    translate(x3, y3) {
      this.tx += x3;
      this.ty += y3;
      return this;
    }
    scale(x3, y3) {
      this.a *= x3;
      this.d *= y3;
      this.c *= x3;
      this.b *= y3;
      this.tx *= x3;
      this.ty *= y3;
      return this;
    }
    rotate(angle) {
      const cos = Math.cos(angle);
      const sin = Math.sin(angle);
      const a1 = this.a;
      const c1 = this.c;
      const tx1 = this.tx;
      this.a = a1 * cos - this.b * sin;
      this.b = a1 * sin + this.b * cos;
      this.c = c1 * cos - this.d * sin;
      this.d = c1 * sin + this.d * cos;
      this.tx = tx1 * cos - this.ty * sin;
      this.ty = tx1 * sin + this.ty * cos;
      return this;
    }
    append(matrix) {
      const a1 = this.a;
      const b1 = this.b;
      const c1 = this.c;
      const d1 = this.d;
      this.a = matrix.a * a1 + matrix.b * c1;
      this.b = matrix.a * b1 + matrix.b * d1;
      this.c = matrix.c * a1 + matrix.d * c1;
      this.d = matrix.c * b1 + matrix.d * d1;
      this.tx = matrix.tx * a1 + matrix.ty * c1 + this.tx;
      this.ty = matrix.tx * b1 + matrix.ty * d1 + this.ty;
      return this;
    }
    setTransform(x3, y3, pivotX, pivotY, scaleX, scaleY, rotation, skewX, skewY) {
      this.a = Math.cos(rotation + skewY) * scaleX;
      this.b = Math.sin(rotation + skewY) * scaleX;
      this.c = -Math.sin(rotation - skewX) * scaleY;
      this.d = Math.cos(rotation - skewX) * scaleY;
      this.tx = x3 - (pivotX * this.a + pivotY * this.c);
      this.ty = y3 - (pivotX * this.b + pivotY * this.d);
      return this;
    }
    prepend(matrix) {
      const tx1 = this.tx;
      if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1) {
        const a1 = this.a;
        const c1 = this.c;
        this.a = a1 * matrix.a + this.b * matrix.c;
        this.b = a1 * matrix.b + this.b * matrix.d;
        this.c = c1 * matrix.a + this.d * matrix.c;
        this.d = c1 * matrix.b + this.d * matrix.d;
      }
      this.tx = tx1 * matrix.a + this.ty * matrix.c + matrix.tx;
      this.ty = tx1 * matrix.b + this.ty * matrix.d + matrix.ty;
      return this;
    }
    decompose(transform2) {
      const a2 = this.a;
      const b = this.b;
      const c2 = this.c;
      const d = this.d;
      const pivot = transform2.pivot;
      const skewX = -Math.atan2(-c2, d);
      const skewY = Math.atan2(b, a2);
      const delta = Math.abs(skewX + skewY);
      if (delta < 1e-5 || Math.abs(PI_2 - delta) < 1e-5) {
        transform2.rotation = skewY;
        transform2.skew.x = transform2.skew.y = 0;
      } else {
        transform2.rotation = 0;
        transform2.skew.x = skewX;
        transform2.skew.y = skewY;
      }
      transform2.scale.x = Math.sqrt(a2 * a2 + b * b);
      transform2.scale.y = Math.sqrt(c2 * c2 + d * d);
      transform2.position.x = this.tx + (pivot.x * a2 + pivot.y * c2);
      transform2.position.y = this.ty + (pivot.x * b + pivot.y * d);
      return transform2;
    }
    invert() {
      const a1 = this.a;
      const b1 = this.b;
      const c1 = this.c;
      const d1 = this.d;
      const tx1 = this.tx;
      const n = a1 * d1 - b1 * c1;
      this.a = d1 / n;
      this.b = -b1 / n;
      this.c = -c1 / n;
      this.d = a1 / n;
      this.tx = (c1 * this.ty - d1 * tx1) / n;
      this.ty = -(a1 * this.ty - b1 * tx1) / n;
      return this;
    }
    identity() {
      this.a = 1;
      this.b = 0;
      this.c = 0;
      this.d = 1;
      this.tx = 0;
      this.ty = 0;
      return this;
    }
    clone() {
      const matrix = new Matrix();
      matrix.a = this.a;
      matrix.b = this.b;
      matrix.c = this.c;
      matrix.d = this.d;
      matrix.tx = this.tx;
      matrix.ty = this.ty;
      return matrix;
    }
    copyTo(matrix) {
      matrix.a = this.a;
      matrix.b = this.b;
      matrix.c = this.c;
      matrix.d = this.d;
      matrix.tx = this.tx;
      matrix.ty = this.ty;
      return matrix;
    }
    copyFrom(matrix) {
      this.a = matrix.a;
      this.b = matrix.b;
      this.c = matrix.c;
      this.d = matrix.d;
      this.tx = matrix.tx;
      this.ty = matrix.ty;
      return this;
    }
    toString() {
      return `[pixijs/math:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`;
    }
    static get IDENTITY() {
      return new Matrix();
    }
    static get TEMP_MATRIX() {
      return new Matrix();
    }
  };

  // node_modules/pixijs/math/groupD8.mjs
  var ux = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1];
  var uy = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1];
  var vx = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1];
  var vy = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1];
  var rotationCayley = [];
  var rotationMatrices = [];
  var signum = Math.sign;
  function init2() {
    for (let i = 0; i < 16; i++) {
      const row = [];
      rotationCayley.push(row);
      for (let j = 0; j < 16; j++) {
        const _ux = signum(ux[i] * ux[j] + vx[i] * uy[j]);
        const _uy = signum(uy[i] * ux[j] + vy[i] * uy[j]);
        const _vx = signum(ux[i] * vx[j] + vx[i] * vy[j]);
        const _vy = signum(uy[i] * vx[j] + vy[i] * vy[j]);
        for (let k = 0; k < 16; k++) {
          if (ux[k] === _ux && uy[k] === _uy && vx[k] === _vx && vy[k] === _vy) {
            row.push(k);
            break;
          }
        }
      }
    }
    for (let i = 0; i < 16; i++) {
      const mat = new Matrix();
      mat.set(ux[i], uy[i], vx[i], vy[i], 0, 0);
      rotationMatrices.push(mat);
    }
  }
  init2();
  var groupD8 = {
    E: 0,
    SE: 1,
    S: 2,
    SW: 3,
    W: 4,
    NW: 5,
    N: 6,
    NE: 7,
    MIRROR_VERTICAL: 8,
    MAIN_DIAGONAL: 10,
    MIRROR_HORIZONTAL: 12,
    REVERSE_DIAGONAL: 14,
    uX: (ind) => ux[ind],
    uY: (ind) => uy[ind],
    vX: (ind) => vx[ind],
    vY: (ind) => vy[ind],
    inv: (rotation) => {
      if (rotation & 8) {
        return rotation & 15;
      }
      return -rotation & 7;
    },
    add: (rotationSecond, rotationFirst) => rotationCayley[rotationSecond][rotationFirst],
    sub: (rotationSecond, rotationFirst) => rotationCayley[rotationSecond][groupD8.inv(rotationFirst)],
    rotate180: (rotation) => rotation ^ 4,
    isVertical: (rotation) => (rotation & 3) === 2,
    byDirection: (dx, dy) => {
      if (Math.abs(dx) * 2 <= Math.abs(dy)) {
        if (dy >= 0) {
          return groupD8.S;
        }
        return groupD8.N;
      } else if (Math.abs(dy) * 2 <= Math.abs(dx)) {
        if (dx > 0) {
          return groupD8.E;
        }
        return groupD8.W;
      } else if (dy > 0) {
        if (dx > 0) {
          return groupD8.SE;
        }
        return groupD8.SW;
      } else if (dx > 0) {
        return groupD8.NE;
      }
      return groupD8.NW;
    },
    matrixAppendRotationInv: (matrix, rotation, tx = 0, ty = 0) => {
      const mat = rotationMatrices[groupD8.inv(rotation)];
      mat.tx = tx;
      mat.ty = ty;
      matrix.append(mat);
    }
  };

  // node_modules/pixijs/math/ObservablePoint.mjs
  var ObservablePoint = class {
    constructor(cb, scope, x3 = 0, y3 = 0) {
      this._x = x3;
      this._y = y3;
      this.cb = cb;
      this.scope = scope;
    }
    clone(cb = this.cb, scope = this.scope) {
      return new ObservablePoint(cb, scope, this._x, this._y);
    }
    set(x3 = 0, y3 = x3) {
      if (this._x !== x3 || this._y !== y3) {
        this._x = x3;
        this._y = y3;
        this.cb.call(this.scope);
      }
      return this;
    }
    copyFrom(p) {
      if (this._x !== p.x || this._y !== p.y) {
        this._x = p.x;
        this._y = p.y;
        this.cb.call(this.scope);
      }
      return this;
    }
    copyTo(p) {
      p.set(this._x, this._y);
      return p;
    }
    equals(p) {
      return p.x === this._x && p.y === this._y;
    }
    toString() {
      return `[pixijs/math:ObservablePoint x=${0} y=${0} scope=${this.scope}]`;
    }
    get x() {
      return this._x;
    }
    set x(value) {
      if (this._x !== value) {
        this._x = value;
        this.cb.call(this.scope);
      }
    }
    get y() {
      return this._y;
    }
    set y(value) {
      if (this._y !== value) {
        this._y = value;
        this.cb.call(this.scope);
      }
    }
  };

  // node_modules/pixijs/math/Transform.mjs
  var _Transform = class {
    constructor() {
      this.worldTransform = new Matrix();
      this.localTransform = new Matrix();
      this.position = new ObservablePoint(this.onChange, this, 0, 0);
      this.scale = new ObservablePoint(this.onChange, this, 1, 1);
      this.pivot = new ObservablePoint(this.onChange, this, 0, 0);
      this.skew = new ObservablePoint(this.updateSkew, this, 0, 0);
      this._rotation = 0;
      this._cx = 1;
      this._sx = 0;
      this._cy = 0;
      this._sy = 1;
      this._localID = 0;
      this._currentLocalID = 0;
      this._worldID = 0;
      this._parentID = 0;
    }
    onChange() {
      this._localID++;
    }
    updateSkew() {
      this._cx = Math.cos(this._rotation + this.skew.y);
      this._sx = Math.sin(this._rotation + this.skew.y);
      this._cy = -Math.sin(this._rotation - this.skew.x);
      this._sy = Math.cos(this._rotation - this.skew.x);
      this._localID++;
    }
    toString() {
      return `[pixijs/math:Transform position=(${this.position.x}, ${this.position.y}) rotation=${this.rotation} scale=(${this.scale.x}, ${this.scale.y}) skew=(${this.skew.x}, ${this.skew.y}) ]`;
    }
    updateLocalTransform() {
      const lt = this.localTransform;
      if (this._localID !== this._currentLocalID) {
        lt.a = this._cx * this.scale.x;
        lt.b = this._sx * this.scale.x;
        lt.c = this._cy * this.scale.y;
        lt.d = this._sy * this.scale.y;
        lt.tx = this.position.x - (this.pivot.x * lt.a + this.pivot.y * lt.c);
        lt.ty = this.position.y - (this.pivot.x * lt.b + this.pivot.y * lt.d);
        this._currentLocalID = this._localID;
        this._parentID = -1;
      }
    }
    updateTransform(parentTransform) {
      const lt = this.localTransform;
      if (this._localID !== this._currentLocalID) {
        lt.a = this._cx * this.scale.x;
        lt.b = this._sx * this.scale.x;
        lt.c = this._cy * this.scale.y;
        lt.d = this._sy * this.scale.y;
        lt.tx = this.position.x - (this.pivot.x * lt.a + this.pivot.y * lt.c);
        lt.ty = this.position.y - (this.pivot.x * lt.b + this.pivot.y * lt.d);
        this._currentLocalID = this._localID;
        this._parentID = -1;
      }
      if (this._parentID !== parentTransform._worldID) {
        const pt = parentTransform.worldTransform;
        const wt = this.worldTransform;
        wt.a = lt.a * pt.a + lt.b * pt.c;
        wt.b = lt.a * pt.b + lt.b * pt.d;
        wt.c = lt.c * pt.a + lt.d * pt.c;
        wt.d = lt.c * pt.b + lt.d * pt.d;
        wt.tx = lt.tx * pt.a + lt.ty * pt.c + pt.tx;
        wt.ty = lt.tx * pt.b + lt.ty * pt.d + pt.ty;
        this._parentID = parentTransform._worldID;
        this._worldID++;
      }
    }
    setFromMatrix(matrix) {
      matrix.decompose(this);
      this._localID++;
    }
    get rotation() {
      return this._rotation;
    }
    set rotation(value) {
      if (this._rotation !== value) {
        this._rotation = value;
        this.updateSkew();
      }
    }
  };
  var Transform2 = _Transform;
  Transform2.IDENTITY = new _Transform();

  // node_modules/pixijs/core/shader/defaultProgram.mjs
  var defaultFragment = "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor *= texture2D(uSampler, vTextureCoord);\n}";

  // node_modules/pixijs/core/shader/defaultProgram2.mjs
  var defaultVertex = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void){\n   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n   vTextureCoord = aTextureCoord;\n}\n";

  // node_modules/pixijs/core/shader/utils/compileShader.mjs
  function compileShader(gl, type2, src) {
    const shader = gl.createShader(type2);
    gl.shaderSource(shader, src);
    gl.compileShader(shader);
    return shader;
  }

  // node_modules/pixijs/core/shader/utils/defaultValue.mjs
  function booleanArray(size) {
    const array2 = new Array(size);
    for (let i = 0; i < array2.length; i++) {
      array2[i] = false;
    }
    return array2;
  }
  function defaultValue(type2, size) {
    switch (type2) {
      case "float":
        return 0;
      case "vec2":
        return new Float32Array(2 * size);
      case "vec3":
        return new Float32Array(3 * size);
      case "vec4":
        return new Float32Array(4 * size);
      case "int":
      case "uint":
      case "sampler2D":
      case "sampler2DArray":
        return 0;
      case "ivec2":
        return new Int32Array(2 * size);
      case "ivec3":
        return new Int32Array(3 * size);
      case "ivec4":
        return new Int32Array(4 * size);
      case "uvec2":
        return new Uint32Array(2 * size);
      case "uvec3":
        return new Uint32Array(3 * size);
      case "uvec4":
        return new Uint32Array(4 * size);
      case "bool":
        return false;
      case "bvec2":
        return booleanArray(2 * size);
      case "bvec3":
        return booleanArray(3 * size);
      case "bvec4":
        return booleanArray(4 * size);
      case "mat2":
        return new Float32Array([
          1,
          0,
          0,
          1
        ]);
      case "mat3":
        return new Float32Array([
          1,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          1
        ]);
      case "mat4":
        return new Float32Array([
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1
        ]);
    }
    return null;
  }

  // node_modules/pixijs/core/shader/utils/uniformParsers.mjs
  var uniformParsers = [
    {
      test: (data) => data.type === "float" && data.size === 1 && !data.isArray,
      code: (name) => `
            if(uv["${name}"] !== ud["${name}"].value)
            {
                ud["${name}"].value = uv["${name}"]
                gl.uniform1f(ud["${name}"].location, uv["${name}"])
            }
            `
    },
    {
      test: (data, uniform) => (data.type === "sampler2D" || data.type === "samplerCube" || data.type === "sampler2DArray") && data.size === 1 && !data.isArray && (uniform == null || uniform.castToBaseTexture !== void 0),
      code: (name) => `t = syncData.textureCount++;

            renderer.texture.bind(uv["${name}"], t);

            if(ud["${name}"].value !== t)
            {
                ud["${name}"].value = t;
                gl.uniform1i(ud["${name}"].location, t);
; // eslint-disable-line max-len
            }`
    },
    {
      test: (data, uniform) => data.type === "mat3" && data.size === 1 && !data.isArray && uniform.a !== void 0,
      code: (name) => `
            gl.uniformMatrix3fv(ud["${name}"].location, false, uv["${name}"].toArray(true));
            `,
      codeUbo: (name) => `
                var ${name}_matrix = uv.${name}.toArray(true);

                data[offset] = ${name}_matrix[0];
                data[offset+1] = ${name}_matrix[1];
                data[offset+2] = ${name}_matrix[2];
        
                data[offset + 4] = ${name}_matrix[3];
                data[offset + 5] = ${name}_matrix[4];
                data[offset + 6] = ${name}_matrix[5];
        
                data[offset + 8] = ${name}_matrix[6];
                data[offset + 9] = ${name}_matrix[7];
                data[offset + 10] = ${name}_matrix[8];
            `
    },
    {
      test: (data, uniform) => data.type === "vec2" && data.size === 1 && !data.isArray && uniform.x !== void 0,
      code: (name) => `
                cv = ud["${name}"].value;
                v = uv["${name}"];

                if(cv[0] !== v.x || cv[1] !== v.y)
                {
                    cv[0] = v.x;
                    cv[1] = v.y;
                    gl.uniform2f(ud["${name}"].location, v.x, v.y);
                }`,
      codeUbo: (name) => `
                v = uv.${name};

                data[offset] = v.x;
                data[offset+1] = v.y;
            `
    },
    {
      test: (data) => data.type === "vec2" && data.size === 1 && !data.isArray,
      code: (name) => `
                cv = ud["${name}"].value;
                v = uv["${name}"];

                if(cv[0] !== v[0] || cv[1] !== v[1])
                {
                    cv[0] = v[0];
                    cv[1] = v[1];
                    gl.uniform2f(ud["${name}"].location, v[0], v[1]);
                }
            `
    },
    {
      test: (data, uniform) => data.type === "vec4" && data.size === 1 && !data.isArray && uniform.width !== void 0,
      code: (name) => `
                cv = ud["${name}"].value;
                v = uv["${name}"];

                if(cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height)
                {
                    cv[0] = v.x;
                    cv[1] = v.y;
                    cv[2] = v.width;
                    cv[3] = v.height;
                    gl.uniform4f(ud["${name}"].location, v.x, v.y, v.width, v.height)
                }`,
      codeUbo: (name) => `
                    v = uv.${name};

                    data[offset] = v.x;
                    data[offset+1] = v.y;
                    data[offset+2] = v.width;
                    data[offset+3] = v.height;
                `
    },
    {
      test: (data) => data.type === "vec4" && data.size === 1 && !data.isArray,
      code: (name) => `
                cv = ud["${name}"].value;
                v = uv["${name}"];

                if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
                {
                    cv[0] = v[0];
                    cv[1] = v[1];
                    cv[2] = v[2];
                    cv[3] = v[3];

                    gl.uniform4f(ud["${name}"].location, v[0], v[1], v[2], v[3])
                }`
    }
  ];

  // node_modules/pixijs/core/shader/utils/generateUniformsSync.mjs
  var GLSL_TO_SINGLE_SETTERS_CACHED = {
    float: `
    if (cv !== v)
    {
        cu.value = v;
        gl.uniform1f(location, v);
    }`,
    vec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2f(location, v[0], v[1])
    }`,
    vec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3f(location, v[0], v[1], v[2])
    }`,
    vec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4f(location, v[0], v[1], v[2], v[3]);
    }`,
    int: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
    ivec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2i(location, v[0], v[1]);
    }`,
    ivec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3i(location, v[0], v[1], v[2]);
    }`,
    ivec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4i(location, v[0], v[1], v[2], v[3]);
    }`,
    uint: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1ui(location, v);
    }`,
    uvec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2ui(location, v[0], v[1]);
    }`,
    uvec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3ui(location, v[0], v[1], v[2]);
    }`,
    uvec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4ui(location, v[0], v[1], v[2], v[3]);
    }`,
    bool: `
    if (cv !== v)
    {
        cu.value = v;
        gl.uniform1i(location, v);
    }`,
    bvec2: `
    if (cv[0] != v[0] || cv[1] != v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2i(location, v[0], v[1]);
    }`,
    bvec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3i(location, v[0], v[1], v[2]);
    }`,
    bvec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4i(location, v[0], v[1], v[2], v[3]);
    }`,
    mat2: "gl.uniformMatrix2fv(location, false, v)",
    mat3: "gl.uniformMatrix3fv(location, false, v)",
    mat4: "gl.uniformMatrix4fv(location, false, v)",
    sampler2D: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
    samplerCube: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
    sampler2DArray: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`
  };
  var GLSL_TO_ARRAY_SETTERS = {
    float: `gl.uniform1fv(location, v)`,
    vec2: `gl.uniform2fv(location, v)`,
    vec3: `gl.uniform3fv(location, v)`,
    vec4: "gl.uniform4fv(location, v)",
    mat4: "gl.uniformMatrix4fv(location, false, v)",
    mat3: "gl.uniformMatrix3fv(location, false, v)",
    mat2: "gl.uniformMatrix2fv(location, false, v)",
    int: "gl.uniform1iv(location, v)",
    ivec2: "gl.uniform2iv(location, v)",
    ivec3: "gl.uniform3iv(location, v)",
    ivec4: "gl.uniform4iv(location, v)",
    uint: "gl.uniform1uiv(location, v)",
    uvec2: "gl.uniform2uiv(location, v)",
    uvec3: "gl.uniform3uiv(location, v)",
    uvec4: "gl.uniform4uiv(location, v)",
    bool: "gl.uniform1iv(location, v)",
    bvec2: "gl.uniform2iv(location, v)",
    bvec3: "gl.uniform3iv(location, v)",
    bvec4: "gl.uniform4iv(location, v)",
    sampler2D: "gl.uniform1iv(location, v)",
    samplerCube: "gl.uniform1iv(location, v)",
    sampler2DArray: "gl.uniform1iv(location, v)"
  };
  function generateUniformsSync(group, uniformData) {
    var _a;
    const funcFragments = [`
        var v = null;
        var cv = null;
        var cu = null;
        var t = 0;
        var gl = renderer.gl;
    `];
    for (const i in group.uniforms) {
      const data = uniformData[i];
      if (!data) {
        if ((_a = group.uniforms[i]) == null ? void 0 : _a.group) {
          if (group.uniforms[i].ubo) {
            funcFragments.push(`
                        renderer.shader.syncUniformBufferGroup(uv.${i}, '${i}');
                    `);
          } else {
            funcFragments.push(`
                        renderer.shader.syncUniformGroup(uv.${i}, syncData);
                    `);
          }
        }
        continue;
      }
      const uniform = group.uniforms[i];
      let parsed = false;
      for (let j = 0; j < uniformParsers.length; j++) {
        if (uniformParsers[j].test(data, uniform)) {
          funcFragments.push(uniformParsers[j].code(i, uniform));
          parsed = true;
          break;
        }
      }
      if (!parsed) {
        const templateType = data.size === 1 && !data.isArray ? GLSL_TO_SINGLE_SETTERS_CACHED : GLSL_TO_ARRAY_SETTERS;
        const template = templateType[data.type].replace("location", `ud["${i}"].location`);
        funcFragments.push(`
            cu = ud["${i}"];
            cv = cu.value;
            v = uv["${i}"];
            ${template};`);
      }
    }
    return new Function("ud", "uv", "renderer", "syncData", funcFragments.join("\n"));
  }

  // node_modules/pixijs/core/shader/utils/getTestContext.mjs
  var unknownContext = {};
  var context = unknownContext;
  function getTestContext() {
    if (context === unknownContext || (context == null ? void 0 : context.isContextLost())) {
      const canvas = settings.ADAPTER.createCanvas();
      let gl;
      if (settings.PREFER_ENV >= ENV.WEBGL2) {
        gl = canvas.getContext("webgl2", {});
      }
      if (!gl) {
        gl = canvas.getContext("webgl", {}) || canvas.getContext("experimental-webgl", {});
        if (!gl) {
          gl = null;
        } else {
          gl.getExtension("WEBGL_draw_buffers");
        }
      }
      context = gl;
    }
    return context;
  }

  // node_modules/pixijs/core/shader/utils/getMaxFragmentPrecision.mjs
  var maxFragmentPrecision;
  function getMaxFragmentPrecision() {
    if (!maxFragmentPrecision) {
      maxFragmentPrecision = PRECISION.MEDIUM;
      const gl = getTestContext();
      if (gl) {
        if (gl.getShaderPrecisionFormat) {
          const shaderFragment = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);
          maxFragmentPrecision = shaderFragment.precision ? PRECISION.HIGH : PRECISION.MEDIUM;
        }
      }
    }
    return maxFragmentPrecision;
  }

  // node_modules/pixijs/core/shader/utils/logProgramError.mjs
  function logPrettyShaderError(gl, shader) {
    const shaderSrc = gl.getShaderSource(shader).split("\n").map((line, index2) => `${index2}: ${line}`);
    const shaderLog = gl.getShaderInfoLog(shader);
    const splitShader = shaderLog.split("\n");
    const dedupe = {};
    const lineNumbers = splitShader.map((line) => parseFloat(line.replace(/^ERROR\: 0\:([\d]+)\:.*$/, "$1"))).filter((n) => {
      if (n && !dedupe[n]) {
        dedupe[n] = true;
        return true;
      }
      return false;
    });
    const logArgs = [""];
    lineNumbers.forEach((number) => {
      shaderSrc[number - 1] = `%c${shaderSrc[number - 1]}%c`;
      logArgs.push("background: #FF0000; color:#FFFFFF; font-size: 10px", "font-size: 10px");
    });
    const fragmentSourceToLog = shaderSrc.join("\n");
    logArgs[0] = fragmentSourceToLog;
    console.error(shaderLog);
    console.groupCollapsed("click to view full shader code");
    console.warn(...logArgs);
    console.groupEnd();
  }
  function logProgramError(gl, program, vertexShader, fragmentShader) {
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
        logPrettyShaderError(gl, vertexShader);
      }
      if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
        logPrettyShaderError(gl, fragmentShader);
      }
      console.error("PixiJS Error: Could not initialize shader.");
      if (gl.getProgramInfoLog(program) !== "") {
        console.warn("PixiJS Warning: gl.getProgramInfoLog()", gl.getProgramInfoLog(program));
      }
    }
  }

  // node_modules/pixijs/core/shader/utils/mapSize.mjs
  var GLSL_TO_SIZE = {
    float: 1,
    vec2: 2,
    vec3: 3,
    vec4: 4,
    int: 1,
    ivec2: 2,
    ivec3: 3,
    ivec4: 4,
    uint: 1,
    uvec2: 2,
    uvec3: 3,
    uvec4: 4,
    bool: 1,
    bvec2: 2,
    bvec3: 3,
    bvec4: 4,
    mat2: 4,
    mat3: 9,
    mat4: 16,
    sampler2D: 1
  };
  function mapSize(type2) {
    return GLSL_TO_SIZE[type2];
  }

  // node_modules/pixijs/core/shader/utils/mapType.mjs
  var GL_TABLE = null;
  var GL_TO_GLSL_TYPES = {
    FLOAT: "float",
    FLOAT_VEC2: "vec2",
    FLOAT_VEC3: "vec3",
    FLOAT_VEC4: "vec4",
    INT: "int",
    INT_VEC2: "ivec2",
    INT_VEC3: "ivec3",
    INT_VEC4: "ivec4",
    UNSIGNED_INT: "uint",
    UNSIGNED_INT_VEC2: "uvec2",
    UNSIGNED_INT_VEC3: "uvec3",
    UNSIGNED_INT_VEC4: "uvec4",
    BOOL: "bool",
    BOOL_VEC2: "bvec2",
    BOOL_VEC3: "bvec3",
    BOOL_VEC4: "bvec4",
    FLOAT_MAT2: "mat2",
    FLOAT_MAT3: "mat3",
    FLOAT_MAT4: "mat4",
    SAMPLER_2D: "sampler2D",
    INT_SAMPLER_2D: "sampler2D",
    UNSIGNED_INT_SAMPLER_2D: "sampler2D",
    SAMPLER_CUBE: "samplerCube",
    INT_SAMPLER_CUBE: "samplerCube",
    UNSIGNED_INT_SAMPLER_CUBE: "samplerCube",
    SAMPLER_2D_ARRAY: "sampler2DArray",
    INT_SAMPLER_2D_ARRAY: "sampler2DArray",
    UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray"
  };
  function mapType(gl, type2) {
    if (!GL_TABLE) {
      const typeNames = Object.keys(GL_TO_GLSL_TYPES);
      GL_TABLE = {};
      for (let i = 0; i < typeNames.length; ++i) {
        const tn = typeNames[i];
        GL_TABLE[gl[tn]] = GL_TO_GLSL_TYPES[tn];
      }
    }
    return GL_TABLE[type2];
  }

  // node_modules/pixijs/core/shader/utils/setPrecision.mjs
  function setPrecision(src, requestedPrecision, maxSupportedPrecision) {
    if (src.substring(0, 9) !== "precision") {
      let precision = requestedPrecision;
      if (requestedPrecision === PRECISION.HIGH && maxSupportedPrecision !== PRECISION.HIGH) {
        precision = PRECISION.MEDIUM;
      }
      return `precision ${precision} float;
${src}`;
    } else if (maxSupportedPrecision !== PRECISION.HIGH && src.substring(0, 15) === "precision highp") {
      return src.replace("precision highp", "precision mediump");
    }
    return src;
  }

  // node_modules/pixijs/core/shader/utils/unsafeEvalSupported.mjs
  var unsafeEval;
  function unsafeEvalSupported() {
    if (typeof unsafeEval === "boolean") {
      return unsafeEval;
    }
    try {
      const func = new Function("param1", "param2", "param3", "return param1[param2] === param3;");
      unsafeEval = func({ a: "b" }, "a", "b") === true;
    } catch (e) {
      unsafeEval = false;
    }
    return unsafeEval;
  }

  // node_modules/pixijs/core/shader/Program.mjs
  var UID3 = 0;
  var nameCache = {};
  var _Program = class {
    constructor(vertexSrc, fragmentSrc, name = "pixi-shader", extra = {}) {
      this.extra = {};
      this.id = UID3++;
      this.vertexSrc = vertexSrc || _Program.defaultVertexSrc;
      this.fragmentSrc = fragmentSrc || _Program.defaultFragmentSrc;
      this.vertexSrc = this.vertexSrc.trim();
      this.fragmentSrc = this.fragmentSrc.trim();
      this.extra = extra;
      if (this.vertexSrc.substring(0, 8) !== "#version") {
        name = name.replace(/\s+/g, "-");
        if (nameCache[name]) {
          nameCache[name]++;
          name += `-${nameCache[name]}`;
        } else {
          nameCache[name] = 1;
        }
        this.vertexSrc = `#define SHADER_NAME ${name}
${this.vertexSrc}`;
        this.fragmentSrc = `#define SHADER_NAME ${name}
${this.fragmentSrc}`;
        this.vertexSrc = setPrecision(this.vertexSrc, _Program.defaultVertexPrecision, PRECISION.HIGH);
        this.fragmentSrc = setPrecision(this.fragmentSrc, _Program.defaultFragmentPrecision, getMaxFragmentPrecision());
      }
      this.glPrograms = {};
      this.syncUniforms = null;
    }
    static get defaultVertexSrc() {
      return defaultVertex;
    }
    static get defaultFragmentSrc() {
      return defaultFragment;
    }
    static from(vertexSrc, fragmentSrc, name) {
      const key = vertexSrc + fragmentSrc;
      let program = ProgramCache[key];
      if (!program) {
        ProgramCache[key] = program = new _Program(vertexSrc, fragmentSrc, name);
      }
      return program;
    }
  };
  var Program = _Program;
  Program.defaultVertexPrecision = PRECISION.HIGH;
  Program.defaultFragmentPrecision = isMobile2.apple.device ? PRECISION.HIGH : PRECISION.MEDIUM;

  // node_modules/pixijs/core/shader/UniformGroup.mjs
  var UID4 = 0;
  var UniformGroup = class {
    constructor(uniforms, isStatic, isUbo) {
      this.group = true;
      this.syncUniforms = {};
      this.dirtyId = 0;
      this.id = UID4++;
      this.static = !!isStatic;
      this.ubo = !!isUbo;
      if (uniforms instanceof Buffer2) {
        this.buffer = uniforms;
        this.buffer.type = BUFFER_TYPE.UNIFORM_BUFFER;
        this.autoManage = false;
        this.ubo = true;
      } else {
        this.uniforms = uniforms;
        if (this.ubo) {
          this.buffer = new Buffer2(new Float32Array(1));
          this.buffer.type = BUFFER_TYPE.UNIFORM_BUFFER;
          this.autoManage = true;
        }
      }
    }
    update() {
      this.dirtyId++;
      if (!this.autoManage && this.buffer) {
        this.buffer.update();
      }
    }
    add(name, uniforms, _static) {
      if (!this.ubo) {
        this.uniforms[name] = new UniformGroup(uniforms, _static);
      } else {
        throw new Error("[UniformGroup] uniform groups in ubo mode cannot be modified, or have uniform groups nested in them");
      }
    }
    static from(uniforms, _static, _ubo) {
      return new UniformGroup(uniforms, _static, _ubo);
    }
    static uboFrom(uniforms, _static) {
      return new UniformGroup(uniforms, _static != null ? _static : true, true);
    }
  };

  // node_modules/pixijs/core/shader/Shader.mjs
  var Shader = class {
    constructor(program, uniforms) {
      this.uniformBindCount = 0;
      this.program = program;
      if (uniforms) {
        if (uniforms instanceof UniformGroup) {
          this.uniformGroup = uniforms;
        } else {
          this.uniformGroup = new UniformGroup(uniforms);
        }
      } else {
        this.uniformGroup = new UniformGroup({});
      }
      this.disposeRunner = new Runner("disposeShader");
    }
    checkUniformExists(name, group) {
      if (group.uniforms[name]) {
        return true;
      }
      for (const i in group.uniforms) {
        const uniform = group.uniforms[i];
        if (uniform.group) {
          if (this.checkUniformExists(name, uniform)) {
            return true;
          }
        }
      }
      return false;
    }
    destroy() {
      this.uniformGroup = null;
      this.disposeRunner.emit(this);
      this.disposeRunner.destroy();
    }
    get uniforms() {
      return this.uniformGroup.uniforms;
    }
    static from(vertexSrc, fragmentSrc, uniforms) {
      const program = Program.from(vertexSrc, fragmentSrc);
      return new Shader(program, uniforms);
    }
  };

  // node_modules/pixijs/core/batch/BatchShaderGenerator.mjs
  var BatchShaderGenerator = class {
    constructor(vertexSrc, fragTemplate3) {
      this.vertexSrc = vertexSrc;
      this.fragTemplate = fragTemplate3;
      this.programCache = {};
      this.defaultGroupCache = {};
      if (!fragTemplate3.includes("%count%")) {
        throw new Error('Fragment template must contain "%count%".');
      }
      if (!fragTemplate3.includes("%forloop%")) {
        throw new Error('Fragment template must contain "%forloop%".');
      }
    }
    generateShader(maxTextures) {
      if (!this.programCache[maxTextures]) {
        const sampleValues = new Int32Array(maxTextures);
        for (let i = 0; i < maxTextures; i++) {
          sampleValues[i] = i;
        }
        this.defaultGroupCache[maxTextures] = UniformGroup.from({ uSamplers: sampleValues }, true);
        let fragmentSrc = this.fragTemplate;
        fragmentSrc = fragmentSrc.replace(/%count%/gi, `${maxTextures}`);
        fragmentSrc = fragmentSrc.replace(/%forloop%/gi, this.generateSampleSrc(maxTextures));
        this.programCache[maxTextures] = new Program(this.vertexSrc, fragmentSrc);
      }
      const uniforms = {
        tint: new Float32Array([1, 1, 1, 1]),
        translationMatrix: new Matrix(),
        default: this.defaultGroupCache[maxTextures]
      };
      return new Shader(this.programCache[maxTextures], uniforms);
    }
    generateSampleSrc(maxTextures) {
      let src = "";
      src += "\n";
      src += "\n";
      for (let i = 0; i < maxTextures; i++) {
        if (i > 0) {
          src += "\nelse ";
        }
        if (i < maxTextures - 1) {
          src += `if(vTextureId < ${i}.5)`;
        }
        src += "\n{";
        src += `
	color = texture2D(uSamplers[${i}], vTextureCoord);`;
        src += "\n}";
      }
      src += "\n";
      src += "\n";
      return src;
    }
  };

  // node_modules/pixijs/core/batch/BatchTextureArray.mjs
  var BatchTextureArray = class {
    constructor() {
      this.elements = [];
      this.ids = [];
      this.count = 0;
    }
    clear() {
      for (let i = 0; i < this.count; i++) {
        this.elements[i] = null;
      }
      this.count = 0;
    }
  };

  // node_modules/pixijs/core/batch/canUploadSameBuffer.mjs
  function canUploadSameBuffer() {
    return !isMobile2.apple.device;
  }

  // node_modules/pixijs/core/batch/maxRecommendedTextures.mjs
  function maxRecommendedTextures(max2) {
    let allowMax = true;
    const navigator2 = settings.ADAPTER.getNavigator();
    if (isMobile2.tablet || isMobile2.phone) {
      if (isMobile2.apple.device) {
        const match = navigator2.userAgent.match(/OS (\d+)_(\d+)?/);
        if (match) {
          const majorVersion = parseInt(match[1], 10);
          if (majorVersion < 11) {
            allowMax = false;
          }
        }
      }
      if (isMobile2.android.device) {
        const match = navigator2.userAgent.match(/Android\s([0-9.]*)/);
        if (match) {
          const majorVersion = parseInt(match[1], 10);
          if (majorVersion < 7) {
            allowMax = false;
          }
        }
      }
    }
    return allowMax ? max2 : 4;
  }

  // node_modules/pixijs/core/batch/ObjectRenderer.mjs
  var ObjectRenderer = class {
    constructor(renderer) {
      this.renderer = renderer;
    }
    flush() {
    }
    destroy() {
      this.renderer = null;
    }
    start() {
    }
    stop() {
      this.flush();
    }
    render(_object) {
    }
  };

  // node_modules/pixijs/core/batch/texture.mjs
  var defaultFragment2 = "varying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\nuniform sampler2D uSamplers[%count%];\n\nvoid main(void){\n    vec4 color;\n    %forloop%\n    gl_FragColor = color * vColor;\n}\n";

  // node_modules/pixijs/core/batch/texture2.mjs
  var defaultVertex2 = "precision highp float;\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\nattribute float aTextureId;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform vec4 tint;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\n\nvoid main(void){\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vTextureId = aTextureId;\n    vColor = aColor * tint;\n}\n";

  // node_modules/pixijs/core/batch/BatchRenderer.mjs
  var _BatchRenderer = class extends ObjectRenderer {
    constructor(renderer) {
      super(renderer);
      this.setShaderGenerator();
      this.geometryClass = BatchGeometry;
      this.vertexSize = 6;
      this.state = State.for2d();
      this.size = _BatchRenderer.defaultBatchSize * 4;
      this._vertexCount = 0;
      this._indexCount = 0;
      this._bufferedElements = [];
      this._bufferedTextures = [];
      this._bufferSize = 0;
      this._shader = null;
      this._packedGeometries = [];
      this._packedGeometryPoolSize = 2;
      this._flushId = 0;
      this._aBuffers = {};
      this._iBuffers = {};
      this.maxTextures = 1;
      this.renderer.on("prerender", this.onPrerender, this);
      renderer.runners.contextChange.add(this);
      this._dcIndex = 0;
      this._aIndex = 0;
      this._iIndex = 0;
      this._attributeBuffer = null;
      this._indexBuffer = null;
      this._tempBoundTextures = [];
    }
    static get defaultMaxTextures() {
      var _a;
      this._defaultMaxTextures = (_a = this._defaultMaxTextures) != null ? _a : maxRecommendedTextures(32);
      return this._defaultMaxTextures;
    }
    static set defaultMaxTextures(value) {
      this._defaultMaxTextures = value;
    }
    static get canUploadSameBuffer() {
      var _a;
      this._canUploadSameBuffer = (_a = this._canUploadSameBuffer) != null ? _a : canUploadSameBuffer();
      return this._canUploadSameBuffer;
    }
    static set canUploadSameBuffer(value) {
      this._canUploadSameBuffer = value;
    }
    get MAX_TEXTURES() {
      deprecation("7.1.0", "BatchRenderer#MAX_TEXTURES renamed to BatchRenderer#maxTextures");
      return this.maxTextures;
    }
    static get defaultVertexSrc() {
      return defaultVertex2;
    }
    static get defaultFragmentTemplate() {
      return defaultFragment2;
    }
    setShaderGenerator({
      vertex: vertex6 = _BatchRenderer.defaultVertexSrc,
      fragment: fragment9 = _BatchRenderer.defaultFragmentTemplate
    } = {}) {
      this.shaderGenerator = new BatchShaderGenerator(vertex6, fragment9);
    }
    contextChange() {
      const gl = this.renderer.gl;
      if (settings.PREFER_ENV === ENV.WEBGL_LEGACY) {
        this.maxTextures = 1;
      } else {
        this.maxTextures = Math.min(gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS), _BatchRenderer.defaultMaxTextures);
        this.maxTextures = checkMaxIfStatementsInShader(this.maxTextures, gl);
      }
      this._shader = this.shaderGenerator.generateShader(this.maxTextures);
      for (let i = 0; i < this._packedGeometryPoolSize; i++) {
        this._packedGeometries[i] = new this.geometryClass();
      }
      this.initFlushBuffers();
    }
    initFlushBuffers() {
      const {
        _drawCallPool,
        _textureArrayPool
      } = _BatchRenderer;
      const MAX_SPRITES = this.size / 4;
      const MAX_TA = Math.floor(MAX_SPRITES / this.maxTextures) + 1;
      while (_drawCallPool.length < MAX_SPRITES) {
        _drawCallPool.push(new BatchDrawCall());
      }
      while (_textureArrayPool.length < MAX_TA) {
        _textureArrayPool.push(new BatchTextureArray());
      }
      for (let i = 0; i < this.maxTextures; i++) {
        this._tempBoundTextures[i] = null;
      }
    }
    onPrerender() {
      this._flushId = 0;
    }
    render(element) {
      if (!element._texture.valid) {
        return;
      }
      if (this._vertexCount + element.vertexData.length / 2 > this.size) {
        this.flush();
      }
      this._vertexCount += element.vertexData.length / 2;
      this._indexCount += element.indices.length;
      this._bufferedTextures[this._bufferSize] = element._texture.baseTexture;
      this._bufferedElements[this._bufferSize++] = element;
    }
    buildTexturesAndDrawCalls() {
      const {
        _bufferedTextures: textures,
        maxTextures
      } = this;
      const textureArrays = _BatchRenderer._textureArrayPool;
      const batch = this.renderer.batch;
      const boundTextures = this._tempBoundTextures;
      const touch = this.renderer.textureGC.count;
      let TICK = ++BaseTexture._globalBatch;
      let countTexArrays = 0;
      let texArray = textureArrays[0];
      let start2 = 0;
      batch.copyBoundTextures(boundTextures, maxTextures);
      for (let i = 0; i < this._bufferSize; ++i) {
        const tex = textures[i];
        textures[i] = null;
        if (tex._batchEnabled === TICK) {
          continue;
        }
        if (texArray.count >= maxTextures) {
          batch.boundArray(texArray, boundTextures, TICK, maxTextures);
          this.buildDrawCalls(texArray, start2, i);
          start2 = i;
          texArray = textureArrays[++countTexArrays];
          ++TICK;
        }
        tex._batchEnabled = TICK;
        tex.touched = touch;
        texArray.elements[texArray.count++] = tex;
      }
      if (texArray.count > 0) {
        batch.boundArray(texArray, boundTextures, TICK, maxTextures);
        this.buildDrawCalls(texArray, start2, this._bufferSize);
        ++countTexArrays;
        ++TICK;
      }
      for (let i = 0; i < boundTextures.length; i++) {
        boundTextures[i] = null;
      }
      BaseTexture._globalBatch = TICK;
    }
    buildDrawCalls(texArray, start2, finish) {
      const {
        _bufferedElements: elements,
        _attributeBuffer,
        _indexBuffer,
        vertexSize
      } = this;
      const drawCalls = _BatchRenderer._drawCallPool;
      let dcIndex = this._dcIndex;
      let aIndex = this._aIndex;
      let iIndex = this._iIndex;
      let drawCall = drawCalls[dcIndex];
      drawCall.start = this._iIndex;
      drawCall.texArray = texArray;
      for (let i = start2; i < finish; ++i) {
        const sprite = elements[i];
        const tex = sprite._texture.baseTexture;
        const spriteBlendMode = premultiplyBlendMode[tex.alphaMode ? 1 : 0][sprite.blendMode];
        elements[i] = null;
        if (start2 < i && drawCall.blend !== spriteBlendMode) {
          drawCall.size = iIndex - drawCall.start;
          start2 = i;
          drawCall = drawCalls[++dcIndex];
          drawCall.texArray = texArray;
          drawCall.start = iIndex;
        }
        this.packInterleavedGeometry(sprite, _attributeBuffer, _indexBuffer, aIndex, iIndex);
        aIndex += sprite.vertexData.length / 2 * vertexSize;
        iIndex += sprite.indices.length;
        drawCall.blend = spriteBlendMode;
      }
      if (start2 < finish) {
        drawCall.size = iIndex - drawCall.start;
        ++dcIndex;
      }
      this._dcIndex = dcIndex;
      this._aIndex = aIndex;
      this._iIndex = iIndex;
    }
    bindAndClearTexArray(texArray) {
      const textureSystem = this.renderer.texture;
      for (let j = 0; j < texArray.count; j++) {
        textureSystem.bind(texArray.elements[j], texArray.ids[j]);
        texArray.elements[j] = null;
      }
      texArray.count = 0;
    }
    updateGeometry() {
      const {
        _packedGeometries: packedGeometries,
        _attributeBuffer: attributeBuffer,
        _indexBuffer: indexBuffer
      } = this;
      if (!_BatchRenderer.canUploadSameBuffer) {
        if (this._packedGeometryPoolSize <= this._flushId) {
          this._packedGeometryPoolSize++;
          packedGeometries[this._flushId] = new this.geometryClass();
        }
        packedGeometries[this._flushId]._buffer.update(attributeBuffer.rawBinaryData);
        packedGeometries[this._flushId]._indexBuffer.update(indexBuffer);
        this.renderer.geometry.bind(packedGeometries[this._flushId]);
        this.renderer.geometry.updateBuffers();
        this._flushId++;
      } else {
        packedGeometries[this._flushId]._buffer.update(attributeBuffer.rawBinaryData);
        packedGeometries[this._flushId]._indexBuffer.update(indexBuffer);
        this.renderer.geometry.updateBuffers();
      }
    }
    drawBatches() {
      const dcCount = this._dcIndex;
      const { gl, state: stateSystem } = this.renderer;
      const drawCalls = _BatchRenderer._drawCallPool;
      let curTexArray = null;
      for (let i = 0; i < dcCount; i++) {
        const { texArray, type: type2, size, start: start2, blend } = drawCalls[i];
        if (curTexArray !== texArray) {
          curTexArray = texArray;
          this.bindAndClearTexArray(texArray);
        }
        this.state.blendMode = blend;
        stateSystem.set(this.state);
        gl.drawElements(type2, size, gl.UNSIGNED_SHORT, start2 * 2);
      }
    }
    flush() {
      if (this._vertexCount === 0) {
        return;
      }
      this._attributeBuffer = this.getAttributeBuffer(this._vertexCount);
      this._indexBuffer = this.getIndexBuffer(this._indexCount);
      this._aIndex = 0;
      this._iIndex = 0;
      this._dcIndex = 0;
      this.buildTexturesAndDrawCalls();
      this.updateGeometry();
      this.drawBatches();
      this._bufferSize = 0;
      this._vertexCount = 0;
      this._indexCount = 0;
    }
    start() {
      this.renderer.state.set(this.state);
      this.renderer.texture.ensureSamplerType(this.maxTextures);
      this.renderer.shader.bind(this._shader);
      if (_BatchRenderer.canUploadSameBuffer) {
        this.renderer.geometry.bind(this._packedGeometries[this._flushId]);
      }
    }
    stop() {
      this.flush();
    }
    destroy() {
      for (let i = 0; i < this._packedGeometryPoolSize; i++) {
        if (this._packedGeometries[i]) {
          this._packedGeometries[i].destroy();
        }
      }
      this.renderer.off("prerender", this.onPrerender, this);
      this._aBuffers = null;
      this._iBuffers = null;
      this._packedGeometries = null;
      this._attributeBuffer = null;
      this._indexBuffer = null;
      if (this._shader) {
        this._shader.destroy();
        this._shader = null;
      }
      super.destroy();
    }
    getAttributeBuffer(size) {
      const roundedP2 = nextPow2(Math.ceil(size / 8));
      const roundedSizeIndex = log2(roundedP2);
      const roundedSize = roundedP2 * 8;
      if (this._aBuffers.length <= roundedSizeIndex) {
        this._iBuffers.length = roundedSizeIndex + 1;
      }
      let buffer = this._aBuffers[roundedSize];
      if (!buffer) {
        this._aBuffers[roundedSize] = buffer = new ViewableBuffer(roundedSize * this.vertexSize * 4);
      }
      return buffer;
    }
    getIndexBuffer(size) {
      const roundedP2 = nextPow2(Math.ceil(size / 12));
      const roundedSizeIndex = log2(roundedP2);
      const roundedSize = roundedP2 * 12;
      if (this._iBuffers.length <= roundedSizeIndex) {
        this._iBuffers.length = roundedSizeIndex + 1;
      }
      let buffer = this._iBuffers[roundedSizeIndex];
      if (!buffer) {
        this._iBuffers[roundedSizeIndex] = buffer = new Uint16Array(roundedSize);
      }
      return buffer;
    }
    packInterleavedGeometry(element, attributeBuffer, indexBuffer, aIndex, iIndex) {
      const {
        uint32View,
        float32View
      } = attributeBuffer;
      const packedVertices = aIndex / this.vertexSize;
      const uvs = element.uvs;
      const indicies = element.indices;
      const vertexData = element.vertexData;
      const textureId = element._texture.baseTexture._batchLocation;
      const alpha = Math.min(element.worldAlpha, 1);
      const argb = alpha < 1 && element._texture.baseTexture.alphaMode ? premultiplyTint(element._tintRGB, alpha) : element._tintRGB + (alpha * 255 << 24);
      for (let i = 0; i < vertexData.length; i += 2) {
        float32View[aIndex++] = vertexData[i];
        float32View[aIndex++] = vertexData[i + 1];
        float32View[aIndex++] = uvs[i];
        float32View[aIndex++] = uvs[i + 1];
        uint32View[aIndex++] = argb;
        float32View[aIndex++] = textureId;
      }
      for (let i = 0; i < indicies.length; i++) {
        indexBuffer[iIndex++] = packedVertices + indicies[i];
      }
    }
  };
  var BatchRenderer = _BatchRenderer;
  BatchRenderer.defaultBatchSize = 4096;
  BatchRenderer.extension = {
    name: "batch",
    type: ExtensionType.RendererPlugin
  };
  BatchRenderer._drawCallPool = [];
  BatchRenderer._textureArrayPool = [];
  extensions.add(BatchRenderer);

  // node_modules/pixijs/core/filters/defaultFilter.mjs
  var defaultFragment3 = "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor = texture2D(uSampler, vTextureCoord);\n}\n";

  // node_modules/pixijs/core/filters/defaultFilter2.mjs
  var defaultVertex3 = "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n";

  // node_modules/pixijs/core/filters/Filter.mjs
  var _Filter = class extends Shader {
    constructor(vertexSrc, fragmentSrc, uniforms) {
      const program = Program.from(vertexSrc || _Filter.defaultVertexSrc, fragmentSrc || _Filter.defaultFragmentSrc);
      super(program, uniforms);
      this.padding = 0;
      this.resolution = _Filter.defaultResolution;
      this.multisample = _Filter.defaultMultisample;
      this.enabled = true;
      this.autoFit = true;
      this.state = new State();
    }
    apply(filterManager, input, output, clearMode, _currentState) {
      filterManager.applyFilter(this, input, output, clearMode);
    }
    get blendMode() {
      return this.state.blendMode;
    }
    set blendMode(value) {
      this.state.blendMode = value;
    }
    get resolution() {
      return this._resolution;
    }
    set resolution(value) {
      this._resolution = value;
    }
    static get defaultVertexSrc() {
      return defaultVertex3;
    }
    static get defaultFragmentSrc() {
      return defaultFragment3;
    }
  };
  var Filter = _Filter;
  Filter.defaultResolution = 1;
  Filter.defaultMultisample = MSAA_QUALITY.NONE;

  // node_modules/pixijs/core/background/BackgroundSystem.mjs
  var BackgroundSystem = class {
    constructor() {
      this.clearBeforeRender = true;
      this._backgroundColor = 0;
      this._backgroundColorRgba = [0, 0, 0, 1];
      this._backgroundColorString = "#000000";
      this.color = this._backgroundColor;
      this.alpha = 1;
    }
    init(options) {
      this.clearBeforeRender = options.clearBeforeRender;
      if (options.color) {
        this.color = typeof options.color === "string" ? string2hex(options.color) : options.color;
      }
      this.alpha = options.alpha;
    }
    get color() {
      return this._backgroundColor;
    }
    set color(value) {
      this._backgroundColor = value;
      this._backgroundColorString = hex2string(value);
      hex2rgb(value, this._backgroundColorRgba);
    }
    get alpha() {
      return this._backgroundColorRgba[3];
    }
    set alpha(value) {
      this._backgroundColorRgba[3] = value;
    }
    get colorRgba() {
      return this._backgroundColorRgba;
    }
    get colorString() {
      return this._backgroundColorString;
    }
    destroy() {
    }
  };
  BackgroundSystem.extension = {
    type: [
      ExtensionType.RendererSystem,
      ExtensionType.CanvasRendererSystem
    ],
    name: "background"
  };
  extensions.add(BackgroundSystem);

  // node_modules/pixijs/core/batch/BatchSystem.mjs
  var BatchSystem = class {
    constructor(renderer) {
      this.renderer = renderer;
      this.emptyRenderer = new ObjectRenderer(renderer);
      this.currentRenderer = this.emptyRenderer;
    }
    setObjectRenderer(objectRenderer) {
      if (this.currentRenderer === objectRenderer) {
        return;
      }
      this.currentRenderer.stop();
      this.currentRenderer = objectRenderer;
      this.currentRenderer.start();
    }
    flush() {
      this.setObjectRenderer(this.emptyRenderer);
    }
    reset() {
      this.setObjectRenderer(this.emptyRenderer);
    }
    copyBoundTextures(arr, maxTextures) {
      const { boundTextures } = this.renderer.texture;
      for (let i = maxTextures - 1; i >= 0; --i) {
        arr[i] = boundTextures[i] || null;
        if (arr[i]) {
          arr[i]._batchLocation = i;
        }
      }
    }
    boundArray(texArray, boundTextures, batchId, maxTextures) {
      const { elements, ids, count } = texArray;
      let j = 0;
      for (let i = 0; i < count; i++) {
        const tex = elements[i];
        const loc = tex._batchLocation;
        if (loc >= 0 && loc < maxTextures && boundTextures[loc] === tex) {
          ids[i] = loc;
          continue;
        }
        while (j < maxTextures) {
          const bound = boundTextures[j];
          if (bound && bound._batchEnabled === batchId && bound._batchLocation === j) {
            j++;
            continue;
          }
          ids[i] = j;
          tex._batchLocation = j;
          boundTextures[j] = tex;
          break;
        }
      }
    }
    destroy() {
      this.renderer = null;
    }
  };
  BatchSystem.extension = {
    type: ExtensionType.RendererSystem,
    name: "batch"
  };
  extensions.add(BatchSystem);

  // node_modules/pixijs/core/context/ContextSystem.mjs
  var CONTEXT_UID_COUNTER = 0;
  var ContextSystem = class {
    constructor(renderer) {
      this.renderer = renderer;
      this.webGLVersion = 1;
      this.extensions = {};
      this.supports = {
        uint32Indices: false
      };
      this.handleContextLost = this.handleContextLost.bind(this);
      this.handleContextRestored = this.handleContextRestored.bind(this);
    }
    get isLost() {
      return !this.gl || this.gl.isContextLost();
    }
    contextChange(gl) {
      this.gl = gl;
      this.renderer.gl = gl;
      this.renderer.CONTEXT_UID = CONTEXT_UID_COUNTER++;
    }
    init(options) {
      if (options.context) {
        this.initFromContext(options.context);
      } else {
        const alpha = this.renderer.background.alpha < 1;
        const premultipliedAlpha = options.premultipliedAlpha;
        this.preserveDrawingBuffer = options.preserveDrawingBuffer;
        this.useContextAlpha = options.useContextAlpha;
        this.powerPreference = options.powerPreference;
        this.initFromOptions({
          alpha,
          premultipliedAlpha,
          antialias: options.antialias,
          stencil: true,
          preserveDrawingBuffer: options.preserveDrawingBuffer,
          powerPreference: options.powerPreference
        });
      }
    }
    initFromContext(gl) {
      this.gl = gl;
      this.validateContext(gl);
      this.renderer.gl = gl;
      this.renderer.CONTEXT_UID = CONTEXT_UID_COUNTER++;
      this.renderer.runners.contextChange.emit(gl);
      const view = this.renderer.view;
      if (view.addEventListener !== void 0) {
        view.addEventListener("webglcontextlost", this.handleContextLost, false);
        view.addEventListener("webglcontextrestored", this.handleContextRestored, false);
      }
    }
    initFromOptions(options) {
      const gl = this.createContext(this.renderer.view, options);
      this.initFromContext(gl);
    }
    createContext(canvas, options) {
      let gl;
      if (settings.PREFER_ENV >= ENV.WEBGL2) {
        gl = canvas.getContext("webgl2", options);
      }
      if (gl) {
        this.webGLVersion = 2;
      } else {
        this.webGLVersion = 1;
        gl = canvas.getContext("webgl", options) || canvas.getContext("experimental-webgl", options);
        if (!gl) {
          throw new Error("This browser does not support WebGL. Try using the canvas renderer");
        }
      }
      this.gl = gl;
      this.getExtensions();
      return this.gl;
    }
    getExtensions() {
      const { gl } = this;
      const common = {
        loseContext: gl.getExtension("WEBGL_lose_context"),
        anisotropicFiltering: gl.getExtension("EXT_texture_filter_anisotropic"),
        floatTextureLinear: gl.getExtension("OES_texture_float_linear"),
        s3tc: gl.getExtension("WEBGL_compressed_texture_s3tc"),
        s3tc_sRGB: gl.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
        etc: gl.getExtension("WEBGL_compressed_texture_etc"),
        etc1: gl.getExtension("WEBGL_compressed_texture_etc1"),
        pvrtc: gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
        atc: gl.getExtension("WEBGL_compressed_texture_atc"),
        astc: gl.getExtension("WEBGL_compressed_texture_astc")
      };
      if (this.webGLVersion === 1) {
        Object.assign(this.extensions, common, {
          drawBuffers: gl.getExtension("WEBGL_draw_buffers"),
          depthTexture: gl.getExtension("WEBGL_depth_texture"),
          vertexArrayObject: gl.getExtension("OES_vertex_array_object") || gl.getExtension("MOZ_OES_vertex_array_object") || gl.getExtension("WEBKIT_OES_vertex_array_object"),
          uint32ElementIndex: gl.getExtension("OES_element_index_uint"),
          floatTexture: gl.getExtension("OES_texture_float"),
          floatTextureLinear: gl.getExtension("OES_texture_float_linear"),
          textureHalfFloat: gl.getExtension("OES_texture_half_float"),
          textureHalfFloatLinear: gl.getExtension("OES_texture_half_float_linear")
        });
      } else if (this.webGLVersion === 2) {
        Object.assign(this.extensions, common, {
          colorBufferFloat: gl.getExtension("EXT_color_buffer_float")
        });
      }
    }
    handleContextLost(event) {
      event.preventDefault();
      setTimeout(() => {
        if (this.gl.isContextLost() && this.extensions.loseContext) {
          this.extensions.loseContext.restoreContext();
        }
      }, 0);
    }
    handleContextRestored() {
      this.renderer.runners.contextChange.emit(this.gl);
    }
    destroy() {
      const view = this.renderer.view;
      this.renderer = null;
      if (view.removeEventListener !== void 0) {
        view.removeEventListener("webglcontextlost", this.handleContextLost);
        view.removeEventListener("webglcontextrestored", this.handleContextRestored);
      }
      this.gl.useProgram(null);
      if (this.extensions.loseContext) {
        this.extensions.loseContext.loseContext();
      }
    }
    postrender() {
      if (this.renderer.objectRenderer.renderingToScreen) {
        this.gl.flush();
      }
    }
    validateContext(gl) {
      const attributes = gl.getContextAttributes();
      const isWebGl2 = "WebGL2RenderingContext" in globalThis && gl instanceof globalThis.WebGL2RenderingContext;
      if (isWebGl2) {
        this.webGLVersion = 2;
      }
      if (attributes && !attributes.stencil) {
        console.warn("Provided WebGL context does not have a stencil buffer, masks may not render correctly");
      }
      const hasuint32 = isWebGl2 || !!gl.getExtension("OES_element_index_uint");
      this.supports.uint32Indices = hasuint32;
      if (!hasuint32) {
        console.warn("Provided WebGL context does not support 32 index buffer, complex graphics may not render correctly");
      }
    }
  };
  ContextSystem.extension = {
    type: ExtensionType.RendererSystem,
    name: "context"
  };
  extensions.add(ContextSystem);

  // node_modules/pixijs/core/textures/resources/DepthResource.mjs
  var DepthResource = class extends BufferResource {
    upload(renderer, baseTexture, glTexture) {
      const gl = renderer.gl;
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.alphaMode === ALPHA_MODES.UNPACK);
      const width = baseTexture.realWidth;
      const height = baseTexture.realHeight;
      if (glTexture.width === width && glTexture.height === height) {
        gl.texSubImage2D(baseTexture.target, 0, 0, 0, width, height, baseTexture.format, glTexture.type, this.data);
      } else {
        glTexture.width = width;
        glTexture.height = height;
        gl.texImage2D(baseTexture.target, 0, glTexture.internalFormat, width, height, 0, baseTexture.format, glTexture.type, this.data);
      }
      return true;
    }
  };

  // node_modules/pixijs/core/framebuffer/Framebuffer.mjs
  var Framebuffer = class {
    constructor(width, height) {
      this.width = Math.round(width || 100);
      this.height = Math.round(height || 100);
      this.stencil = false;
      this.depth = false;
      this.dirtyId = 0;
      this.dirtyFormat = 0;
      this.dirtySize = 0;
      this.depthTexture = null;
      this.colorTextures = [];
      this.glFramebuffers = {};
      this.disposeRunner = new Runner("disposeFramebuffer");
      this.multisample = MSAA_QUALITY.NONE;
    }
    get colorTexture() {
      return this.colorTextures[0];
    }
    addColorTexture(index2 = 0, texture) {
      this.colorTextures[index2] = texture || new BaseTexture(null, {
        scaleMode: SCALE_MODES.NEAREST,
        resolution: 1,
        mipmap: MIPMAP_MODES.OFF,
        width: this.width,
        height: this.height
      });
      this.dirtyId++;
      this.dirtyFormat++;
      return this;
    }
    addDepthTexture(texture) {
      this.depthTexture = texture || new BaseTexture(new DepthResource(null, { width: this.width, height: this.height }), {
        scaleMode: SCALE_MODES.NEAREST,
        resolution: 1,
        width: this.width,
        height: this.height,
        mipmap: MIPMAP_MODES.OFF,
        format: FORMATS.DEPTH_COMPONENT,
        type: TYPES.UNSIGNED_SHORT
      });
      this.dirtyId++;
      this.dirtyFormat++;
      return this;
    }
    enableDepth() {
      this.depth = true;
      this.dirtyId++;
      this.dirtyFormat++;
      return this;
    }
    enableStencil() {
      this.stencil = true;
      this.dirtyId++;
      this.dirtyFormat++;
      return this;
    }
    resize(width, height) {
      width = Math.round(width);
      height = Math.round(height);
      if (width === this.width && height === this.height)
        return;
      this.width = width;
      this.height = height;
      this.dirtyId++;
      this.dirtySize++;
      for (let i = 0; i < this.colorTextures.length; i++) {
        const texture = this.colorTextures[i];
        const resolution = texture.resolution;
        texture.setSize(width / resolution, height / resolution);
      }
      if (this.depthTexture) {
        const resolution = this.depthTexture.resolution;
        this.depthTexture.setSize(width / resolution, height / resolution);
      }
    }
    dispose() {
      this.disposeRunner.emit(this, false);
    }
    destroyDepthTexture() {
      if (this.depthTexture) {
        this.depthTexture.destroy();
        this.depthTexture = null;
        ++this.dirtyId;
        ++this.dirtyFormat;
      }
    }
  };

  // node_modules/pixijs/core/renderTexture/BaseRenderTexture.mjs
  var BaseRenderTexture = class extends BaseTexture {
    constructor(options = {}) {
      var _a;
      if (typeof options === "number") {
        const width = arguments[0];
        const height = arguments[1];
        const scaleMode = arguments[2];
        const resolution = arguments[3];
        options = { width, height, scaleMode, resolution };
      }
      options.width = options.width || 100;
      options.height = options.height || 100;
      (_a = options.multisample) != null ? _a : options.multisample = MSAA_QUALITY.NONE;
      super(null, options);
      this.mipmap = MIPMAP_MODES.OFF;
      this.valid = true;
      this.clearColor = [0, 0, 0, 0];
      this.framebuffer = new Framebuffer(this.realWidth, this.realHeight).addColorTexture(0, this);
      this.framebuffer.multisample = options.multisample;
      this.maskStack = [];
      this.filterStack = [{}];
    }
    resize(desiredWidth, desiredHeight) {
      this.framebuffer.resize(desiredWidth * this.resolution, desiredHeight * this.resolution);
      this.setRealSize(this.framebuffer.width, this.framebuffer.height);
    }
    dispose() {
      this.framebuffer.dispose();
      super.dispose();
    }
    destroy() {
      super.destroy();
      this.framebuffer.destroyDepthTexture();
      this.framebuffer = null;
    }
  };

  // node_modules/pixijs/core/textures/resources/BaseImageResource.mjs
  var BaseImageResource = class extends Resource {
    constructor(source) {
      const sourceAny = source;
      const width = sourceAny.naturalWidth || sourceAny.videoWidth || sourceAny.width;
      const height = sourceAny.naturalHeight || sourceAny.videoHeight || sourceAny.height;
      super(width, height);
      this.source = source;
      this.noSubImage = false;
    }
    static crossOrigin(element, url2, crossorigin) {
      if (crossorigin === void 0 && !url2.startsWith("data:")) {
        element.crossOrigin = determineCrossOrigin(url2);
      } else if (crossorigin !== false) {
        element.crossOrigin = typeof crossorigin === "string" ? crossorigin : "anonymous";
      }
    }
    upload(renderer, baseTexture, glTexture, source) {
      const gl = renderer.gl;
      const width = baseTexture.realWidth;
      const height = baseTexture.realHeight;
      source = source || this.source;
      if (typeof HTMLImageElement !== "undefined" && source instanceof HTMLImageElement) {
        if (!source.complete || source.naturalWidth === 0) {
          return false;
        }
      } else if (typeof HTMLVideoElement !== "undefined" && source instanceof HTMLVideoElement) {
        if (source.readyState <= 1 && source.buffered.length === 0) {
          return false;
        }
      }
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.alphaMode === ALPHA_MODES.UNPACK);
      if (!this.noSubImage && baseTexture.target === gl.TEXTURE_2D && glTexture.width === width && glTexture.height === height) {
        gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, baseTexture.format, glTexture.type, source);
      } else {
        glTexture.width = width;
        glTexture.height = height;
        gl.texImage2D(baseTexture.target, 0, glTexture.internalFormat, baseTexture.format, glTexture.type, source);
      }
      return true;
    }
    update() {
      if (this.destroyed) {
        return;
      }
      const source = this.source;
      const width = source.naturalWidth || source.videoWidth || source.width;
      const height = source.naturalHeight || source.videoHeight || source.height;
      this.resize(width, height);
      super.update();
    }
    dispose() {
      this.source = null;
    }
  };

  // node_modules/pixijs/core/textures/resources/ImageResource.mjs
  var ImageResource = class extends BaseImageResource {
    constructor(source, options) {
      var _a;
      options = options || {};
      if (typeof source === "string") {
        const imageElement = new Image();
        BaseImageResource.crossOrigin(imageElement, source, options.crossorigin);
        imageElement.src = source;
        source = imageElement;
      }
      super(source);
      if (!source.complete && !!this._width && !!this._height) {
        this._width = 0;
        this._height = 0;
      }
      this.url = source.src;
      this._process = null;
      this.preserveBitmap = false;
      this.createBitmap = ((_a = options.createBitmap) != null ? _a : settings.CREATE_IMAGE_BITMAP) && !!globalThis.createImageBitmap;
      this.alphaMode = typeof options.alphaMode === "number" ? options.alphaMode : null;
      this.bitmap = null;
      this._load = null;
      if (options.autoLoad !== false) {
        this.load();
      }
    }
    load(createBitmap) {
      if (this._load) {
        return this._load;
      }
      if (createBitmap !== void 0) {
        this.createBitmap = createBitmap;
      }
      this._load = new Promise((resolve2, reject) => {
        const source = this.source;
        this.url = source.src;
        const completed = () => {
          if (this.destroyed) {
            return;
          }
          source.onload = null;
          source.onerror = null;
          this.resize(source.width, source.height);
          this._load = null;
          if (this.createBitmap) {
            resolve2(this.process());
          } else {
            resolve2(this);
          }
        };
        if (source.complete && source.src) {
          completed();
        } else {
          source.onload = completed;
          source.onerror = (event) => {
            reject(event);
            this.onError.emit(event);
          };
        }
      });
      return this._load;
    }
    process() {
      const source = this.source;
      if (this._process !== null) {
        return this._process;
      }
      if (this.bitmap !== null || !globalThis.createImageBitmap) {
        return Promise.resolve(this);
      }
      const createImageBitmap2 = globalThis.createImageBitmap;
      const cors = !source.crossOrigin || source.crossOrigin === "anonymous";
      this._process = fetch(source.src, {
        mode: cors ? "cors" : "no-cors"
      }).then((r) => r.blob()).then((blob) => createImageBitmap2(blob, 0, 0, source.width, source.height, {
        premultiplyAlpha: this.alphaMode === null || this.alphaMode === ALPHA_MODES.UNPACK ? "premultiply" : "none"
      })).then((bitmap) => {
        if (this.destroyed) {
          return Promise.reject();
        }
        this.bitmap = bitmap;
        this.update();
        this._process = null;
        return Promise.resolve(this);
      });
      return this._process;
    }
    upload(renderer, baseTexture, glTexture) {
      if (typeof this.alphaMode === "number") {
        baseTexture.alphaMode = this.alphaMode;
      }
      if (!this.createBitmap) {
        return super.upload(renderer, baseTexture, glTexture);
      }
      if (!this.bitmap) {
        this.process();
        if (!this.bitmap) {
          return false;
        }
      }
      super.upload(renderer, baseTexture, glTexture, this.bitmap);
      if (!this.preserveBitmap) {
        let flag = true;
        const glTextures = baseTexture._glTextures;
        for (const key in glTextures) {
          const otherTex = glTextures[key];
          if (otherTex !== glTexture && otherTex.dirtyId !== baseTexture.dirtyId) {
            flag = false;
            break;
          }
        }
        if (flag) {
          if (this.bitmap.close) {
            this.bitmap.close();
          }
          this.bitmap = null;
        }
      }
      return true;
    }
    dispose() {
      this.source.onload = null;
      this.source.onerror = null;
      super.dispose();
      if (this.bitmap) {
        this.bitmap.close();
        this.bitmap = null;
      }
      this._process = null;
      this._load = null;
    }
    static test(source) {
      return typeof HTMLImageElement !== "undefined" && (typeof source === "string" || source instanceof HTMLImageElement);
    }
  };

  // node_modules/pixijs/core/textures/TextureUvs.mjs
  var TextureUvs = class {
    constructor() {
      this.x0 = 0;
      this.y0 = 0;
      this.x1 = 1;
      this.y1 = 0;
      this.x2 = 1;
      this.y2 = 1;
      this.x3 = 0;
      this.y3 = 1;
      this.uvsFloat32 = new Float32Array(8);
    }
    set(frame2, baseFrame, rotate) {
      const tw = baseFrame.width;
      const th = baseFrame.height;
      if (rotate) {
        const w2 = frame2.width / 2 / tw;
        const h2 = frame2.height / 2 / th;
        const cX = frame2.x / tw + w2;
        const cY = frame2.y / th + h2;
        rotate = groupD8.add(rotate, groupD8.NW);
        this.x0 = cX + w2 * groupD8.uX(rotate);
        this.y0 = cY + h2 * groupD8.uY(rotate);
        rotate = groupD8.add(rotate, 2);
        this.x1 = cX + w2 * groupD8.uX(rotate);
        this.y1 = cY + h2 * groupD8.uY(rotate);
        rotate = groupD8.add(rotate, 2);
        this.x2 = cX + w2 * groupD8.uX(rotate);
        this.y2 = cY + h2 * groupD8.uY(rotate);
        rotate = groupD8.add(rotate, 2);
        this.x3 = cX + w2 * groupD8.uX(rotate);
        this.y3 = cY + h2 * groupD8.uY(rotate);
      } else {
        this.x0 = frame2.x / tw;
        this.y0 = frame2.y / th;
        this.x1 = (frame2.x + frame2.width) / tw;
        this.y1 = frame2.y / th;
        this.x2 = (frame2.x + frame2.width) / tw;
        this.y2 = (frame2.y + frame2.height) / th;
        this.x3 = frame2.x / tw;
        this.y3 = (frame2.y + frame2.height) / th;
      }
      this.uvsFloat32[0] = this.x0;
      this.uvsFloat32[1] = this.y0;
      this.uvsFloat32[2] = this.x1;
      this.uvsFloat32[3] = this.y1;
      this.uvsFloat32[4] = this.x2;
      this.uvsFloat32[5] = this.y2;
      this.uvsFloat32[6] = this.x3;
      this.uvsFloat32[7] = this.y3;
    }
    toString() {
      return `[pixijs/core:TextureUvs x0=${this.x0} y0=${this.y0} x1=${this.x1} y1=${this.y1} x2=${this.x2} y2=${this.y2} x3=${this.x3} y3=${this.y3}]`;
    }
  };

  // node_modules/pixijs/core/textures/Texture.mjs
  var DEFAULT_UVS = new TextureUvs();
  function removeAllHandlers(tex) {
    tex.destroy = function _emptyDestroy() {
    };
    tex.on = function _emptyOn() {
    };
    tex.once = function _emptyOnce() {
    };
    tex.emit = function _emptyEmit() {
    };
  }
  var Texture = class extends import_eventemitter3.default {
    constructor(baseTexture, frame2, orig, trim, rotate, anchor) {
      super();
      this.noFrame = false;
      if (!frame2) {
        this.noFrame = true;
        frame2 = new Rectangle(0, 0, 1, 1);
      }
      if (baseTexture instanceof Texture) {
        baseTexture = baseTexture.baseTexture;
      }
      this.baseTexture = baseTexture;
      this._frame = frame2;
      this.trim = trim;
      this.valid = false;
      this._uvs = DEFAULT_UVS;
      this.uvMatrix = null;
      this.orig = orig || frame2;
      this._rotate = Number(rotate || 0);
      if (rotate === true) {
        this._rotate = 2;
      } else if (this._rotate % 2 !== 0) {
        throw new Error("attempt to use diamond-shaped UVs. If you are sure, set rotation manually");
      }
      this.defaultAnchor = anchor ? new Point(anchor.x, anchor.y) : new Point(0, 0);
      this._updateID = 0;
      this.textureCacheIds = [];
      if (!baseTexture.valid) {
        baseTexture.once("loaded", this.onBaseTextureUpdated, this);
      } else if (this.noFrame) {
        if (baseTexture.valid) {
          this.onBaseTextureUpdated(baseTexture);
        }
      } else {
        this.frame = frame2;
      }
      if (this.noFrame) {
        baseTexture.on("update", this.onBaseTextureUpdated, this);
      }
    }
    update() {
      if (this.baseTexture.resource) {
        this.baseTexture.resource.update();
      }
    }
    onBaseTextureUpdated(baseTexture) {
      if (this.noFrame) {
        if (!this.baseTexture.valid) {
          return;
        }
        this._frame.width = baseTexture.width;
        this._frame.height = baseTexture.height;
        this.valid = true;
        this.updateUvs();
      } else {
        this.frame = this._frame;
      }
      this.emit("update", this);
    }
    destroy(destroyBase) {
      if (this.baseTexture) {
        if (destroyBase) {
          const { resource } = this.baseTexture;
          if ((resource == null ? void 0 : resource.url) && TextureCache[resource.url]) {
            Texture.removeFromCache(resource.url);
          }
          this.baseTexture.destroy();
        }
        this.baseTexture.off("loaded", this.onBaseTextureUpdated, this);
        this.baseTexture.off("update", this.onBaseTextureUpdated, this);
        this.baseTexture = null;
      }
      this._frame = null;
      this._uvs = null;
      this.trim = null;
      this.orig = null;
      this.valid = false;
      Texture.removeFromCache(this);
      this.textureCacheIds = null;
    }
    clone() {
      var _a;
      const clonedFrame = this._frame.clone();
      const clonedOrig = this._frame === this.orig ? clonedFrame : this.orig.clone();
      const clonedTexture = new Texture(this.baseTexture, !this.noFrame && clonedFrame, clonedOrig, (_a = this.trim) == null ? void 0 : _a.clone(), this.rotate, this.defaultAnchor);
      if (this.noFrame) {
        clonedTexture._frame = clonedFrame;
      }
      return clonedTexture;
    }
    updateUvs() {
      if (this._uvs === DEFAULT_UVS) {
        this._uvs = new TextureUvs();
      }
      this._uvs.set(this._frame, this.baseTexture, this.rotate);
      this._updateID++;
    }
    static from(source, options = {}, strict = settings.STRICT_TEXTURE_CACHE) {
      const isFrame = typeof source === "string";
      let cacheId = null;
      if (isFrame) {
        cacheId = source;
      } else if (source instanceof BaseTexture) {
        if (!source.cacheId) {
          const prefix = (options == null ? void 0 : options.pixiIdPrefix) || "pixiid";
          source.cacheId = `${prefix}-${uid()}`;
          BaseTexture.addToCache(source, source.cacheId);
        }
        cacheId = source.cacheId;
      } else {
        if (!source._pixiId) {
          const prefix = (options == null ? void 0 : options.pixiIdPrefix) || "pixiid";
          source._pixiId = `${prefix}_${uid()}`;
        }
        cacheId = source._pixiId;
      }
      let texture = TextureCache[cacheId];
      if (isFrame && strict && !texture) {
        throw new Error(`The cacheId "${cacheId}" does not exist in TextureCache.`);
      }
      if (!texture && !(source instanceof BaseTexture)) {
        if (!options.resolution) {
          options.resolution = getResolutionOfUrl(source);
        }
        texture = new Texture(new BaseTexture(source, options));
        texture.baseTexture.cacheId = cacheId;
        BaseTexture.addToCache(texture.baseTexture, cacheId);
        Texture.addToCache(texture, cacheId);
      } else if (!texture && source instanceof BaseTexture) {
        texture = new Texture(source);
        Texture.addToCache(texture, cacheId);
      }
      return texture;
    }
    static fromURL(url2, options) {
      const resourceOptions = Object.assign({ autoLoad: false }, options == null ? void 0 : options.resourceOptions);
      const texture = Texture.from(url2, Object.assign({ resourceOptions }, options), false);
      const resource = texture.baseTexture.resource;
      if (texture.baseTexture.valid) {
        return Promise.resolve(texture);
      }
      return resource.load().then(() => Promise.resolve(texture));
    }
    static fromBuffer(buffer, width, height, options) {
      return new Texture(BaseTexture.fromBuffer(buffer, width, height, options));
    }
    static fromLoader(source, imageUrl, name, options) {
      const baseTexture = new BaseTexture(source, Object.assign({
        scaleMode: BaseTexture.defaultOptions.scaleMode,
        resolution: getResolutionOfUrl(imageUrl)
      }, options));
      const { resource } = baseTexture;
      if (resource instanceof ImageResource) {
        resource.url = imageUrl;
      }
      const texture = new Texture(baseTexture);
      if (!name) {
        name = imageUrl;
      }
      BaseTexture.addToCache(texture.baseTexture, name);
      Texture.addToCache(texture, name);
      if (name !== imageUrl) {
        BaseTexture.addToCache(texture.baseTexture, imageUrl);
        Texture.addToCache(texture, imageUrl);
      }
      if (texture.baseTexture.valid) {
        return Promise.resolve(texture);
      }
      return new Promise((resolve2) => {
        texture.baseTexture.once("loaded", () => resolve2(texture));
      });
    }
    static addToCache(texture, id2) {
      if (id2) {
        if (!texture.textureCacheIds.includes(id2)) {
          texture.textureCacheIds.push(id2);
        }
        if (TextureCache[id2] && TextureCache[id2] !== texture) {
          console.warn(`Texture added to the cache with an id [${id2}] that already had an entry`);
        }
        TextureCache[id2] = texture;
      }
    }
    static removeFromCache(texture) {
      if (typeof texture === "string") {
        const textureFromCache = TextureCache[texture];
        if (textureFromCache) {
          const index2 = textureFromCache.textureCacheIds.indexOf(texture);
          if (index2 > -1) {
            textureFromCache.textureCacheIds.splice(index2, 1);
          }
          delete TextureCache[texture];
          return textureFromCache;
        }
      } else if (texture == null ? void 0 : texture.textureCacheIds) {
        for (let i = 0; i < texture.textureCacheIds.length; ++i) {
          if (TextureCache[texture.textureCacheIds[i]] === texture) {
            delete TextureCache[texture.textureCacheIds[i]];
          }
        }
        texture.textureCacheIds.length = 0;
        return texture;
      }
      return null;
    }
    get resolution() {
      return this.baseTexture.resolution;
    }
    get frame() {
      return this._frame;
    }
    set frame(frame2) {
      this._frame = frame2;
      this.noFrame = false;
      const { x: x3, y: y3, width, height } = frame2;
      const xNotFit = x3 + width > this.baseTexture.width;
      const yNotFit = y3 + height > this.baseTexture.height;
      if (xNotFit || yNotFit) {
        const relationship = xNotFit && yNotFit ? "and" : "or";
        const errorX = `X: ${x3} + ${width} = ${x3 + width} > ${this.baseTexture.width}`;
        const errorY = `Y: ${y3} + ${height} = ${y3 + height} > ${this.baseTexture.height}`;
        throw new Error(`Texture Error: frame does not fit inside the base Texture dimensions: ${errorX} ${relationship} ${errorY}`);
      }
      this.valid = width && height && this.baseTexture.valid;
      if (!this.trim && !this.rotate) {
        this.orig = frame2;
      }
      if (this.valid) {
        this.updateUvs();
      }
    }
    get rotate() {
      return this._rotate;
    }
    set rotate(rotate) {
      this._rotate = rotate;
      if (this.valid) {
        this.updateUvs();
      }
    }
    get width() {
      return this.orig.width;
    }
    get height() {
      return this.orig.height;
    }
    castToBaseTexture() {
      return this.baseTexture;
    }
    static get EMPTY() {
      if (!Texture._EMPTY) {
        Texture._EMPTY = new Texture(new BaseTexture());
        removeAllHandlers(Texture._EMPTY);
        removeAllHandlers(Texture._EMPTY.baseTexture);
      }
      return Texture._EMPTY;
    }
    static get WHITE() {
      if (!Texture._WHITE) {
        const canvas = settings.ADAPTER.createCanvas(16, 16);
        const context2 = canvas.getContext("2d");
        canvas.width = 16;
        canvas.height = 16;
        context2.fillStyle = "white";
        context2.fillRect(0, 0, 16, 16);
        Texture._WHITE = new Texture(BaseTexture.from(canvas));
        removeAllHandlers(Texture._WHITE);
        removeAllHandlers(Texture._WHITE.baseTexture);
      }
      return Texture._WHITE;
    }
  };

  // node_modules/pixijs/core/renderTexture/RenderTexture.mjs
  var RenderTexture = class extends Texture {
    constructor(baseRenderTexture, frame2) {
      super(baseRenderTexture, frame2);
      this.valid = true;
      this.filterFrame = null;
      this.filterPoolKey = null;
      this.updateUvs();
    }
    get framebuffer() {
      return this.baseTexture.framebuffer;
    }
    get multisample() {
      return this.framebuffer.multisample;
    }
    set multisample(value) {
      this.framebuffer.multisample = value;
    }
    resize(desiredWidth, desiredHeight, resizeBaseTexture = true) {
      const resolution = this.baseTexture.resolution;
      const width = Math.round(desiredWidth * resolution) / resolution;
      const height = Math.round(desiredHeight * resolution) / resolution;
      this.valid = width > 0 && height > 0;
      this._frame.width = this.orig.width = width;
      this._frame.height = this.orig.height = height;
      if (resizeBaseTexture) {
        this.baseTexture.resize(width, height);
      }
      this.updateUvs();
    }
    setResolution(resolution) {
      const { baseTexture } = this;
      if (baseTexture.resolution === resolution) {
        return;
      }
      baseTexture.setResolution(resolution);
      this.resize(baseTexture.width, baseTexture.height, false);
    }
    static create(options) {
      return new RenderTexture(new BaseRenderTexture(options));
    }
  };

  // node_modules/pixijs/core/renderTexture/RenderTexturePool.mjs
  var RenderTexturePool = class {
    constructor(textureOptions) {
      this.texturePool = {};
      this.textureOptions = textureOptions || {};
      this.enableFullScreen = false;
      this._pixelsWidth = 0;
      this._pixelsHeight = 0;
    }
    createTexture(realWidth, realHeight, multisample = MSAA_QUALITY.NONE) {
      const baseRenderTexture = new BaseRenderTexture(Object.assign({
        width: realWidth,
        height: realHeight,
        resolution: 1,
        multisample
      }, this.textureOptions));
      return new RenderTexture(baseRenderTexture);
    }
    getOptimalTexture(minWidth, minHeight, resolution = 1, multisample = MSAA_QUALITY.NONE) {
      let key;
      minWidth = Math.ceil(minWidth * resolution - 1e-6);
      minHeight = Math.ceil(minHeight * resolution - 1e-6);
      if (!this.enableFullScreen || minWidth !== this._pixelsWidth || minHeight !== this._pixelsHeight) {
        minWidth = nextPow2(minWidth);
        minHeight = nextPow2(minHeight);
        key = ((minWidth & 65535) << 16 | minHeight & 65535) >>> 0;
        if (multisample > 1) {
          key += multisample * 4294967296;
        }
      } else {
        key = multisample > 1 ? -multisample : -1;
      }
      if (!this.texturePool[key]) {
        this.texturePool[key] = [];
      }
      let renderTexture = this.texturePool[key].pop();
      if (!renderTexture) {
        renderTexture = this.createTexture(minWidth, minHeight, multisample);
      }
      renderTexture.filterPoolKey = key;
      renderTexture.setResolution(resolution);
      return renderTexture;
    }
    getFilterTexture(input, resolution, multisample) {
      const filterTexture = this.getOptimalTexture(input.width, input.height, resolution || input.resolution, multisample || MSAA_QUALITY.NONE);
      filterTexture.filterFrame = input.filterFrame;
      return filterTexture;
    }
    returnTexture(renderTexture) {
      const key = renderTexture.filterPoolKey;
      renderTexture.filterFrame = null;
      this.texturePool[key].push(renderTexture);
    }
    returnFilterTexture(renderTexture) {
      this.returnTexture(renderTexture);
    }
    clear(destroyTextures) {
      destroyTextures = destroyTextures !== false;
      if (destroyTextures) {
        for (const i in this.texturePool) {
          const textures = this.texturePool[i];
          if (textures) {
            for (let j = 0; j < textures.length; j++) {
              textures[j].destroy(true);
            }
          }
        }
      }
      this.texturePool = {};
    }
    setScreenSize(size) {
      if (size.width === this._pixelsWidth && size.height === this._pixelsHeight) {
        return;
      }
      this.enableFullScreen = size.width > 0 && size.height > 0;
      for (const i in this.texturePool) {
        if (!(Number(i) < 0)) {
          continue;
        }
        const textures = this.texturePool[i];
        if (textures) {
          for (let j = 0; j < textures.length; j++) {
            textures[j].destroy(true);
          }
        }
        this.texturePool[i] = [];
      }
      this._pixelsWidth = size.width;
      this._pixelsHeight = size.height;
    }
  };
  RenderTexturePool.SCREEN_KEY = -1;

  // node_modules/pixijs/core/utils/Quad.mjs
  var Quad = class extends Geometry {
    constructor() {
      super();
      this.addAttribute("aVertexPosition", new Float32Array([
        0,
        0,
        1,
        0,
        1,
        1,
        0,
        1
      ])).addIndex([0, 1, 3, 2]);
    }
  };

  // node_modules/pixijs/core/utils/QuadUv.mjs
  var QuadUv = class extends Geometry {
    constructor() {
      super();
      this.vertices = new Float32Array([
        -1,
        -1,
        1,
        -1,
        1,
        1,
        -1,
        1
      ]);
      this.uvs = new Float32Array([
        0,
        0,
        1,
        0,
        1,
        1,
        0,
        1
      ]);
      this.vertexBuffer = new Buffer2(this.vertices);
      this.uvBuffer = new Buffer2(this.uvs);
      this.addAttribute("aVertexPosition", this.vertexBuffer).addAttribute("aTextureCoord", this.uvBuffer).addIndex([0, 1, 2, 0, 2, 3]);
    }
    map(targetTextureFrame, destinationFrame) {
      let x3 = 0;
      let y3 = 0;
      this.uvs[0] = x3;
      this.uvs[1] = y3;
      this.uvs[2] = x3 + destinationFrame.width / targetTextureFrame.width;
      this.uvs[3] = y3;
      this.uvs[4] = x3 + destinationFrame.width / targetTextureFrame.width;
      this.uvs[5] = y3 + destinationFrame.height / targetTextureFrame.height;
      this.uvs[6] = x3;
      this.uvs[7] = y3 + destinationFrame.height / targetTextureFrame.height;
      x3 = destinationFrame.x;
      y3 = destinationFrame.y;
      this.vertices[0] = x3;
      this.vertices[1] = y3;
      this.vertices[2] = x3 + destinationFrame.width;
      this.vertices[3] = y3;
      this.vertices[4] = x3 + destinationFrame.width;
      this.vertices[5] = y3 + destinationFrame.height;
      this.vertices[6] = x3;
      this.vertices[7] = y3 + destinationFrame.height;
      this.invalidate();
      return this;
    }
    invalidate() {
      this.vertexBuffer._updateID++;
      this.uvBuffer._updateID++;
      return this;
    }
  };

  // node_modules/pixijs/core/filters/FilterState.mjs
  var FilterState = class {
    constructor() {
      this.renderTexture = null;
      this.target = null;
      this.legacy = false;
      this.resolution = 1;
      this.multisample = MSAA_QUALITY.NONE;
      this.sourceFrame = new Rectangle();
      this.destinationFrame = new Rectangle();
      this.bindingSourceFrame = new Rectangle();
      this.bindingDestinationFrame = new Rectangle();
      this.filters = [];
      this.transform = null;
    }
    clear() {
      this.target = null;
      this.filters = null;
      this.renderTexture = null;
    }
  };

  // node_modules/pixijs/core/filters/FilterSystem.mjs
  var tempPoints2 = [new Point(), new Point(), new Point(), new Point()];
  var tempMatrix = new Matrix();
  var FilterSystem = class {
    constructor(renderer) {
      this.renderer = renderer;
      this.defaultFilterStack = [{}];
      this.texturePool = new RenderTexturePool();
      this.statePool = [];
      this.quad = new Quad();
      this.quadUv = new QuadUv();
      this.tempRect = new Rectangle();
      this.activeState = {};
      this.globalUniforms = new UniformGroup({
        outputFrame: new Rectangle(),
        inputSize: new Float32Array(4),
        inputPixel: new Float32Array(4),
        inputClamp: new Float32Array(4),
        resolution: 1,
        filterArea: new Float32Array(4),
        filterClamp: new Float32Array(4)
      }, true);
      this.forceClear = false;
      this.useMaxPadding = false;
    }
    init() {
      this.texturePool.setScreenSize(this.renderer.view);
    }
    push(target, filters2) {
      var _a, _b;
      const renderer = this.renderer;
      const filterStack = this.defaultFilterStack;
      const state = this.statePool.pop() || new FilterState();
      const renderTextureSystem = this.renderer.renderTexture;
      let resolution = filters2[0].resolution;
      let multisample = filters2[0].multisample;
      let padding = filters2[0].padding;
      let autoFit = filters2[0].autoFit;
      let legacy = (_a = filters2[0].legacy) != null ? _a : true;
      for (let i = 1; i < filters2.length; i++) {
        const filter2 = filters2[i];
        resolution = Math.min(resolution, filter2.resolution);
        multisample = Math.min(multisample, filter2.multisample);
        padding = this.useMaxPadding ? Math.max(padding, filter2.padding) : padding + filter2.padding;
        autoFit = autoFit && filter2.autoFit;
        legacy = legacy || ((_b = filter2.legacy) != null ? _b : true);
      }
      if (filterStack.length === 1) {
        this.defaultFilterStack[0].renderTexture = renderTextureSystem.current;
      }
      filterStack.push(state);
      state.resolution = resolution;
      state.multisample = multisample;
      state.legacy = legacy;
      state.target = target;
      state.sourceFrame.copyFrom(target.filterArea || target.getBounds(true));
      state.sourceFrame.pad(padding);
      const sourceFrameProjected = this.tempRect.copyFrom(renderTextureSystem.sourceFrame);
      if (renderer.projection.transform) {
        this.transformAABB(tempMatrix.copyFrom(renderer.projection.transform).invert(), sourceFrameProjected);
      }
      if (autoFit) {
        state.sourceFrame.fit(sourceFrameProjected);
        if (state.sourceFrame.width <= 0 || state.sourceFrame.height <= 0) {
          state.sourceFrame.width = 0;
          state.sourceFrame.height = 0;
        }
      } else if (!state.sourceFrame.intersects(sourceFrameProjected)) {
        state.sourceFrame.width = 0;
        state.sourceFrame.height = 0;
      }
      this.roundFrame(state.sourceFrame, renderTextureSystem.current ? renderTextureSystem.current.resolution : renderer.resolution, renderTextureSystem.sourceFrame, renderTextureSystem.destinationFrame, renderer.projection.transform);
      state.renderTexture = this.getOptimalFilterTexture(state.sourceFrame.width, state.sourceFrame.height, resolution, multisample);
      state.filters = filters2;
      state.destinationFrame.width = state.renderTexture.width;
      state.destinationFrame.height = state.renderTexture.height;
      const destinationFrame = this.tempRect;
      destinationFrame.x = 0;
      destinationFrame.y = 0;
      destinationFrame.width = state.sourceFrame.width;
      destinationFrame.height = state.sourceFrame.height;
      state.renderTexture.filterFrame = state.sourceFrame;
      state.bindingSourceFrame.copyFrom(renderTextureSystem.sourceFrame);
      state.bindingDestinationFrame.copyFrom(renderTextureSystem.destinationFrame);
      state.transform = renderer.projection.transform;
      renderer.projection.transform = null;
      renderTextureSystem.bind(state.renderTexture, state.sourceFrame, destinationFrame);
      renderer.framebuffer.clear(0, 0, 0, 0);
    }
    pop() {
      const filterStack = this.defaultFilterStack;
      const state = filterStack.pop();
      const filters2 = state.filters;
      this.activeState = state;
      const globalUniforms = this.globalUniforms.uniforms;
      globalUniforms.outputFrame = state.sourceFrame;
      globalUniforms.resolution = state.resolution;
      const inputSize = globalUniforms.inputSize;
      const inputPixel = globalUniforms.inputPixel;
      const inputClamp = globalUniforms.inputClamp;
      inputSize[0] = state.destinationFrame.width;
      inputSize[1] = state.destinationFrame.height;
      inputSize[2] = 1 / inputSize[0];
      inputSize[3] = 1 / inputSize[1];
      inputPixel[0] = Math.round(inputSize[0] * state.resolution);
      inputPixel[1] = Math.round(inputSize[1] * state.resolution);
      inputPixel[2] = 1 / inputPixel[0];
      inputPixel[3] = 1 / inputPixel[1];
      inputClamp[0] = 0.5 * inputPixel[2];
      inputClamp[1] = 0.5 * inputPixel[3];
      inputClamp[2] = state.sourceFrame.width * inputSize[2] - 0.5 * inputPixel[2];
      inputClamp[3] = state.sourceFrame.height * inputSize[3] - 0.5 * inputPixel[3];
      if (state.legacy) {
        const filterArea = globalUniforms.filterArea;
        filterArea[0] = state.destinationFrame.width;
        filterArea[1] = state.destinationFrame.height;
        filterArea[2] = state.sourceFrame.x;
        filterArea[3] = state.sourceFrame.y;
        globalUniforms.filterClamp = globalUniforms.inputClamp;
      }
      this.globalUniforms.update();
      const lastState = filterStack[filterStack.length - 1];
      this.renderer.framebuffer.blit();
      if (filters2.length === 1) {
        filters2[0].apply(this, state.renderTexture, lastState.renderTexture, CLEAR_MODES.BLEND, state);
        this.returnFilterTexture(state.renderTexture);
      } else {
        let flip = state.renderTexture;
        let flop = this.getOptimalFilterTexture(flip.width, flip.height, state.resolution);
        flop.filterFrame = flip.filterFrame;
        let i = 0;
        for (i = 0; i < filters2.length - 1; ++i) {
          if (i === 1 && state.multisample > 1) {
            flop = this.getOptimalFilterTexture(flip.width, flip.height, state.resolution);
            flop.filterFrame = flip.filterFrame;
          }
          filters2[i].apply(this, flip, flop, CLEAR_MODES.CLEAR, state);
          const t = flip;
          flip = flop;
          flop = t;
        }
        filters2[i].apply(this, flip, lastState.renderTexture, CLEAR_MODES.BLEND, state);
        if (i > 1 && state.multisample > 1) {
          this.returnFilterTexture(state.renderTexture);
        }
        this.returnFilterTexture(flip);
        this.returnFilterTexture(flop);
      }
      state.clear();
      this.statePool.push(state);
    }
    bindAndClear(filterTexture, clearMode = CLEAR_MODES.CLEAR) {
      const {
        renderTexture: renderTextureSystem,
        state: stateSystem
      } = this.renderer;
      if (filterTexture === this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture) {
        this.renderer.projection.transform = this.activeState.transform;
      } else {
        this.renderer.projection.transform = null;
      }
      if (filterTexture == null ? void 0 : filterTexture.filterFrame) {
        const destinationFrame = this.tempRect;
        destinationFrame.x = 0;
        destinationFrame.y = 0;
        destinationFrame.width = filterTexture.filterFrame.width;
        destinationFrame.height = filterTexture.filterFrame.height;
        renderTextureSystem.bind(filterTexture, filterTexture.filterFrame, destinationFrame);
      } else if (filterTexture !== this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture) {
        renderTextureSystem.bind(filterTexture);
      } else {
        this.renderer.renderTexture.bind(filterTexture, this.activeState.bindingSourceFrame, this.activeState.bindingDestinationFrame);
      }
      const autoClear = stateSystem.stateId & 1 || this.forceClear;
      if (clearMode === CLEAR_MODES.CLEAR || clearMode === CLEAR_MODES.BLIT && autoClear) {
        this.renderer.framebuffer.clear(0, 0, 0, 0);
      }
    }
    applyFilter(filter2, input, output, clearMode) {
      const renderer = this.renderer;
      renderer.state.set(filter2.state);
      this.bindAndClear(output, clearMode);
      filter2.uniforms.uSampler = input;
      filter2.uniforms.filterGlobals = this.globalUniforms;
      renderer.shader.bind(filter2);
      filter2.legacy = !!filter2.program.attributeData.aTextureCoord;
      if (filter2.legacy) {
        this.quadUv.map(input._frame, input.filterFrame);
        renderer.geometry.bind(this.quadUv);
        renderer.geometry.draw(DRAW_MODES.TRIANGLES);
      } else {
        renderer.geometry.bind(this.quad);
        renderer.geometry.draw(DRAW_MODES.TRIANGLE_STRIP);
      }
    }
    calculateSpriteMatrix(outputMatrix, sprite) {
      const { sourceFrame, destinationFrame } = this.activeState;
      const { orig } = sprite._texture;
      const mappedMatrix = outputMatrix.set(destinationFrame.width, 0, 0, destinationFrame.height, sourceFrame.x, sourceFrame.y);
      const worldTransform = sprite.worldTransform.copyTo(Matrix.TEMP_MATRIX);
      worldTransform.invert();
      mappedMatrix.prepend(worldTransform);
      mappedMatrix.scale(1 / orig.width, 1 / orig.height);
      mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);
      return mappedMatrix;
    }
    destroy() {
      this.renderer = null;
      this.texturePool.clear(false);
    }
    getOptimalFilterTexture(minWidth, minHeight, resolution = 1, multisample = MSAA_QUALITY.NONE) {
      return this.texturePool.getOptimalTexture(minWidth, minHeight, resolution, multisample);
    }
    getFilterTexture(input, resolution, multisample) {
      if (typeof input === "number") {
        const swap = input;
        input = resolution;
        resolution = swap;
      }
      input = input || this.activeState.renderTexture;
      const filterTexture = this.texturePool.getOptimalTexture(input.width, input.height, resolution || input.resolution, multisample || MSAA_QUALITY.NONE);
      filterTexture.filterFrame = input.filterFrame;
      return filterTexture;
    }
    returnFilterTexture(renderTexture) {
      this.texturePool.returnTexture(renderTexture);
    }
    emptyPool() {
      this.texturePool.clear(true);
    }
    resize() {
      this.texturePool.setScreenSize(this.renderer.view);
    }
    transformAABB(matrix, rect) {
      const lt = tempPoints2[0];
      const lb = tempPoints2[1];
      const rt = tempPoints2[2];
      const rb = tempPoints2[3];
      lt.set(rect.left, rect.top);
      lb.set(rect.left, rect.bottom);
      rt.set(rect.right, rect.top);
      rb.set(rect.right, rect.bottom);
      matrix.apply(lt, lt);
      matrix.apply(lb, lb);
      matrix.apply(rt, rt);
      matrix.apply(rb, rb);
      const x0 = Math.min(lt.x, lb.x, rt.x, rb.x);
      const y0 = Math.min(lt.y, lb.y, rt.y, rb.y);
      const x1 = Math.max(lt.x, lb.x, rt.x, rb.x);
      const y1 = Math.max(lt.y, lb.y, rt.y, rb.y);
      rect.x = x0;
      rect.y = y0;
      rect.width = x1 - x0;
      rect.height = y1 - y0;
    }
    roundFrame(frame2, resolution, bindingSourceFrame, bindingDestinationFrame, transform2) {
      if (frame2.width <= 0 || frame2.height <= 0 || bindingSourceFrame.width <= 0 || bindingSourceFrame.height <= 0) {
        return;
      }
      if (transform2) {
        const { a: a2, b, c: c2, d } = transform2;
        if ((Math.abs(b) > 1e-4 || Math.abs(c2) > 1e-4) && (Math.abs(a2) > 1e-4 || Math.abs(d) > 1e-4)) {
          return;
        }
      }
      transform2 = transform2 ? tempMatrix.copyFrom(transform2) : tempMatrix.identity();
      transform2.translate(-bindingSourceFrame.x, -bindingSourceFrame.y).scale(bindingDestinationFrame.width / bindingSourceFrame.width, bindingDestinationFrame.height / bindingSourceFrame.height).translate(bindingDestinationFrame.x, bindingDestinationFrame.y);
      this.transformAABB(transform2, frame2);
      frame2.ceil(resolution);
      this.transformAABB(transform2.invert(), frame2);
    }
  };
  FilterSystem.extension = {
    type: ExtensionType.RendererSystem,
    name: "filter"
  };
  extensions.add(FilterSystem);

  // node_modules/pixijs/core/framebuffer/GLFramebuffer.mjs
  var GLFramebuffer = class {
    constructor(framebuffer) {
      this.framebuffer = framebuffer;
      this.stencil = null;
      this.dirtyId = -1;
      this.dirtyFormat = -1;
      this.dirtySize = -1;
      this.multisample = MSAA_QUALITY.NONE;
      this.msaaBuffer = null;
      this.blitFramebuffer = null;
      this.mipLevel = 0;
    }
  };

  // node_modules/pixijs/core/framebuffer/FramebufferSystem.mjs
  var tempRectangle = new Rectangle();
  var FramebufferSystem = class {
    constructor(renderer) {
      this.renderer = renderer;
      this.managedFramebuffers = [];
      this.unknownFramebuffer = new Framebuffer(10, 10);
      this.msaaSamples = null;
    }
    contextChange() {
      this.disposeAll(true);
      const gl = this.gl = this.renderer.gl;
      this.CONTEXT_UID = this.renderer.CONTEXT_UID;
      this.current = this.unknownFramebuffer;
      this.viewport = new Rectangle();
      this.hasMRT = true;
      this.writeDepthTexture = true;
      if (this.renderer.context.webGLVersion === 1) {
        let nativeDrawBuffersExtension = this.renderer.context.extensions.drawBuffers;
        let nativeDepthTextureExtension = this.renderer.context.extensions.depthTexture;
        if (settings.PREFER_ENV === ENV.WEBGL_LEGACY) {
          nativeDrawBuffersExtension = null;
          nativeDepthTextureExtension = null;
        }
        if (nativeDrawBuffersExtension) {
          gl.drawBuffers = (activeTextures) => nativeDrawBuffersExtension.drawBuffersWEBGL(activeTextures);
        } else {
          this.hasMRT = false;
          gl.drawBuffers = () => {
          };
        }
        if (!nativeDepthTextureExtension) {
          this.writeDepthTexture = false;
        }
      } else {
        this.msaaSamples = gl.getInternalformatParameter(gl.RENDERBUFFER, gl.RGBA8, gl.SAMPLES);
      }
    }
    bind(framebuffer, frame2, mipLevel = 0) {
      const { gl } = this;
      if (framebuffer) {
        const fbo = framebuffer.glFramebuffers[this.CONTEXT_UID] || this.initFramebuffer(framebuffer);
        if (this.current !== framebuffer) {
          this.current = framebuffer;
          gl.bindFramebuffer(gl.FRAMEBUFFER, fbo.framebuffer);
        }
        if (fbo.mipLevel !== mipLevel) {
          framebuffer.dirtyId++;
          framebuffer.dirtyFormat++;
          fbo.mipLevel = mipLevel;
        }
        if (fbo.dirtyId !== framebuffer.dirtyId) {
          fbo.dirtyId = framebuffer.dirtyId;
          if (fbo.dirtyFormat !== framebuffer.dirtyFormat) {
            fbo.dirtyFormat = framebuffer.dirtyFormat;
            fbo.dirtySize = framebuffer.dirtySize;
            this.updateFramebuffer(framebuffer, mipLevel);
          } else if (fbo.dirtySize !== framebuffer.dirtySize) {
            fbo.dirtySize = framebuffer.dirtySize;
            this.resizeFramebuffer(framebuffer);
          }
        }
        for (let i = 0; i < framebuffer.colorTextures.length; i++) {
          const tex = framebuffer.colorTextures[i];
          this.renderer.texture.unbind(tex.parentTextureArray || tex);
        }
        if (framebuffer.depthTexture) {
          this.renderer.texture.unbind(framebuffer.depthTexture);
        }
        if (frame2) {
          const mipWidth = frame2.width >> mipLevel;
          const mipHeight = frame2.height >> mipLevel;
          const scale = mipWidth / frame2.width;
          this.setViewport(frame2.x * scale, frame2.y * scale, mipWidth, mipHeight);
        } else {
          const mipWidth = framebuffer.width >> mipLevel;
          const mipHeight = framebuffer.height >> mipLevel;
          this.setViewport(0, 0, mipWidth, mipHeight);
        }
      } else {
        if (this.current) {
          this.current = null;
          gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        }
        if (frame2) {
          this.setViewport(frame2.x, frame2.y, frame2.width, frame2.height);
        } else {
          this.setViewport(0, 0, this.renderer.width, this.renderer.height);
        }
      }
    }
    setViewport(x3, y3, width, height) {
      const v = this.viewport;
      x3 = Math.round(x3);
      y3 = Math.round(y3);
      width = Math.round(width);
      height = Math.round(height);
      if (v.width !== width || v.height !== height || v.x !== x3 || v.y !== y3) {
        v.x = x3;
        v.y = y3;
        v.width = width;
        v.height = height;
        this.gl.viewport(x3, y3, width, height);
      }
    }
    get size() {
      if (this.current) {
        return { x: 0, y: 0, width: this.current.width, height: this.current.height };
      }
      return { x: 0, y: 0, width: this.renderer.width, height: this.renderer.height };
    }
    clear(r, g, b, a2, mask = BUFFER_BITS.COLOR | BUFFER_BITS.DEPTH) {
      const { gl } = this;
      gl.clearColor(r, g, b, a2);
      gl.clear(mask);
    }
    initFramebuffer(framebuffer) {
      const { gl } = this;
      const fbo = new GLFramebuffer(gl.createFramebuffer());
      fbo.multisample = this.detectSamples(framebuffer.multisample);
      framebuffer.glFramebuffers[this.CONTEXT_UID] = fbo;
      this.managedFramebuffers.push(framebuffer);
      framebuffer.disposeRunner.add(this);
      return fbo;
    }
    resizeFramebuffer(framebuffer) {
      const { gl } = this;
      const fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
      if (fbo.stencil) {
        gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.stencil);
        if (fbo.msaaBuffer) {
          gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, gl.DEPTH24_STENCIL8, framebuffer.width, framebuffer.height);
        } else {
          gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, framebuffer.width, framebuffer.height);
        }
      }
      const colorTextures = framebuffer.colorTextures;
      let count = colorTextures.length;
      if (!gl.drawBuffers) {
        count = Math.min(count, 1);
      }
      for (let i = 0; i < count; i++) {
        const texture = colorTextures[i];
        const parentTexture = texture.parentTextureArray || texture;
        this.renderer.texture.bind(parentTexture, 0);
        if (i === 0 && fbo.msaaBuffer) {
          gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.msaaBuffer);
          gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, parentTexture._glTextures[this.CONTEXT_UID].internalFormat, framebuffer.width, framebuffer.height);
        }
      }
      if (framebuffer.depthTexture && this.writeDepthTexture) {
        this.renderer.texture.bind(framebuffer.depthTexture, 0);
      }
    }
    updateFramebuffer(framebuffer, mipLevel) {
      const { gl } = this;
      const fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
      const colorTextures = framebuffer.colorTextures;
      let count = colorTextures.length;
      if (!gl.drawBuffers) {
        count = Math.min(count, 1);
      }
      if (fbo.multisample > 1 && this.canMultisampleFramebuffer(framebuffer)) {
        fbo.msaaBuffer = fbo.msaaBuffer || gl.createRenderbuffer();
      } else if (fbo.msaaBuffer) {
        gl.deleteRenderbuffer(fbo.msaaBuffer);
        fbo.msaaBuffer = null;
        if (fbo.blitFramebuffer) {
          fbo.blitFramebuffer.dispose();
          fbo.blitFramebuffer = null;
        }
      }
      const activeTextures = [];
      for (let i = 0; i < count; i++) {
        const texture = colorTextures[i];
        const parentTexture = texture.parentTextureArray || texture;
        this.renderer.texture.bind(parentTexture, 0);
        if (i === 0 && fbo.msaaBuffer) {
          gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.msaaBuffer);
          gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, parentTexture._glTextures[this.CONTEXT_UID].internalFormat, framebuffer.width, framebuffer.height);
          gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, fbo.msaaBuffer);
        } else {
          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, texture.target, parentTexture._glTextures[this.CONTEXT_UID].texture, mipLevel);
          activeTextures.push(gl.COLOR_ATTACHMENT0 + i);
        }
      }
      if (activeTextures.length > 1) {
        gl.drawBuffers(activeTextures);
      }
      if (framebuffer.depthTexture) {
        const writeDepthTexture = this.writeDepthTexture;
        if (writeDepthTexture) {
          const depthTexture = framebuffer.depthTexture;
          this.renderer.texture.bind(depthTexture, 0);
          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, depthTexture._glTextures[this.CONTEXT_UID].texture, mipLevel);
        }
      }
      if ((framebuffer.stencil || framebuffer.depth) && !(framebuffer.depthTexture && this.writeDepthTexture)) {
        fbo.stencil = fbo.stencil || gl.createRenderbuffer();
        gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.stencil);
        if (fbo.msaaBuffer) {
          gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, gl.DEPTH24_STENCIL8, framebuffer.width, framebuffer.height);
        } else {
          gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, framebuffer.width, framebuffer.height);
        }
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, fbo.stencil);
      } else if (fbo.stencil) {
        gl.deleteRenderbuffer(fbo.stencil);
        fbo.stencil = null;
      }
    }
    canMultisampleFramebuffer(framebuffer) {
      return this.renderer.context.webGLVersion !== 1 && framebuffer.colorTextures.length <= 1 && !framebuffer.depthTexture;
    }
    detectSamples(samples) {
      const { msaaSamples } = this;
      let res = MSAA_QUALITY.NONE;
      if (samples <= 1 || msaaSamples === null) {
        return res;
      }
      for (let i = 0; i < msaaSamples.length; i++) {
        if (msaaSamples[i] <= samples) {
          res = msaaSamples[i];
          break;
        }
      }
      if (res === 1) {
        res = MSAA_QUALITY.NONE;
      }
      return res;
    }
    blit(framebuffer, sourcePixels, destPixels) {
      const { current, renderer, gl, CONTEXT_UID } = this;
      if (renderer.context.webGLVersion !== 2) {
        return;
      }
      if (!current) {
        return;
      }
      const fbo = current.glFramebuffers[CONTEXT_UID];
      if (!fbo) {
        return;
      }
      if (!framebuffer) {
        if (!fbo.msaaBuffer) {
          return;
        }
        const colorTexture = current.colorTextures[0];
        if (!colorTexture) {
          return;
        }
        if (!fbo.blitFramebuffer) {
          fbo.blitFramebuffer = new Framebuffer(current.width, current.height);
          fbo.blitFramebuffer.addColorTexture(0, colorTexture);
        }
        framebuffer = fbo.blitFramebuffer;
        if (framebuffer.colorTextures[0] !== colorTexture) {
          framebuffer.colorTextures[0] = colorTexture;
          framebuffer.dirtyId++;
          framebuffer.dirtyFormat++;
        }
        if (framebuffer.width !== current.width || framebuffer.height !== current.height) {
          framebuffer.width = current.width;
          framebuffer.height = current.height;
          framebuffer.dirtyId++;
          framebuffer.dirtySize++;
        }
      }
      if (!sourcePixels) {
        sourcePixels = tempRectangle;
        sourcePixels.width = current.width;
        sourcePixels.height = current.height;
      }
      if (!destPixels) {
        destPixels = sourcePixels;
      }
      const sameSize = sourcePixels.width === destPixels.width && sourcePixels.height === destPixels.height;
      this.bind(framebuffer);
      gl.bindFramebuffer(gl.READ_FRAMEBUFFER, fbo.framebuffer);
      gl.blitFramebuffer(sourcePixels.left, sourcePixels.top, sourcePixels.right, sourcePixels.bottom, destPixels.left, destPixels.top, destPixels.right, destPixels.bottom, gl.COLOR_BUFFER_BIT, sameSize ? gl.NEAREST : gl.LINEAR);
    }
    disposeFramebuffer(framebuffer, contextLost) {
      const fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
      const gl = this.gl;
      if (!fbo) {
        return;
      }
      delete framebuffer.glFramebuffers[this.CONTEXT_UID];
      const index2 = this.managedFramebuffers.indexOf(framebuffer);
      if (index2 >= 0) {
        this.managedFramebuffers.splice(index2, 1);
      }
      framebuffer.disposeRunner.remove(this);
      if (!contextLost) {
        gl.deleteFramebuffer(fbo.framebuffer);
        if (fbo.msaaBuffer) {
          gl.deleteRenderbuffer(fbo.msaaBuffer);
        }
        if (fbo.stencil) {
          gl.deleteRenderbuffer(fbo.stencil);
        }
      }
      if (fbo.blitFramebuffer) {
        fbo.blitFramebuffer.dispose();
      }
    }
    disposeAll(contextLost) {
      const list = this.managedFramebuffers;
      this.managedFramebuffers = [];
      for (let i = 0; i < list.length; i++) {
        this.disposeFramebuffer(list[i], contextLost);
      }
    }
    forceStencil() {
      const framebuffer = this.current;
      if (!framebuffer) {
        return;
      }
      const fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
      if (!fbo || fbo.stencil) {
        return;
      }
      framebuffer.stencil = true;
      const w = framebuffer.width;
      const h = framebuffer.height;
      const gl = this.gl;
      const stencil = gl.createRenderbuffer();
      gl.bindRenderbuffer(gl.RENDERBUFFER, stencil);
      if (fbo.msaaBuffer) {
        gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, gl.DEPTH24_STENCIL8, w, h);
      } else {
        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, w, h);
      }
      fbo.stencil = stencil;
      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, stencil);
    }
    reset() {
      this.current = this.unknownFramebuffer;
      this.viewport = new Rectangle();
    }
    destroy() {
      this.renderer = null;
    }
  };
  FramebufferSystem.extension = {
    type: ExtensionType.RendererSystem,
    name: "framebuffer"
  };
  extensions.add(FramebufferSystem);

  // node_modules/pixijs/core/geometry/GeometrySystem.mjs
  var byteSizeMap2 = { 5126: 4, 5123: 2, 5121: 1 };
  var GeometrySystem = class {
    constructor(renderer) {
      this.renderer = renderer;
      this._activeGeometry = null;
      this._activeVao = null;
      this.hasVao = true;
      this.hasInstance = true;
      this.canUseUInt32ElementIndex = false;
      this.managedGeometries = {};
    }
    contextChange() {
      this.disposeAll(true);
      const gl = this.gl = this.renderer.gl;
      const context2 = this.renderer.context;
      this.CONTEXT_UID = this.renderer.CONTEXT_UID;
      if (context2.webGLVersion !== 2) {
        let nativeVaoExtension = this.renderer.context.extensions.vertexArrayObject;
        if (settings.PREFER_ENV === ENV.WEBGL_LEGACY) {
          nativeVaoExtension = null;
        }
        if (nativeVaoExtension) {
          gl.createVertexArray = () => nativeVaoExtension.createVertexArrayOES();
          gl.bindVertexArray = (vao) => nativeVaoExtension.bindVertexArrayOES(vao);
          gl.deleteVertexArray = (vao) => nativeVaoExtension.deleteVertexArrayOES(vao);
        } else {
          this.hasVao = false;
          gl.createVertexArray = () => null;
          gl.bindVertexArray = () => null;
          gl.deleteVertexArray = () => null;
        }
      }
      if (context2.webGLVersion !== 2) {
        const instanceExt = gl.getExtension("ANGLE_instanced_arrays");
        if (instanceExt) {
          gl.vertexAttribDivisor = (a2, b) => instanceExt.vertexAttribDivisorANGLE(a2, b);
          gl.drawElementsInstanced = (a2, b, c2, d, e) => instanceExt.drawElementsInstancedANGLE(a2, b, c2, d, e);
          gl.drawArraysInstanced = (a2, b, c2, d) => instanceExt.drawArraysInstancedANGLE(a2, b, c2, d);
        } else {
          this.hasInstance = false;
        }
      }
      this.canUseUInt32ElementIndex = context2.webGLVersion === 2 || !!context2.extensions.uint32ElementIndex;
    }
    bind(geometry, shader) {
      shader = shader || this.renderer.shader.shader;
      const { gl } = this;
      let vaos = geometry.glVertexArrayObjects[this.CONTEXT_UID];
      let incRefCount = false;
      if (!vaos) {
        this.managedGeometries[geometry.id] = geometry;
        geometry.disposeRunner.add(this);
        geometry.glVertexArrayObjects[this.CONTEXT_UID] = vaos = {};
        incRefCount = true;
      }
      const vao = vaos[shader.program.id] || this.initGeometryVao(geometry, shader, incRefCount);
      this._activeGeometry = geometry;
      if (this._activeVao !== vao) {
        this._activeVao = vao;
        if (this.hasVao) {
          gl.bindVertexArray(vao);
        } else {
          this.activateVao(geometry, shader.program);
        }
      }
      this.updateBuffers();
    }
    reset() {
      this.unbind();
    }
    updateBuffers() {
      const geometry = this._activeGeometry;
      const bufferSystem = this.renderer.buffer;
      for (let i = 0; i < geometry.buffers.length; i++) {
        const buffer = geometry.buffers[i];
        bufferSystem.update(buffer);
      }
    }
    checkCompatibility(geometry, program) {
      const geometryAttributes = geometry.attributes;
      const shaderAttributes = program.attributeData;
      for (const j in shaderAttributes) {
        if (!geometryAttributes[j]) {
          throw new Error(`shader and geometry incompatible, geometry missing the "${j}" attribute`);
        }
      }
    }
    getSignature(geometry, program) {
      const attribs = geometry.attributes;
      const shaderAttributes = program.attributeData;
      const strings = ["g", geometry.id];
      for (const i in attribs) {
        if (shaderAttributes[i]) {
          strings.push(i, shaderAttributes[i].location);
        }
      }
      return strings.join("-");
    }
    initGeometryVao(geometry, shader, incRefCount = true) {
      const gl = this.gl;
      const CONTEXT_UID = this.CONTEXT_UID;
      const bufferSystem = this.renderer.buffer;
      const program = shader.program;
      if (!program.glPrograms[CONTEXT_UID]) {
        this.renderer.shader.generateProgram(shader);
      }
      this.checkCompatibility(geometry, program);
      const signature = this.getSignature(geometry, program);
      const vaoObjectHash = geometry.glVertexArrayObjects[this.CONTEXT_UID];
      let vao = vaoObjectHash[signature];
      if (vao) {
        vaoObjectHash[program.id] = vao;
        return vao;
      }
      const buffers = geometry.buffers;
      const attributes = geometry.attributes;
      const tempStride = {};
      const tempStart = {};
      for (const j in buffers) {
        tempStride[j] = 0;
        tempStart[j] = 0;
      }
      for (const j in attributes) {
        if (!attributes[j].size && program.attributeData[j]) {
          attributes[j].size = program.attributeData[j].size;
        } else if (!attributes[j].size) {
          console.warn(`PIXI Geometry attribute '${j}' size cannot be determined (likely the bound shader does not have the attribute)`);
        }
        tempStride[attributes[j].buffer] += attributes[j].size * byteSizeMap2[attributes[j].type];
      }
      for (const j in attributes) {
        const attribute = attributes[j];
        const attribSize = attribute.size;
        if (attribute.stride === void 0) {
          if (tempStride[attribute.buffer] === attribSize * byteSizeMap2[attribute.type]) {
            attribute.stride = 0;
          } else {
            attribute.stride = tempStride[attribute.buffer];
          }
        }
        if (attribute.start === void 0) {
          attribute.start = tempStart[attribute.buffer];
          tempStart[attribute.buffer] += attribSize * byteSizeMap2[attribute.type];
        }
      }
      vao = gl.createVertexArray();
      gl.bindVertexArray(vao);
      for (let i = 0; i < buffers.length; i++) {
        const buffer = buffers[i];
        bufferSystem.bind(buffer);
        if (incRefCount) {
          buffer._glBuffers[CONTEXT_UID].refCount++;
        }
      }
      this.activateVao(geometry, program);
      vaoObjectHash[program.id] = vao;
      vaoObjectHash[signature] = vao;
      gl.bindVertexArray(null);
      bufferSystem.unbind(BUFFER_TYPE.ARRAY_BUFFER);
      return vao;
    }
    disposeGeometry(geometry, contextLost) {
      var _a;
      if (!this.managedGeometries[geometry.id]) {
        return;
      }
      delete this.managedGeometries[geometry.id];
      const vaos = geometry.glVertexArrayObjects[this.CONTEXT_UID];
      const gl = this.gl;
      const buffers = geometry.buffers;
      const bufferSystem = (_a = this.renderer) == null ? void 0 : _a.buffer;
      geometry.disposeRunner.remove(this);
      if (!vaos) {
        return;
      }
      if (bufferSystem) {
        for (let i = 0; i < buffers.length; i++) {
          const buf = buffers[i]._glBuffers[this.CONTEXT_UID];
          if (buf) {
            buf.refCount--;
            if (buf.refCount === 0 && !contextLost) {
              bufferSystem.dispose(buffers[i], contextLost);
            }
          }
        }
      }
      if (!contextLost) {
        for (const vaoId in vaos) {
          if (vaoId[0] === "g") {
            const vao = vaos[vaoId];
            if (this._activeVao === vao) {
              this.unbind();
            }
            gl.deleteVertexArray(vao);
          }
        }
      }
      delete geometry.glVertexArrayObjects[this.CONTEXT_UID];
    }
    disposeAll(contextLost) {
      const all = Object.keys(this.managedGeometries);
      for (let i = 0; i < all.length; i++) {
        this.disposeGeometry(this.managedGeometries[all[i]], contextLost);
      }
    }
    activateVao(geometry, program) {
      const gl = this.gl;
      const CONTEXT_UID = this.CONTEXT_UID;
      const bufferSystem = this.renderer.buffer;
      const buffers = geometry.buffers;
      const attributes = geometry.attributes;
      if (geometry.indexBuffer) {
        bufferSystem.bind(geometry.indexBuffer);
      }
      let lastBuffer = null;
      for (const j in attributes) {
        const attribute = attributes[j];
        const buffer = buffers[attribute.buffer];
        const glBuffer = buffer._glBuffers[CONTEXT_UID];
        if (program.attributeData[j]) {
          if (lastBuffer !== glBuffer) {
            bufferSystem.bind(buffer);
            lastBuffer = glBuffer;
          }
          const location = program.attributeData[j].location;
          gl.enableVertexAttribArray(location);
          gl.vertexAttribPointer(location, attribute.size, attribute.type || gl.FLOAT, attribute.normalized, attribute.stride, attribute.start);
          if (attribute.instance) {
            if (this.hasInstance) {
              gl.vertexAttribDivisor(location, attribute.divisor);
            } else {
              throw new Error("geometry error, GPU Instancing is not supported on this device");
            }
          }
        }
      }
    }
    draw(type2, size, start2, instanceCount) {
      const { gl } = this;
      const geometry = this._activeGeometry;
      if (geometry.indexBuffer) {
        const byteSize = geometry.indexBuffer.data.BYTES_PER_ELEMENT;
        const glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;
        if (byteSize === 2 || byteSize === 4 && this.canUseUInt32ElementIndex) {
          if (geometry.instanced) {
            gl.drawElementsInstanced(type2, size || geometry.indexBuffer.data.length, glType, (start2 || 0) * byteSize, instanceCount || 1);
          } else {
            gl.drawElements(type2, size || geometry.indexBuffer.data.length, glType, (start2 || 0) * byteSize);
          }
        } else {
          console.warn("unsupported index buffer type: uint32");
        }
      } else if (geometry.instanced) {
        gl.drawArraysInstanced(type2, start2, size || geometry.getSize(), instanceCount || 1);
      } else {
        gl.drawArrays(type2, start2, size || geometry.getSize());
      }
      return this;
    }
    unbind() {
      this.gl.bindVertexArray(null);
      this._activeVao = null;
      this._activeGeometry = null;
    }
    destroy() {
      this.renderer = null;
    }
  };
  GeometrySystem.extension = {
    type: ExtensionType.RendererSystem,
    name: "geometry"
  };
  extensions.add(GeometrySystem);

  // node_modules/pixijs/core/textures/TextureMatrix.mjs
  var tempMat = new Matrix();
  var TextureMatrix = class {
    constructor(texture, clampMargin) {
      this._texture = texture;
      this.mapCoord = new Matrix();
      this.uClampFrame = new Float32Array(4);
      this.uClampOffset = new Float32Array(2);
      this._textureID = -1;
      this._updateID = 0;
      this.clampOffset = 0;
      this.clampMargin = typeof clampMargin === "undefined" ? 0.5 : clampMargin;
      this.isSimple = false;
    }
    get texture() {
      return this._texture;
    }
    set texture(value) {
      this._texture = value;
      this._textureID = -1;
    }
    multiplyUvs(uvs, out) {
      if (out === void 0) {
        out = uvs;
      }
      const mat = this.mapCoord;
      for (let i = 0; i < uvs.length; i += 2) {
        const x3 = uvs[i];
        const y3 = uvs[i + 1];
        out[i] = x3 * mat.a + y3 * mat.c + mat.tx;
        out[i + 1] = x3 * mat.b + y3 * mat.d + mat.ty;
      }
      return out;
    }
    update(forceUpdate) {
      const tex = this._texture;
      if (!tex || !tex.valid) {
        return false;
      }
      if (!forceUpdate && this._textureID === tex._updateID) {
        return false;
      }
      this._textureID = tex._updateID;
      this._updateID++;
      const uvs = tex._uvs;
      this.mapCoord.set(uvs.x1 - uvs.x0, uvs.y1 - uvs.y0, uvs.x3 - uvs.x0, uvs.y3 - uvs.y0, uvs.x0, uvs.y0);
      const orig = tex.orig;
      const trim = tex.trim;
      if (trim) {
        tempMat.set(orig.width / trim.width, 0, 0, orig.height / trim.height, -trim.x / trim.width, -trim.y / trim.height);
        this.mapCoord.append(tempMat);
      }
      const texBase = tex.baseTexture;
      const frame2 = this.uClampFrame;
      const margin = this.clampMargin / texBase.resolution;
      const offset = this.clampOffset;
      frame2[0] = (tex._frame.x + margin + offset) / texBase.width;
      frame2[1] = (tex._frame.y + margin + offset) / texBase.height;
      frame2[2] = (tex._frame.x + tex._frame.width - margin + offset) / texBase.width;
      frame2[3] = (tex._frame.y + tex._frame.height - margin + offset) / texBase.height;
      this.uClampOffset[0] = offset / texBase.realWidth;
      this.uClampOffset[1] = offset / texBase.realHeight;
      this.isSimple = tex._frame.width === texBase.width && tex._frame.height === texBase.height && tex.rotate === 0;
      return true;
    }
  };

  // node_modules/pixijs/core/filters/spriteMask/spriteMaskFilter2.mjs
  var fragment = "varying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform sampler2D mask;\nuniform float alpha;\nuniform float npmAlpha;\nuniform vec4 maskClamp;\n\nvoid main(void)\n{\n    float clip = step(3.5,\n        step(maskClamp.x, vMaskCoord.x) +\n        step(maskClamp.y, vMaskCoord.y) +\n        step(vMaskCoord.x, maskClamp.z) +\n        step(vMaskCoord.y, maskClamp.w));\n\n    vec4 original = texture2D(uSampler, vTextureCoord);\n    vec4 masky = texture2D(mask, vMaskCoord);\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\n\n    original *= (alphaMul * masky.r * alpha * clip);\n\n    gl_FragColor = original;\n}\n";

  // node_modules/pixijs/core/filters/spriteMask/spriteMaskFilter3.mjs
  var vertex = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 otherMatrix;\n\nvarying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;\n}\n";

  // node_modules/pixijs/core/filters/spriteMask/SpriteMaskFilter.mjs
  var SpriteMaskFilter = class extends Filter {
    constructor(vertexSrc, fragmentSrc, uniforms) {
      let sprite = null;
      if (typeof vertexSrc !== "string" && fragmentSrc === void 0 && uniforms === void 0) {
        sprite = vertexSrc;
        vertexSrc = void 0;
        fragmentSrc = void 0;
        uniforms = void 0;
      }
      super(vertexSrc || vertex, fragmentSrc || fragment, uniforms);
      this.maskSprite = sprite;
      this.maskMatrix = new Matrix();
    }
    get maskSprite() {
      return this._maskSprite;
    }
    set maskSprite(value) {
      this._maskSprite = value;
      if (this._maskSprite) {
        this._maskSprite.renderable = false;
      }
    }
    apply(filterManager, input, output, clearMode) {
      const maskSprite = this._maskSprite;
      const tex = maskSprite._texture;
      if (!tex.valid) {
        return;
      }
      if (!tex.uvMatrix) {
        tex.uvMatrix = new TextureMatrix(tex, 0);
      }
      tex.uvMatrix.update();
      this.uniforms.npmAlpha = tex.baseTexture.alphaMode ? 0 : 1;
      this.uniforms.mask = tex;
      this.uniforms.otherMatrix = filterManager.calculateSpriteMatrix(this.maskMatrix, maskSprite).prepend(tex.uvMatrix.mapCoord);
      this.uniforms.alpha = maskSprite.worldAlpha;
      this.uniforms.maskClamp = tex.uvMatrix.uClampFrame;
      filterManager.applyFilter(this, input, output, clearMode);
    }
  };

  // node_modules/pixijs/core/mask/MaskData.mjs
  var MaskData = class {
    constructor(maskObject = null) {
      this.type = MASK_TYPES.NONE;
      this.autoDetect = true;
      this.maskObject = maskObject || null;
      this.pooled = false;
      this.isMaskData = true;
      this.resolution = null;
      this.multisample = Filter.defaultMultisample;
      this.enabled = true;
      this.colorMask = 15;
      this._filters = null;
      this._stencilCounter = 0;
      this._scissorCounter = 0;
      this._scissorRect = null;
      this._scissorRectLocal = null;
      this._colorMask = 15;
      this._target = null;
    }
    get filter() {
      return this._filters ? this._filters[0] : null;
    }
    set filter(value) {
      if (value) {
        if (this._filters) {
          this._filters[0] = value;
        } else {
          this._filters = [value];
        }
      } else {
        this._filters = null;
      }
    }
    reset() {
      if (this.pooled) {
        this.maskObject = null;
        this.type = MASK_TYPES.NONE;
        this.autoDetect = true;
      }
      this._target = null;
      this._scissorRectLocal = null;
    }
    copyCountersOrReset(maskAbove) {
      if (maskAbove) {
        this._stencilCounter = maskAbove._stencilCounter;
        this._scissorCounter = maskAbove._scissorCounter;
        this._scissorRect = maskAbove._scissorRect;
      } else {
        this._stencilCounter = 0;
        this._scissorCounter = 0;
        this._scissorRect = null;
      }
    }
  };

  // node_modules/pixijs/core/mask/MaskSystem.mjs
  var MaskSystem = class {
    constructor(renderer) {
      this.renderer = renderer;
      this.enableScissor = true;
      this.alphaMaskPool = [];
      this.maskDataPool = [];
      this.maskStack = [];
      this.alphaMaskIndex = 0;
    }
    setMaskStack(maskStack) {
      this.maskStack = maskStack;
      this.renderer.scissor.setMaskStack(maskStack);
      this.renderer.stencil.setMaskStack(maskStack);
    }
    push(target, maskDataOrTarget) {
      let maskData = maskDataOrTarget;
      if (!maskData.isMaskData) {
        const d = this.maskDataPool.pop() || new MaskData();
        d.pooled = true;
        d.maskObject = maskDataOrTarget;
        maskData = d;
      }
      const maskAbove = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null;
      maskData.copyCountersOrReset(maskAbove);
      maskData._colorMask = maskAbove ? maskAbove._colorMask : 15;
      if (maskData.autoDetect) {
        this.detect(maskData);
      }
      maskData._target = target;
      if (maskData.type !== MASK_TYPES.SPRITE) {
        this.maskStack.push(maskData);
      }
      if (maskData.enabled) {
        switch (maskData.type) {
          case MASK_TYPES.SCISSOR:
            this.renderer.scissor.push(maskData);
            break;
          case MASK_TYPES.STENCIL:
            this.renderer.stencil.push(maskData);
            break;
          case MASK_TYPES.SPRITE:
            maskData.copyCountersOrReset(null);
            this.pushSpriteMask(maskData);
            break;
          case MASK_TYPES.COLOR:
            this.pushColorMask(maskData);
            break;
          default:
            break;
        }
      }
      if (maskData.type === MASK_TYPES.SPRITE) {
        this.maskStack.push(maskData);
      }
    }
    pop(target) {
      const maskData = this.maskStack.pop();
      if (!maskData || maskData._target !== target) {
        return;
      }
      if (maskData.enabled) {
        switch (maskData.type) {
          case MASK_TYPES.SCISSOR:
            this.renderer.scissor.pop(maskData);
            break;
          case MASK_TYPES.STENCIL:
            this.renderer.stencil.pop(maskData.maskObject);
            break;
          case MASK_TYPES.SPRITE:
            this.popSpriteMask(maskData);
            break;
          case MASK_TYPES.COLOR:
            this.popColorMask(maskData);
            break;
          default:
            break;
        }
      }
      maskData.reset();
      if (maskData.pooled) {
        this.maskDataPool.push(maskData);
      }
      if (this.maskStack.length !== 0) {
        const maskCurrent = this.maskStack[this.maskStack.length - 1];
        if (maskCurrent.type === MASK_TYPES.SPRITE && maskCurrent._filters) {
          maskCurrent._filters[0].maskSprite = maskCurrent.maskObject;
        }
      }
    }
    detect(maskData) {
      const maskObject = maskData.maskObject;
      if (!maskObject) {
        maskData.type = MASK_TYPES.COLOR;
      } else if (maskObject.isSprite) {
        maskData.type = MASK_TYPES.SPRITE;
      } else if (this.enableScissor && this.renderer.scissor.testScissor(maskData)) {
        maskData.type = MASK_TYPES.SCISSOR;
      } else {
        maskData.type = MASK_TYPES.STENCIL;
      }
    }
    pushSpriteMask(maskData) {
      var _a, _b;
      const { maskObject } = maskData;
      const target = maskData._target;
      let alphaMaskFilter = maskData._filters;
      if (!alphaMaskFilter) {
        alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex];
        if (!alphaMaskFilter) {
          alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex] = [new SpriteMaskFilter()];
        }
      }
      const renderer = this.renderer;
      const renderTextureSystem = renderer.renderTexture;
      let resolution;
      let multisample;
      if (renderTextureSystem.current) {
        const renderTexture = renderTextureSystem.current;
        resolution = maskData.resolution || renderTexture.resolution;
        multisample = (_a = maskData.multisample) != null ? _a : renderTexture.multisample;
      } else {
        resolution = maskData.resolution || renderer.resolution;
        multisample = (_b = maskData.multisample) != null ? _b : renderer.multisample;
      }
      alphaMaskFilter[0].resolution = resolution;
      alphaMaskFilter[0].multisample = multisample;
      alphaMaskFilter[0].maskSprite = maskObject;
      const stashFilterArea = target.filterArea;
      target.filterArea = maskObject.getBounds(true);
      renderer.filter.push(target, alphaMaskFilter);
      target.filterArea = stashFilterArea;
      if (!maskData._filters) {
        this.alphaMaskIndex++;
      }
    }
    popSpriteMask(maskData) {
      this.renderer.filter.pop();
      if (maskData._filters) {
        maskData._filters[0].maskSprite = null;
      } else {
        this.alphaMaskIndex--;
        this.alphaMaskPool[this.alphaMaskIndex][0].maskSprite = null;
      }
    }
    pushColorMask(maskData) {
      const currColorMask = maskData._colorMask;
      const nextColorMask = maskData._colorMask = currColorMask & maskData.colorMask;
      if (nextColorMask !== currColorMask) {
        this.renderer.gl.colorMask((nextColorMask & 1) !== 0, (nextColorMask & 2) !== 0, (nextColorMask & 4) !== 0, (nextColorMask & 8) !== 0);
      }
    }
    popColorMask(maskData) {
      const currColorMask = maskData._colorMask;
      const nextColorMask = this.maskStack.length > 0 ? this.maskStack[this.maskStack.length - 1]._colorMask : 15;
      if (nextColorMask !== currColorMask) {
        this.renderer.gl.colorMask((nextColorMask & 1) !== 0, (nextColorMask & 2) !== 0, (nextColorMask & 4) !== 0, (nextColorMask & 8) !== 0);
      }
    }
    destroy() {
      this.renderer = null;
    }
  };
  MaskSystem.extension = {
    type: ExtensionType.RendererSystem,
    name: "mask"
  };
  extensions.add(MaskSystem);

  // node_modules/pixijs/core/mask/AbstractMaskSystem.mjs
  var AbstractMaskSystem = class {
    constructor(renderer) {
      this.renderer = renderer;
      this.maskStack = [];
      this.glConst = 0;
    }
    getStackLength() {
      return this.maskStack.length;
    }
    setMaskStack(maskStack) {
      const { gl } = this.renderer;
      const curStackLen = this.getStackLength();
      this.maskStack = maskStack;
      const newStackLen = this.getStackLength();
      if (newStackLen !== curStackLen) {
        if (newStackLen === 0) {
          gl.disable(this.glConst);
        } else {
          gl.enable(this.glConst);
          this._useCurrent();
        }
      }
    }
    _useCurrent() {
    }
    destroy() {
      this.renderer = null;
      this.maskStack = null;
    }
  };

  // node_modules/pixijs/core/mask/ScissorSystem.mjs
  var tempMatrix2 = new Matrix();
  var rectPool = [];
  var _ScissorSystem = class extends AbstractMaskSystem {
    constructor(renderer) {
      super(renderer);
      this.glConst = settings.ADAPTER.getWebGLRenderingContext().SCISSOR_TEST;
    }
    getStackLength() {
      const maskData = this.maskStack[this.maskStack.length - 1];
      if (maskData) {
        return maskData._scissorCounter;
      }
      return 0;
    }
    calcScissorRect(maskData) {
      var _a;
      if (maskData._scissorRectLocal) {
        return;
      }
      const prevData = maskData._scissorRect;
      const { maskObject } = maskData;
      const { renderer } = this;
      const renderTextureSystem = renderer.renderTexture;
      const rect = maskObject.getBounds(true, (_a = rectPool.pop()) != null ? _a : new Rectangle());
      this.roundFrameToPixels(rect, renderTextureSystem.current ? renderTextureSystem.current.resolution : renderer.resolution, renderTextureSystem.sourceFrame, renderTextureSystem.destinationFrame, renderer.projection.transform);
      if (prevData) {
        rect.fit(prevData);
      }
      maskData._scissorRectLocal = rect;
    }
    static isMatrixRotated(matrix) {
      if (!matrix) {
        return false;
      }
      const { a: a2, b, c: c2, d } = matrix;
      return (Math.abs(b) > 1e-4 || Math.abs(c2) > 1e-4) && (Math.abs(a2) > 1e-4 || Math.abs(d) > 1e-4);
    }
    testScissor(maskData) {
      const { maskObject } = maskData;
      if (!maskObject.isFastRect || !maskObject.isFastRect()) {
        return false;
      }
      if (_ScissorSystem.isMatrixRotated(maskObject.worldTransform)) {
        return false;
      }
      if (_ScissorSystem.isMatrixRotated(this.renderer.projection.transform)) {
        return false;
      }
      this.calcScissorRect(maskData);
      const rect = maskData._scissorRectLocal;
      return rect.width > 0 && rect.height > 0;
    }
    roundFrameToPixels(frame2, resolution, bindingSourceFrame, bindingDestinationFrame, transform2) {
      if (_ScissorSystem.isMatrixRotated(transform2)) {
        return;
      }
      transform2 = transform2 ? tempMatrix2.copyFrom(transform2) : tempMatrix2.identity();
      transform2.translate(-bindingSourceFrame.x, -bindingSourceFrame.y).scale(bindingDestinationFrame.width / bindingSourceFrame.width, bindingDestinationFrame.height / bindingSourceFrame.height).translate(bindingDestinationFrame.x, bindingDestinationFrame.y);
      this.renderer.filter.transformAABB(transform2, frame2);
      frame2.fit(bindingDestinationFrame);
      frame2.x = Math.round(frame2.x * resolution);
      frame2.y = Math.round(frame2.y * resolution);
      frame2.width = Math.round(frame2.width * resolution);
      frame2.height = Math.round(frame2.height * resolution);
    }
    push(maskData) {
      if (!maskData._scissorRectLocal) {
        this.calcScissorRect(maskData);
      }
      const { gl } = this.renderer;
      if (!maskData._scissorRect) {
        gl.enable(gl.SCISSOR_TEST);
      }
      maskData._scissorCounter++;
      maskData._scissorRect = maskData._scissorRectLocal;
      this._useCurrent();
    }
    pop(maskData) {
      const { gl } = this.renderer;
      if (maskData) {
        rectPool.push(maskData._scissorRectLocal);
      }
      if (this.getStackLength() > 0) {
        this._useCurrent();
      } else {
        gl.disable(gl.SCISSOR_TEST);
      }
    }
    _useCurrent() {
      const rect = this.maskStack[this.maskStack.length - 1]._scissorRect;
      let y3;
      if (this.renderer.renderTexture.current) {
        y3 = rect.y;
      } else {
        y3 = this.renderer.height - rect.height - rect.y;
      }
      this.renderer.gl.scissor(rect.x, y3, rect.width, rect.height);
    }
  };
  var ScissorSystem = _ScissorSystem;
  ScissorSystem.extension = {
    type: ExtensionType.RendererSystem,
    name: "scissor"
  };
  extensions.add(ScissorSystem);

  // node_modules/pixijs/core/mask/StencilSystem.mjs
  var StencilSystem = class extends AbstractMaskSystem {
    constructor(renderer) {
      super(renderer);
      this.glConst = settings.ADAPTER.getWebGLRenderingContext().STENCIL_TEST;
    }
    getStackLength() {
      const maskData = this.maskStack[this.maskStack.length - 1];
      if (maskData) {
        return maskData._stencilCounter;
      }
      return 0;
    }
    push(maskData) {
      const maskObject = maskData.maskObject;
      const { gl } = this.renderer;
      const prevMaskCount = maskData._stencilCounter;
      if (prevMaskCount === 0) {
        this.renderer.framebuffer.forceStencil();
        gl.clearStencil(0);
        gl.clear(gl.STENCIL_BUFFER_BIT);
        gl.enable(gl.STENCIL_TEST);
      }
      maskData._stencilCounter++;
      const colorMask = maskData._colorMask;
      if (colorMask !== 0) {
        maskData._colorMask = 0;
        gl.colorMask(false, false, false, false);
      }
      gl.stencilFunc(gl.EQUAL, prevMaskCount, 4294967295);
      gl.stencilOp(gl.KEEP, gl.KEEP, gl.INCR);
      maskObject.renderable = true;
      maskObject.render(this.renderer);
      this.renderer.batch.flush();
      maskObject.renderable = false;
      if (colorMask !== 0) {
        maskData._colorMask = colorMask;
        gl.colorMask((colorMask & 1) !== 0, (colorMask & 2) !== 0, (colorMask & 4) !== 0, (colorMask & 8) !== 0);
      }
      this._useCurrent();
    }
    pop(maskObject) {
      const gl = this.renderer.gl;
      if (this.getStackLength() === 0) {
        gl.disable(gl.STENCIL_TEST);
      } else {
        const maskData = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null;
        const colorMask = maskData ? maskData._colorMask : 15;
        if (colorMask !== 0) {
          maskData._colorMask = 0;
          gl.colorMask(false, false, false, false);
        }
        gl.stencilOp(gl.KEEP, gl.KEEP, gl.DECR);
        maskObject.renderable = true;
        maskObject.render(this.renderer);
        this.renderer.batch.flush();
        maskObject.renderable = false;
        if (colorMask !== 0) {
          maskData._colorMask = colorMask;
          gl.colorMask((colorMask & 1) !== 0, (colorMask & 2) !== 0, (colorMask & 4) !== 0, (colorMask & 8) !== 0);
        }
        this._useCurrent();
      }
    }
    _useCurrent() {
      const gl = this.renderer.gl;
      gl.stencilFunc(gl.EQUAL, this.getStackLength(), 4294967295);
      gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
    }
  };
  StencilSystem.extension = {
    type: ExtensionType.RendererSystem,
    name: "stencil"
  };
  extensions.add(StencilSystem);

  // node_modules/pixijs/core/plugin/PluginSystem.mjs
  var PluginSystem = class {
    constructor(renderer) {
      this.renderer = renderer;
      this.plugins = {};
      Object.defineProperties(this.plugins, {
        extract: {
          enumerable: false,
          get() {
            deprecation("7.0.0", "renderer.plugins.extract has moved to renderer.extract");
            return renderer.extract;
          }
        },
        prepare: {
          enumerable: false,
          get() {
            deprecation("7.0.0", "renderer.plugins.prepare has moved to renderer.prepare");
            return renderer.prepare;
          }
        },
        interaction: {
          enumerable: false,
          get() {
            deprecation("7.0.0", "renderer.plugins.interaction has been deprecated, use renderer.events");
            return renderer.events;
          }
        }
      });
    }
    init(staticMap) {
      for (const o in staticMap) {
        this.plugins[o] = new staticMap[o](this.renderer);
      }
    }
    destroy() {
      for (const o in this.plugins) {
        this.plugins[o].destroy();
        this.plugins[o] = null;
      }
    }
  };
  PluginSystem.extension = {
    type: [
      ExtensionType.RendererSystem,
      ExtensionType.CanvasRendererSystem
    ],
    name: "_plugin"
  };
  extensions.add(PluginSystem);

  // node_modules/pixijs/core/projection/ProjectionSystem.mjs
  var ProjectionSystem = class {
    constructor(renderer) {
      this.renderer = renderer;
      this.destinationFrame = null;
      this.sourceFrame = null;
      this.defaultFrame = null;
      this.projectionMatrix = new Matrix();
      this.transform = null;
    }
    update(destinationFrame, sourceFrame, resolution, root2) {
      this.destinationFrame = destinationFrame || this.destinationFrame || this.defaultFrame;
      this.sourceFrame = sourceFrame || this.sourceFrame || destinationFrame;
      this.calculateProjection(this.destinationFrame, this.sourceFrame, resolution, root2);
      if (this.transform) {
        this.projectionMatrix.append(this.transform);
      }
      const renderer = this.renderer;
      renderer.globalUniforms.uniforms.projectionMatrix = this.projectionMatrix;
      renderer.globalUniforms.update();
      if (renderer.shader.shader) {
        renderer.shader.syncUniformGroup(renderer.shader.shader.uniforms.globals);
      }
    }
    calculateProjection(_destinationFrame, sourceFrame, _resolution, root2) {
      const pm = this.projectionMatrix;
      const sign2 = !root2 ? 1 : -1;
      pm.identity();
      pm.a = 1 / sourceFrame.width * 2;
      pm.d = sign2 * (1 / sourceFrame.height * 2);
      pm.tx = -1 - sourceFrame.x * pm.a;
      pm.ty = -sign2 - sourceFrame.y * pm.d;
    }
    setTransform(_matrix) {
    }
    destroy() {
      this.renderer = null;
    }
  };
  ProjectionSystem.extension = {
    type: ExtensionType.RendererSystem,
    name: "projection"
  };
  extensions.add(ProjectionSystem);

  // node_modules/pixijs/core/renderTexture/GenerateTextureSystem.mjs
  var tempTransform = new Transform2();
  var GenerateTextureSystem = class {
    constructor(renderer) {
      this.renderer = renderer;
      this._tempMatrix = new Matrix();
    }
    generateTexture(displayObject, options) {
      const _a = options || {}, { region: manualRegion } = _a, textureOptions = __objRest(_a, ["region"]);
      const region = manualRegion || displayObject.getLocalBounds(null, true);
      if (region.width === 0)
        region.width = 1;
      if (region.height === 0)
        region.height = 1;
      const renderTexture = RenderTexture.create(__spreadValues({
        width: region.width,
        height: region.height
      }, textureOptions));
      this._tempMatrix.tx = -region.x;
      this._tempMatrix.ty = -region.y;
      const transform2 = displayObject.transform;
      displayObject.transform = tempTransform;
      this.renderer.render(displayObject, {
        renderTexture,
        transform: this._tempMatrix,
        skipUpdateTransform: !!displayObject.parent,
        blit: true
      });
      displayObject.transform = transform2;
      return renderTexture;
    }
    destroy() {
    }
  };
  GenerateTextureSystem.extension = {
    type: [
      ExtensionType.RendererSystem,
      ExtensionType.CanvasRendererSystem
    ],
    name: "textureGenerator"
  };
  extensions.add(GenerateTextureSystem);

  // node_modules/pixijs/core/renderTexture/RenderTextureSystem.mjs
  var tempRect = new Rectangle();
  var tempRect2 = new Rectangle();
  var RenderTextureSystem = class {
    constructor(renderer) {
      this.renderer = renderer;
      this.defaultMaskStack = [];
      this.current = null;
      this.sourceFrame = new Rectangle();
      this.destinationFrame = new Rectangle();
      this.viewportFrame = new Rectangle();
    }
    bind(renderTexture = null, sourceFrame, destinationFrame) {
      const renderer = this.renderer;
      this.current = renderTexture;
      let baseTexture;
      let framebuffer;
      let resolution;
      if (renderTexture) {
        baseTexture = renderTexture.baseTexture;
        resolution = baseTexture.resolution;
        if (!sourceFrame) {
          tempRect.width = renderTexture.frame.width;
          tempRect.height = renderTexture.frame.height;
          sourceFrame = tempRect;
        }
        if (!destinationFrame) {
          tempRect2.x = renderTexture.frame.x;
          tempRect2.y = renderTexture.frame.y;
          tempRect2.width = sourceFrame.width;
          tempRect2.height = sourceFrame.height;
          destinationFrame = tempRect2;
        }
        framebuffer = baseTexture.framebuffer;
      } else {
        resolution = renderer.resolution;
        if (!sourceFrame) {
          tempRect.width = renderer._view.screen.width;
          tempRect.height = renderer._view.screen.height;
          sourceFrame = tempRect;
        }
        if (!destinationFrame) {
          destinationFrame = tempRect;
          destinationFrame.width = sourceFrame.width;
          destinationFrame.height = sourceFrame.height;
        }
      }
      const viewportFrame = this.viewportFrame;
      viewportFrame.x = destinationFrame.x * resolution;
      viewportFrame.y = destinationFrame.y * resolution;
      viewportFrame.width = destinationFrame.width * resolution;
      viewportFrame.height = destinationFrame.height * resolution;
      if (!renderTexture) {
        viewportFrame.y = renderer.view.height - (viewportFrame.y + viewportFrame.height);
      }
      viewportFrame.ceil();
      this.renderer.framebuffer.bind(framebuffer, viewportFrame);
      this.renderer.projection.update(destinationFrame, sourceFrame, resolution, !framebuffer);
      if (renderTexture) {
        this.renderer.mask.setMaskStack(baseTexture.maskStack);
      } else {
        this.renderer.mask.setMaskStack(this.defaultMaskStack);
      }
      this.sourceFrame.copyFrom(sourceFrame);
      this.destinationFrame.copyFrom(destinationFrame);
    }
    clear(clearColor, mask) {
      if (this.current) {
        clearColor = clearColor || this.current.baseTexture.clearColor;
      } else {
        clearColor = clearColor || this.renderer.background.colorRgba;
      }
      const destinationFrame = this.destinationFrame;
      const baseFrame = this.current ? this.current.baseTexture : this.renderer._view.screen;
      const clearMask = destinationFrame.width !== baseFrame.width || destinationFrame.height !== baseFrame.height;
      if (clearMask) {
        let { x: x3, y: y3, width, height } = this.viewportFrame;
        x3 = Math.round(x3);
        y3 = Math.round(y3);
        width = Math.round(width);
        height = Math.round(height);
        this.renderer.gl.enable(this.renderer.gl.SCISSOR_TEST);
        this.renderer.gl.scissor(x3, y3, width, height);
      }
      this.renderer.framebuffer.clear(clearColor[0], clearColor[1], clearColor[2], clearColor[3], mask);
      if (clearMask) {
        this.renderer.scissor.pop();
      }
    }
    resize() {
      this.bind(null);
    }
    reset() {
      this.bind(null);
    }
    destroy() {
      this.renderer = null;
    }
  };
  RenderTextureSystem.extension = {
    type: ExtensionType.RendererSystem,
    name: "renderTexture"
  };
  extensions.add(RenderTextureSystem);

  // node_modules/pixijs/core/shader/GLProgram.mjs
  var GLProgram = class {
    constructor(program, uniformData) {
      this.program = program;
      this.uniformData = uniformData;
      this.uniformGroups = {};
      this.uniformDirtyGroups = {};
      this.uniformBufferBindings = {};
    }
    destroy() {
      this.uniformData = null;
      this.uniformGroups = null;
      this.uniformDirtyGroups = null;
      this.uniformBufferBindings = null;
      this.program = null;
    }
  };

  // node_modules/pixijs/core/shader/utils/getAttributeData.mjs
  function getAttributeData(program, gl) {
    const attributes = {};
    const totalAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
    for (let i = 0; i < totalAttributes; i++) {
      const attribData = gl.getActiveAttrib(program, i);
      if (attribData.name.startsWith("gl_")) {
        continue;
      }
      const type2 = mapType(gl, attribData.type);
      const data = {
        type: type2,
        name: attribData.name,
        size: mapSize(type2),
        location: gl.getAttribLocation(program, attribData.name)
      };
      attributes[attribData.name] = data;
    }
    return attributes;
  }

  // node_modules/pixijs/core/shader/utils/getUniformData.mjs
  function getUniformData(program, gl) {
    const uniforms = {};
    const totalUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
    for (let i = 0; i < totalUniforms; i++) {
      const uniformData = gl.getActiveUniform(program, i);
      const name = uniformData.name.replace(/\[.*?\]$/, "");
      const isArray = !!uniformData.name.match(/\[.*?\]$/);
      const type2 = mapType(gl, uniformData.type);
      uniforms[name] = {
        name,
        index: i,
        type: type2,
        size: uniformData.size,
        isArray,
        value: defaultValue(type2, uniformData.size)
      };
    }
    return uniforms;
  }

  // node_modules/pixijs/core/shader/utils/generateProgram.mjs
  function generateProgram(gl, program) {
    var _a;
    const glVertShader = compileShader(gl, gl.VERTEX_SHADER, program.vertexSrc);
    const glFragShader = compileShader(gl, gl.FRAGMENT_SHADER, program.fragmentSrc);
    const webGLProgram = gl.createProgram();
    gl.attachShader(webGLProgram, glVertShader);
    gl.attachShader(webGLProgram, glFragShader);
    const transformFeedbackVaryings = (_a = program.extra) == null ? void 0 : _a.transformFeedbackVaryings;
    if (transformFeedbackVaryings) {
      if (typeof gl.transformFeedbackVaryings !== "function") {
        console.warn(`TransformFeedback is not supported but TransformFeedbackVaryings are given.`);
      } else {
        gl.transformFeedbackVaryings(webGLProgram, transformFeedbackVaryings.names, transformFeedbackVaryings.bufferMode === "separate" ? gl.SEPARATE_ATTRIBS : gl.INTERLEAVED_ATTRIBS);
      }
    }
    gl.linkProgram(webGLProgram);
    if (!gl.getProgramParameter(webGLProgram, gl.LINK_STATUS)) {
      logProgramError(gl, webGLProgram, glVertShader, glFragShader);
    }
    program.attributeData = getAttributeData(webGLProgram, gl);
    program.uniformData = getUniformData(webGLProgram, gl);
    if (!/^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m.test(program.vertexSrc)) {
      const keys = Object.keys(program.attributeData);
      keys.sort((a2, b) => a2 > b ? 1 : -1);
      for (let i = 0; i < keys.length; i++) {
        program.attributeData[keys[i]].location = i;
        gl.bindAttribLocation(webGLProgram, i, keys[i]);
      }
      gl.linkProgram(webGLProgram);
    }
    gl.deleteShader(glVertShader);
    gl.deleteShader(glFragShader);
    const uniformData = {};
    for (const i in program.uniformData) {
      const data = program.uniformData[i];
      uniformData[i] = {
        location: gl.getUniformLocation(webGLProgram, i),
        value: defaultValue(data.type, data.size)
      };
    }
    const glProgram = new GLProgram(webGLProgram, uniformData);
    return glProgram;
  }

  // node_modules/pixijs/core/shader/utils/generateUniformBufferSync.mjs
  function uboUpdate(_ud, _uv, _renderer, _syncData, buffer) {
    _renderer.buffer.update(buffer);
  }
  var UBO_TO_SINGLE_SETTERS = {
    float: `
        data[offset] = v;
    `,
    vec2: `
        data[offset] = v[0];
        data[offset+1] = v[1];
    `,
    vec3: `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];

    `,
    vec4: `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];
        data[offset+3] = v[3];
    `,
    mat2: `
        data[offset] = v[0];
        data[offset+1] = v[1];

        data[offset+4] = v[2];
        data[offset+5] = v[3];
    `,
    mat3: `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];

        data[offset + 4] = v[3];
        data[offset + 5] = v[4];
        data[offset + 6] = v[5];

        data[offset + 8] = v[6];
        data[offset + 9] = v[7];
        data[offset + 10] = v[8];
    `,
    mat4: `
        for(var i = 0; i < 16; i++)
        {
            data[offset + i] = v[i];
        }
    `
  };
  var GLSL_TO_STD40_SIZE = {
    float: 4,
    vec2: 8,
    vec3: 12,
    vec4: 16,
    int: 4,
    ivec2: 8,
    ivec3: 12,
    ivec4: 16,
    uint: 4,
    uvec2: 8,
    uvec3: 12,
    uvec4: 16,
    bool: 4,
    bvec2: 8,
    bvec3: 12,
    bvec4: 16,
    mat2: 16 * 2,
    mat3: 16 * 3,
    mat4: 16 * 4
  };
  function createUBOElements(uniformData) {
    const uboElements = uniformData.map((data) => ({
      data,
      offset: 0,
      dataLen: 0,
      dirty: 0
    }));
    let size = 0;
    let chunkSize = 0;
    let offset = 0;
    for (let i = 0; i < uboElements.length; i++) {
      const uboElement = uboElements[i];
      size = GLSL_TO_STD40_SIZE[uboElement.data.type];
      if (uboElement.data.size > 1) {
        size = Math.max(size, 16) * uboElement.data.size;
      }
      uboElement.dataLen = size;
      if (chunkSize % size !== 0 && chunkSize < 16) {
        const lineUpValue = chunkSize % size % 16;
        chunkSize += lineUpValue;
        offset += lineUpValue;
      }
      if (chunkSize + size > 16) {
        offset = Math.ceil(offset / 16) * 16;
        uboElement.offset = offset;
        offset += size;
        chunkSize = size;
      } else {
        uboElement.offset = offset;
        chunkSize += size;
        offset += size;
      }
    }
    offset = Math.ceil(offset / 16) * 16;
    return { uboElements, size: offset };
  }
  function getUBOData(uniforms, uniformData) {
    const usedUniformDatas = [];
    for (const i in uniforms) {
      if (uniformData[i]) {
        usedUniformDatas.push(uniformData[i]);
      }
    }
    usedUniformDatas.sort((a2, b) => a2.index - b.index);
    return usedUniformDatas;
  }
  function generateUniformBufferSync(group, uniformData) {
    if (!group.autoManage) {
      return { size: 0, syncFunc: uboUpdate };
    }
    const usedUniformDatas = getUBOData(group.uniforms, uniformData);
    const { uboElements, size } = createUBOElements(usedUniformDatas);
    const funcFragments = [`
    var v = null;
    var v2 = null;
    var cv = null;
    var t = 0;
    var gl = renderer.gl
    var index = 0;
    var data = buffer.data;
    `];
    for (let i = 0; i < uboElements.length; i++) {
      const uboElement = uboElements[i];
      const uniform = group.uniforms[uboElement.data.name];
      const name = uboElement.data.name;
      let parsed = false;
      for (let j = 0; j < uniformParsers.length; j++) {
        const uniformParser = uniformParsers[j];
        if (uniformParser.codeUbo && uniformParser.test(uboElement.data, uniform)) {
          funcFragments.push(`offset = ${uboElement.offset / 4};`, uniformParsers[j].codeUbo(uboElement.data.name, uniform));
          parsed = true;
          break;
        }
      }
      if (!parsed) {
        if (uboElement.data.size > 1) {
          const size2 = mapSize(uboElement.data.type);
          const rowSize = Math.max(GLSL_TO_STD40_SIZE[uboElement.data.type] / 16, 1);
          const elementSize = size2 / rowSize;
          const remainder = (4 - elementSize % 4) % 4;
          funcFragments.push(`
                cv = ud.${name}.value;
                v = uv.${name};
                offset = ${uboElement.offset / 4};

                t = 0;

                for(var i=0; i < ${uboElement.data.size * rowSize}; i++)
                {
                    for(var j = 0; j < ${elementSize}; j++)
                    {
                        data[offset++] = v[t++];
                    }
                    offset += ${remainder};
                }

                `);
        } else {
          const template = UBO_TO_SINGLE_SETTERS[uboElement.data.type];
          funcFragments.push(`
                cv = ud.${name}.value;
                v = uv.${name};
                offset = ${uboElement.offset / 4};
                ${template};
                `);
        }
      }
    }
    funcFragments.push(`
       renderer.buffer.update(buffer);
    `);
    return {
      size,
      syncFunc: new Function("ud", "uv", "renderer", "syncData", "buffer", funcFragments.join("\n"))
    };
  }

  // node_modules/pixijs/core/shader/ShaderSystem.mjs
  var UID5 = 0;
  var defaultSyncData = { textureCount: 0, uboCount: 0 };
  var ShaderSystem = class {
    constructor(renderer) {
      this.destroyed = false;
      this.renderer = renderer;
      this.systemCheck();
      this.gl = null;
      this.shader = null;
      this.program = null;
      this.cache = {};
      this._uboCache = {};
      this.id = UID5++;
    }
    systemCheck() {
      if (!unsafeEvalSupported()) {
        throw new Error("Current environment does not allow unsafe-eval, please use pixijs/unsafe-eval module to enable support.");
      }
    }
    contextChange(gl) {
      this.gl = gl;
      this.reset();
    }
    bind(shader, dontSync) {
      shader.disposeRunner.add(this);
      shader.uniforms.globals = this.renderer.globalUniforms;
      const program = shader.program;
      const glProgram = program.glPrograms[this.renderer.CONTEXT_UID] || this.generateProgram(shader);
      this.shader = shader;
      if (this.program !== program) {
        this.program = program;
        this.gl.useProgram(glProgram.program);
      }
      if (!dontSync) {
        defaultSyncData.textureCount = 0;
        defaultSyncData.uboCount = 0;
        this.syncUniformGroup(shader.uniformGroup, defaultSyncData);
      }
      return glProgram;
    }
    setUniforms(uniforms) {
      const shader = this.shader.program;
      const glProgram = shader.glPrograms[this.renderer.CONTEXT_UID];
      shader.syncUniforms(glProgram.uniformData, uniforms, this.renderer);
    }
    syncUniformGroup(group, syncData) {
      const glProgram = this.getGlProgram();
      if (!group.static || group.dirtyId !== glProgram.uniformDirtyGroups[group.id]) {
        glProgram.uniformDirtyGroups[group.id] = group.dirtyId;
        this.syncUniforms(group, glProgram, syncData);
      }
    }
    syncUniforms(group, glProgram, syncData) {
      const syncFunc = group.syncUniforms[this.shader.program.id] || this.createSyncGroups(group);
      syncFunc(glProgram.uniformData, group.uniforms, this.renderer, syncData);
    }
    createSyncGroups(group) {
      const id2 = this.getSignature(group, this.shader.program.uniformData, "u");
      if (!this.cache[id2]) {
        this.cache[id2] = generateUniformsSync(group, this.shader.program.uniformData);
      }
      group.syncUniforms[this.shader.program.id] = this.cache[id2];
      return group.syncUniforms[this.shader.program.id];
    }
    syncUniformBufferGroup(group, name) {
      const glProgram = this.getGlProgram();
      if (!group.static || group.dirtyId !== 0 || !glProgram.uniformGroups[group.id]) {
        group.dirtyId = 0;
        const syncFunc = glProgram.uniformGroups[group.id] || this.createSyncBufferGroup(group, glProgram, name);
        group.buffer.update();
        syncFunc(glProgram.uniformData, group.uniforms, this.renderer, defaultSyncData, group.buffer);
      }
      this.renderer.buffer.bindBufferBase(group.buffer, glProgram.uniformBufferBindings[name]);
    }
    createSyncBufferGroup(group, glProgram, name) {
      const { gl } = this.renderer;
      this.renderer.buffer.bind(group.buffer);
      const uniformBlockIndex = this.gl.getUniformBlockIndex(glProgram.program, name);
      glProgram.uniformBufferBindings[name] = this.shader.uniformBindCount;
      gl.uniformBlockBinding(glProgram.program, uniformBlockIndex, this.shader.uniformBindCount);
      this.shader.uniformBindCount++;
      const id2 = this.getSignature(group, this.shader.program.uniformData, "ubo");
      let uboData = this._uboCache[id2];
      if (!uboData) {
        uboData = this._uboCache[id2] = generateUniformBufferSync(group, this.shader.program.uniformData);
      }
      if (group.autoManage) {
        const data = new Float32Array(uboData.size / 4);
        group.buffer.update(data);
      }
      glProgram.uniformGroups[group.id] = uboData.syncFunc;
      return glProgram.uniformGroups[group.id];
    }
    getSignature(group, uniformData, preFix) {
      const uniforms = group.uniforms;
      const strings = [`${preFix}-`];
      for (const i in uniforms) {
        strings.push(i);
        if (uniformData[i]) {
          strings.push(uniformData[i].type);
        }
      }
      return strings.join("-");
    }
    getGlProgram() {
      if (this.shader) {
        return this.shader.program.glPrograms[this.renderer.CONTEXT_UID];
      }
      return null;
    }
    generateProgram(shader) {
      const gl = this.gl;
      const program = shader.program;
      const glProgram = generateProgram(gl, program);
      program.glPrograms[this.renderer.CONTEXT_UID] = glProgram;
      return glProgram;
    }
    reset() {
      this.program = null;
      this.shader = null;
    }
    disposeShader(shader) {
      if (this.shader === shader) {
        this.shader = null;
      }
    }
    destroy() {
      this.renderer = null;
      this.destroyed = true;
    }
  };
  ShaderSystem.extension = {
    type: ExtensionType.RendererSystem,
    name: "shader"
  };
  extensions.add(ShaderSystem);

  // node_modules/pixijs/core/startup/StartupSystem.mjs
  var StartupSystem = class {
    constructor(renderer) {
      this.renderer = renderer;
    }
    run(options) {
      const renderer = this.renderer;
      renderer.emitWithCustomOptions(renderer.runners.init, options);
      if (options.hello) {
        console.log(`PixiJS ${"7.1.1"} - ${renderer.rendererLogId} - https://pixijs.com`);
      }
      renderer.resize(this.renderer.screen.width, this.renderer.screen.height);
    }
    destroy() {
    }
  };
  StartupSystem.extension = {
    type: [
      ExtensionType.RendererSystem,
      ExtensionType.CanvasRendererSystem
    ],
    name: "startup"
  };
  extensions.add(StartupSystem);

  // node_modules/pixijs/core/state/utils/mapWebGLBlendModesToPixi.mjs
  function mapWebGLBlendModesToPixi(gl, array2 = []) {
    array2[BLEND_MODES.NORMAL] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array2[BLEND_MODES.ADD] = [gl.ONE, gl.ONE];
    array2[BLEND_MODES.MULTIPLY] = [gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array2[BLEND_MODES.SCREEN] = [gl.ONE, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array2[BLEND_MODES.OVERLAY] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array2[BLEND_MODES.DARKEN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array2[BLEND_MODES.LIGHTEN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array2[BLEND_MODES.COLOR_DODGE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array2[BLEND_MODES.COLOR_BURN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array2[BLEND_MODES.HARD_LIGHT] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array2[BLEND_MODES.SOFT_LIGHT] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array2[BLEND_MODES.DIFFERENCE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array2[BLEND_MODES.EXCLUSION] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array2[BLEND_MODES.HUE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array2[BLEND_MODES.SATURATION] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array2[BLEND_MODES.COLOR] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array2[BLEND_MODES.LUMINOSITY] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array2[BLEND_MODES.NONE] = [0, 0];
    array2[BLEND_MODES.NORMAL_NPM] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array2[BLEND_MODES.ADD_NPM] = [gl.SRC_ALPHA, gl.ONE, gl.ONE, gl.ONE];
    array2[BLEND_MODES.SCREEN_NPM] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array2[BLEND_MODES.SRC_IN] = [gl.DST_ALPHA, gl.ZERO];
    array2[BLEND_MODES.SRC_OUT] = [gl.ONE_MINUS_DST_ALPHA, gl.ZERO];
    array2[BLEND_MODES.SRC_ATOP] = [gl.DST_ALPHA, gl.ONE_MINUS_SRC_ALPHA];
    array2[BLEND_MODES.DST_OVER] = [gl.ONE_MINUS_DST_ALPHA, gl.ONE];
    array2[BLEND_MODES.DST_IN] = [gl.ZERO, gl.SRC_ALPHA];
    array2[BLEND_MODES.DST_OUT] = [gl.ZERO, gl.ONE_MINUS_SRC_ALPHA];
    array2[BLEND_MODES.DST_ATOP] = [gl.ONE_MINUS_DST_ALPHA, gl.SRC_ALPHA];
    array2[BLEND_MODES.XOR] = [gl.ONE_MINUS_DST_ALPHA, gl.ONE_MINUS_SRC_ALPHA];
    array2[BLEND_MODES.SUBTRACT] = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, gl.FUNC_REVERSE_SUBTRACT, gl.FUNC_ADD];
    return array2;
  }

  // node_modules/pixijs/core/state/StateSystem.mjs
  var BLEND2 = 0;
  var OFFSET2 = 1;
  var CULLING2 = 2;
  var DEPTH_TEST2 = 3;
  var WINDING2 = 4;
  var DEPTH_MASK2 = 5;
  var _StateSystem = class {
    constructor() {
      this.gl = null;
      this.stateId = 0;
      this.polygonOffset = 0;
      this.blendMode = BLEND_MODES.NONE;
      this._blendEq = false;
      this.map = [];
      this.map[BLEND2] = this.setBlend;
      this.map[OFFSET2] = this.setOffset;
      this.map[CULLING2] = this.setCullFace;
      this.map[DEPTH_TEST2] = this.setDepthTest;
      this.map[WINDING2] = this.setFrontFace;
      this.map[DEPTH_MASK2] = this.setDepthMask;
      this.checks = [];
      this.defaultState = new State();
      this.defaultState.blend = true;
    }
    contextChange(gl) {
      this.gl = gl;
      this.blendModes = mapWebGLBlendModesToPixi(gl);
      this.set(this.defaultState);
      this.reset();
    }
    set(state) {
      state = state || this.defaultState;
      if (this.stateId !== state.data) {
        let diff = this.stateId ^ state.data;
        let i = 0;
        while (diff) {
          if (diff & 1) {
            this.map[i].call(this, !!(state.data & 1 << i));
          }
          diff = diff >> 1;
          i++;
        }
        this.stateId = state.data;
      }
      for (let i = 0; i < this.checks.length; i++) {
        this.checks[i](this, state);
      }
    }
    forceState(state) {
      state = state || this.defaultState;
      for (let i = 0; i < this.map.length; i++) {
        this.map[i].call(this, !!(state.data & 1 << i));
      }
      for (let i = 0; i < this.checks.length; i++) {
        this.checks[i](this, state);
      }
      this.stateId = state.data;
    }
    setBlend(value) {
      this.updateCheck(_StateSystem.checkBlendMode, value);
      this.gl[value ? "enable" : "disable"](this.gl.BLEND);
    }
    setOffset(value) {
      this.updateCheck(_StateSystem.checkPolygonOffset, value);
      this.gl[value ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL);
    }
    setDepthTest(value) {
      this.gl[value ? "enable" : "disable"](this.gl.DEPTH_TEST);
    }
    setDepthMask(value) {
      this.gl.depthMask(value);
    }
    setCullFace(value) {
      this.gl[value ? "enable" : "disable"](this.gl.CULL_FACE);
    }
    setFrontFace(value) {
      this.gl.frontFace(this.gl[value ? "CW" : "CCW"]);
    }
    setBlendMode(value) {
      if (value === this.blendMode) {
        return;
      }
      this.blendMode = value;
      const mode = this.blendModes[value];
      const gl = this.gl;
      if (mode.length === 2) {
        gl.blendFunc(mode[0], mode[1]);
      } else {
        gl.blendFuncSeparate(mode[0], mode[1], mode[2], mode[3]);
      }
      if (mode.length === 6) {
        this._blendEq = true;
        gl.blendEquationSeparate(mode[4], mode[5]);
      } else if (this._blendEq) {
        this._blendEq = false;
        gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
      }
    }
    setPolygonOffset(value, scale) {
      this.gl.polygonOffset(value, scale);
    }
    reset() {
      this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, false);
      this.forceState(this.defaultState);
      this._blendEq = true;
      this.blendMode = -1;
      this.setBlendMode(0);
    }
    updateCheck(func, value) {
      const index2 = this.checks.indexOf(func);
      if (value && index2 === -1) {
        this.checks.push(func);
      } else if (!value && index2 !== -1) {
        this.checks.splice(index2, 1);
      }
    }
    static checkBlendMode(system, state) {
      system.setBlendMode(state.blendMode);
    }
    static checkPolygonOffset(system, state) {
      system.setPolygonOffset(1, state.polygonOffset);
    }
    destroy() {
      this.gl = null;
    }
  };
  var StateSystem = _StateSystem;
  StateSystem.extension = {
    type: ExtensionType.RendererSystem,
    name: "state"
  };
  extensions.add(StateSystem);

  // node_modules/pixijs/core/system/SystemManager.mjs
  var SystemManager = class extends import_eventemitter3.default {
    constructor() {
      super(...arguments);
      this.runners = {};
      this._systemsHash = {};
    }
    setup(config) {
      var _a;
      this.addRunners(...config.runners);
      const priority = ((_a = config.priority) != null ? _a : []).filter((key) => config.systems[key]);
      const orderByPriority = [
        ...priority,
        ...Object.keys(config.systems).filter((key) => !priority.includes(key))
      ];
      for (const i of orderByPriority) {
        this.addSystem(config.systems[i], i);
      }
    }
    addRunners(...runnerIds) {
      runnerIds.forEach((runnerId) => {
        this.runners[runnerId] = new Runner(runnerId);
      });
    }
    addSystem(ClassRef, name) {
      const system = new ClassRef(this);
      if (this[name]) {
        throw new Error(`Whoops! The name "${name}" is already in use`);
      }
      this[name] = system;
      this._systemsHash[name] = system;
      for (const i in this.runners) {
        this.runners[i].add(system);
      }
      return this;
    }
    emitWithCustomOptions(runner, options) {
      const systemHashKeys = Object.keys(this._systemsHash);
      runner.items.forEach((system) => {
        const systemName = systemHashKeys.find((systemId) => this._systemsHash[systemId] === system);
        system[runner.name](options[systemName]);
      });
    }
    destroy() {
      Object.values(this.runners).forEach((runner) => {
        runner.destroy();
      });
      this._systemsHash = {};
    }
  };

  // node_modules/pixijs/core/textures/TextureGCSystem.mjs
  var _TextureGCSystem = class {
    constructor(renderer) {
      this.renderer = renderer;
      this.count = 0;
      this.checkCount = 0;
      this.maxIdle = _TextureGCSystem.defaultMaxIdle;
      this.checkCountMax = _TextureGCSystem.defaultCheckCountMax;
      this.mode = _TextureGCSystem.defaultMode;
    }
    postrender() {
      if (!this.renderer.objectRenderer.renderingToScreen) {
        return;
      }
      this.count++;
      if (this.mode === GC_MODES.MANUAL) {
        return;
      }
      this.checkCount++;
      if (this.checkCount > this.checkCountMax) {
        this.checkCount = 0;
        this.run();
      }
    }
    run() {
      const tm = this.renderer.texture;
      const managedTextures = tm.managedTextures;
      let wasRemoved = false;
      for (let i = 0; i < managedTextures.length; i++) {
        const texture = managedTextures[i];
        if (!texture.framebuffer && this.count - texture.touched > this.maxIdle) {
          tm.destroyTexture(texture, true);
          managedTextures[i] = null;
          wasRemoved = true;
        }
      }
      if (wasRemoved) {
        let j = 0;
        for (let i = 0; i < managedTextures.length; i++) {
          if (managedTextures[i] !== null) {
            managedTextures[j++] = managedTextures[i];
          }
        }
        managedTextures.length = j;
      }
    }
    unload(displayObject) {
      const tm = this.renderer.texture;
      const texture = displayObject._texture;
      if (texture && !texture.framebuffer) {
        tm.destroyTexture(texture);
      }
      for (let i = displayObject.children.length - 1; i >= 0; i--) {
        this.unload(displayObject.children[i]);
      }
    }
    destroy() {
      this.renderer = null;
    }
  };
  var TextureGCSystem = _TextureGCSystem;
  TextureGCSystem.defaultMode = GC_MODES.AUTO;
  TextureGCSystem.defaultMaxIdle = 60 * 60;
  TextureGCSystem.defaultCheckCountMax = 60 * 10;
  TextureGCSystem.extension = {
    type: ExtensionType.RendererSystem,
    name: "textureGC"
  };
  extensions.add(TextureGCSystem);

  // node_modules/pixijs/core/textures/GLTexture.mjs
  var GLTexture = class {
    constructor(texture) {
      this.texture = texture;
      this.width = -1;
      this.height = -1;
      this.dirtyId = -1;
      this.dirtyStyleId = -1;
      this.mipmap = false;
      this.wrapMode = 33071;
      this.type = TYPES.UNSIGNED_BYTE;
      this.internalFormat = FORMATS.RGBA;
      this.samplerType = 0;
    }
  };

  // node_modules/pixijs/core/textures/utils/mapTypeAndFormatToInternalFormat.mjs
  function mapTypeAndFormatToInternalFormat(gl) {
    let table;
    if ("WebGL2RenderingContext" in globalThis && gl instanceof globalThis.WebGL2RenderingContext) {
      table = {
        [TYPES.UNSIGNED_BYTE]: {
          [FORMATS.RGBA]: gl.RGBA8,
          [FORMATS.RGB]: gl.RGB8,
          [FORMATS.RG]: gl.RG8,
          [FORMATS.RED]: gl.R8,
          [FORMATS.RGBA_INTEGER]: gl.RGBA8UI,
          [FORMATS.RGB_INTEGER]: gl.RGB8UI,
          [FORMATS.RG_INTEGER]: gl.RG8UI,
          [FORMATS.RED_INTEGER]: gl.R8UI,
          [FORMATS.ALPHA]: gl.ALPHA,
          [FORMATS.LUMINANCE]: gl.LUMINANCE,
          [FORMATS.LUMINANCE_ALPHA]: gl.LUMINANCE_ALPHA
        },
        [TYPES.BYTE]: {
          [FORMATS.RGBA]: gl.RGBA8_SNORM,
          [FORMATS.RGB]: gl.RGB8_SNORM,
          [FORMATS.RG]: gl.RG8_SNORM,
          [FORMATS.RED]: gl.R8_SNORM,
          [FORMATS.RGBA_INTEGER]: gl.RGBA8I,
          [FORMATS.RGB_INTEGER]: gl.RGB8I,
          [FORMATS.RG_INTEGER]: gl.RG8I,
          [FORMATS.RED_INTEGER]: gl.R8I
        },
        [TYPES.UNSIGNED_SHORT]: {
          [FORMATS.RGBA_INTEGER]: gl.RGBA16UI,
          [FORMATS.RGB_INTEGER]: gl.RGB16UI,
          [FORMATS.RG_INTEGER]: gl.RG16UI,
          [FORMATS.RED_INTEGER]: gl.R16UI,
          [FORMATS.DEPTH_COMPONENT]: gl.DEPTH_COMPONENT16
        },
        [TYPES.SHORT]: {
          [FORMATS.RGBA_INTEGER]: gl.RGBA16I,
          [FORMATS.RGB_INTEGER]: gl.RGB16I,
          [FORMATS.RG_INTEGER]: gl.RG16I,
          [FORMATS.RED_INTEGER]: gl.R16I
        },
        [TYPES.UNSIGNED_INT]: {
          [FORMATS.RGBA_INTEGER]: gl.RGBA32UI,
          [FORMATS.RGB_INTEGER]: gl.RGB32UI,
          [FORMATS.RG_INTEGER]: gl.RG32UI,
          [FORMATS.RED_INTEGER]: gl.R32UI,
          [FORMATS.DEPTH_COMPONENT]: gl.DEPTH_COMPONENT24
        },
        [TYPES.INT]: {
          [FORMATS.RGBA_INTEGER]: gl.RGBA32I,
          [FORMATS.RGB_INTEGER]: gl.RGB32I,
          [FORMATS.RG_INTEGER]: gl.RG32I,
          [FORMATS.RED_INTEGER]: gl.R32I
        },
        [TYPES.FLOAT]: {
          [FORMATS.RGBA]: gl.RGBA32F,
          [FORMATS.RGB]: gl.RGB32F,
          [FORMATS.RG]: gl.RG32F,
          [FORMATS.RED]: gl.R32F,
          [FORMATS.DEPTH_COMPONENT]: gl.DEPTH_COMPONENT32F
        },
        [TYPES.HALF_FLOAT]: {
          [FORMATS.RGBA]: gl.RGBA16F,
          [FORMATS.RGB]: gl.RGB16F,
          [FORMATS.RG]: gl.RG16F,
          [FORMATS.RED]: gl.R16F
        },
        [TYPES.UNSIGNED_SHORT_5_6_5]: {
          [FORMATS.RGB]: gl.RGB565
        },
        [TYPES.UNSIGNED_SHORT_4_4_4_4]: {
          [FORMATS.RGBA]: gl.RGBA4
        },
        [TYPES.UNSIGNED_SHORT_5_5_5_1]: {
          [FORMATS.RGBA]: gl.RGB5_A1
        },
        [TYPES.UNSIGNED_INT_2_10_10_10_REV]: {
          [FORMATS.RGBA]: gl.RGB10_A2,
          [FORMATS.RGBA_INTEGER]: gl.RGB10_A2UI
        },
        [TYPES.UNSIGNED_INT_10F_11F_11F_REV]: {
          [FORMATS.RGB]: gl.R11F_G11F_B10F
        },
        [TYPES.UNSIGNED_INT_5_9_9_9_REV]: {
          [FORMATS.RGB]: gl.RGB9_E5
        },
        [TYPES.UNSIGNED_INT_24_8]: {
          [FORMATS.DEPTH_STENCIL]: gl.DEPTH24_STENCIL8
        },
        [TYPES.FLOAT_32_UNSIGNED_INT_24_8_REV]: {
          [FORMATS.DEPTH_STENCIL]: gl.DEPTH32F_STENCIL8
        }
      };
    } else {
      table = {
        [TYPES.UNSIGNED_BYTE]: {
          [FORMATS.RGBA]: gl.RGBA,
          [FORMATS.RGB]: gl.RGB,
          [FORMATS.ALPHA]: gl.ALPHA,
          [FORMATS.LUMINANCE]: gl.LUMINANCE,
          [FORMATS.LUMINANCE_ALPHA]: gl.LUMINANCE_ALPHA
        },
        [TYPES.UNSIGNED_SHORT_5_6_5]: {
          [FORMATS.RGB]: gl.RGB
        },
        [TYPES.UNSIGNED_SHORT_4_4_4_4]: {
          [FORMATS.RGBA]: gl.RGBA
        },
        [TYPES.UNSIGNED_SHORT_5_5_5_1]: {
          [FORMATS.RGBA]: gl.RGBA
        }
      };
    }
    return table;
  }

  // node_modules/pixijs/core/textures/TextureSystem.mjs
  var TextureSystem = class {
    constructor(renderer) {
      this.renderer = renderer;
      this.boundTextures = [];
      this.currentLocation = -1;
      this.managedTextures = [];
      this._unknownBoundTextures = false;
      this.unknownTexture = new BaseTexture();
      this.hasIntegerTextures = false;
    }
    contextChange() {
      const gl = this.gl = this.renderer.gl;
      this.CONTEXT_UID = this.renderer.CONTEXT_UID;
      this.webGLVersion = this.renderer.context.webGLVersion;
      this.internalFormats = mapTypeAndFormatToInternalFormat(gl);
      const maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
      this.boundTextures.length = maxTextures;
      for (let i = 0; i < maxTextures; i++) {
        this.boundTextures[i] = null;
      }
      this.emptyTextures = {};
      const emptyTexture2D = new GLTexture(gl.createTexture());
      gl.bindTexture(gl.TEXTURE_2D, emptyTexture2D.texture);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array(4));
      this.emptyTextures[gl.TEXTURE_2D] = emptyTexture2D;
      this.emptyTextures[gl.TEXTURE_CUBE_MAP] = new GLTexture(gl.createTexture());
      gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.emptyTextures[gl.TEXTURE_CUBE_MAP].texture);
      for (let i = 0; i < 6; i++) {
        gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
      }
      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      for (let i = 0; i < this.boundTextures.length; i++) {
        this.bind(null, i);
      }
    }
    bind(texture, location = 0) {
      const { gl } = this;
      texture = texture == null ? void 0 : texture.castToBaseTexture();
      if ((texture == null ? void 0 : texture.valid) && !texture.parentTextureArray) {
        texture.touched = this.renderer.textureGC.count;
        const glTexture = texture._glTextures[this.CONTEXT_UID] || this.initTexture(texture);
        if (this.boundTextures[location] !== texture) {
          if (this.currentLocation !== location) {
            this.currentLocation = location;
            gl.activeTexture(gl.TEXTURE0 + location);
          }
          gl.bindTexture(texture.target, glTexture.texture);
        }
        if (glTexture.dirtyId !== texture.dirtyId) {
          if (this.currentLocation !== location) {
            this.currentLocation = location;
            gl.activeTexture(gl.TEXTURE0 + location);
          }
          this.updateTexture(texture);
        } else if (glTexture.dirtyStyleId !== texture.dirtyStyleId) {
          this.updateTextureStyle(texture);
        }
        this.boundTextures[location] = texture;
      } else {
        if (this.currentLocation !== location) {
          this.currentLocation = location;
          gl.activeTexture(gl.TEXTURE0 + location);
        }
        gl.bindTexture(gl.TEXTURE_2D, this.emptyTextures[gl.TEXTURE_2D].texture);
        this.boundTextures[location] = null;
      }
    }
    reset() {
      this._unknownBoundTextures = true;
      this.hasIntegerTextures = false;
      this.currentLocation = -1;
      for (let i = 0; i < this.boundTextures.length; i++) {
        this.boundTextures[i] = this.unknownTexture;
      }
    }
    unbind(texture) {
      const { gl, boundTextures } = this;
      if (this._unknownBoundTextures) {
        this._unknownBoundTextures = false;
        for (let i = 0; i < boundTextures.length; i++) {
          if (boundTextures[i] === this.unknownTexture) {
            this.bind(null, i);
          }
        }
      }
      for (let i = 0; i < boundTextures.length; i++) {
        if (boundTextures[i] === texture) {
          if (this.currentLocation !== i) {
            gl.activeTexture(gl.TEXTURE0 + i);
            this.currentLocation = i;
          }
          gl.bindTexture(texture.target, this.emptyTextures[texture.target].texture);
          boundTextures[i] = null;
        }
      }
    }
    ensureSamplerType(maxTextures) {
      const { boundTextures, hasIntegerTextures, CONTEXT_UID } = this;
      if (!hasIntegerTextures) {
        return;
      }
      for (let i = maxTextures - 1; i >= 0; --i) {
        const tex = boundTextures[i];
        if (tex) {
          const glTexture = tex._glTextures[CONTEXT_UID];
          if (glTexture.samplerType !== SAMPLER_TYPES.FLOAT) {
            this.renderer.texture.unbind(tex);
          }
        }
      }
    }
    initTexture(texture) {
      const glTexture = new GLTexture(this.gl.createTexture());
      glTexture.dirtyId = -1;
      texture._glTextures[this.CONTEXT_UID] = glTexture;
      this.managedTextures.push(texture);
      texture.on("dispose", this.destroyTexture, this);
      return glTexture;
    }
    initTextureType(texture, glTexture) {
      var _a, _b;
      glTexture.internalFormat = (_b = (_a = this.internalFormats[texture.type]) == null ? void 0 : _a[texture.format]) != null ? _b : texture.format;
      if (this.webGLVersion === 2 && texture.type === TYPES.HALF_FLOAT) {
        glTexture.type = this.gl.HALF_FLOAT;
      } else {
        glTexture.type = texture.type;
      }
    }
    updateTexture(texture) {
      var _a;
      const glTexture = texture._glTextures[this.CONTEXT_UID];
      if (!glTexture) {
        return;
      }
      const renderer = this.renderer;
      this.initTextureType(texture, glTexture);
      if ((_a = texture.resource) == null ? void 0 : _a.upload(renderer, texture, glTexture)) {
        if (glTexture.samplerType !== SAMPLER_TYPES.FLOAT) {
          this.hasIntegerTextures = true;
        }
      } else {
        const width = texture.realWidth;
        const height = texture.realHeight;
        const gl = renderer.gl;
        if (glTexture.width !== width || glTexture.height !== height || glTexture.dirtyId < 0) {
          glTexture.width = width;
          glTexture.height = height;
          gl.texImage2D(texture.target, 0, glTexture.internalFormat, width, height, 0, texture.format, glTexture.type, null);
        }
      }
      if (texture.dirtyStyleId !== glTexture.dirtyStyleId) {
        this.updateTextureStyle(texture);
      }
      glTexture.dirtyId = texture.dirtyId;
    }
    destroyTexture(texture, skipRemove) {
      const { gl } = this;
      texture = texture.castToBaseTexture();
      if (texture._glTextures[this.CONTEXT_UID]) {
        this.unbind(texture);
        gl.deleteTexture(texture._glTextures[this.CONTEXT_UID].texture);
        texture.off("dispose", this.destroyTexture, this);
        delete texture._glTextures[this.CONTEXT_UID];
        if (!skipRemove) {
          const i = this.managedTextures.indexOf(texture);
          if (i !== -1) {
            removeItems(this.managedTextures, i, 1);
          }
        }
      }
    }
    updateTextureStyle(texture) {
      var _a;
      const glTexture = texture._glTextures[this.CONTEXT_UID];
      if (!glTexture) {
        return;
      }
      if ((texture.mipmap === MIPMAP_MODES.POW2 || this.webGLVersion !== 2) && !texture.isPowerOfTwo) {
        glTexture.mipmap = false;
      } else {
        glTexture.mipmap = texture.mipmap >= 1;
      }
      if (this.webGLVersion !== 2 && !texture.isPowerOfTwo) {
        glTexture.wrapMode = WRAP_MODES.CLAMP;
      } else {
        glTexture.wrapMode = texture.wrapMode;
      }
      if ((_a = texture.resource) == null ? void 0 : _a.style(this.renderer, texture, glTexture)) {
      } else {
        this.setStyle(texture, glTexture);
      }
      glTexture.dirtyStyleId = texture.dirtyStyleId;
    }
    setStyle(texture, glTexture) {
      const gl = this.gl;
      if (glTexture.mipmap && texture.mipmap !== MIPMAP_MODES.ON_MANUAL) {
        gl.generateMipmap(texture.target);
      }
      gl.texParameteri(texture.target, gl.TEXTURE_WRAP_S, glTexture.wrapMode);
      gl.texParameteri(texture.target, gl.TEXTURE_WRAP_T, glTexture.wrapMode);
      if (glTexture.mipmap) {
        gl.texParameteri(texture.target, gl.TEXTURE_MIN_FILTER, texture.scaleMode === SCALE_MODES.LINEAR ? gl.LINEAR_MIPMAP_LINEAR : gl.NEAREST_MIPMAP_NEAREST);
        const anisotropicExt = this.renderer.context.extensions.anisotropicFiltering;
        if (anisotropicExt && texture.anisotropicLevel > 0 && texture.scaleMode === SCALE_MODES.LINEAR) {
          const level = Math.min(texture.anisotropicLevel, gl.getParameter(anisotropicExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT));
          gl.texParameterf(texture.target, anisotropicExt.TEXTURE_MAX_ANISOTROPY_EXT, level);
        }
      } else {
        gl.texParameteri(texture.target, gl.TEXTURE_MIN_FILTER, texture.scaleMode === SCALE_MODES.LINEAR ? gl.LINEAR : gl.NEAREST);
      }
      gl.texParameteri(texture.target, gl.TEXTURE_MAG_FILTER, texture.scaleMode === SCALE_MODES.LINEAR ? gl.LINEAR : gl.NEAREST);
    }
    destroy() {
      this.renderer = null;
    }
  };
  TextureSystem.extension = {
    type: ExtensionType.RendererSystem,
    name: "texture"
  };
  extensions.add(TextureSystem);

  // node_modules/pixijs/core/transformFeedback/TransformFeedbackSystem.mjs
  var TransformFeedbackSystem = class {
    constructor(renderer) {
      this.renderer = renderer;
    }
    contextChange() {
      this.gl = this.renderer.gl;
      this.CONTEXT_UID = this.renderer.CONTEXT_UID;
    }
    bind(transformFeedback) {
      const { gl, CONTEXT_UID } = this;
      const glTransformFeedback = transformFeedback._glTransformFeedbacks[CONTEXT_UID] || this.createGLTransformFeedback(transformFeedback);
      gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, glTransformFeedback);
    }
    unbind() {
      const { gl } = this;
      gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);
    }
    beginTransformFeedback(drawMode, shader) {
      const { gl, renderer } = this;
      if (shader) {
        renderer.shader.bind(shader);
      }
      gl.beginTransformFeedback(drawMode);
    }
    endTransformFeedback() {
      const { gl } = this;
      gl.endTransformFeedback();
    }
    createGLTransformFeedback(tf) {
      const { gl, renderer, CONTEXT_UID } = this;
      const glTransformFeedback = gl.createTransformFeedback();
      tf._glTransformFeedbacks[CONTEXT_UID] = glTransformFeedback;
      gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, glTransformFeedback);
      for (let i = 0; i < tf.buffers.length; i++) {
        const buffer = tf.buffers[i];
        if (!buffer)
          continue;
        renderer.buffer.update(buffer);
        buffer._glBuffers[CONTEXT_UID].refCount++;
        gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, i, buffer._glBuffers[CONTEXT_UID].buffer || null);
      }
      gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);
      tf.disposeRunner.add(this);
      return glTransformFeedback;
    }
    disposeTransformFeedback(tf, contextLost) {
      const glTF = tf._glTransformFeedbacks[this.CONTEXT_UID];
      const gl = this.gl;
      tf.disposeRunner.remove(this);
      const bufferSystem = this.renderer.buffer;
      if (bufferSystem) {
        for (let i = 0; i < tf.buffers.length; i++) {
          const buffer = tf.buffers[i];
          if (!buffer)
            continue;
          const buf = buffer._glBuffers[this.CONTEXT_UID];
          if (buf) {
            buf.refCount--;
            if (buf.refCount === 0 && !contextLost) {
              bufferSystem.dispose(buffer, contextLost);
            }
          }
        }
      }
      if (!glTF) {
        return;
      }
      if (!contextLost) {
        gl.deleteTransformFeedback(glTF);
      }
      delete tf._glTransformFeedbacks[this.CONTEXT_UID];
    }
    destroy() {
      this.renderer = null;
    }
  };
  TransformFeedbackSystem.extension = {
    type: ExtensionType.RendererSystem,
    name: "transformFeedback"
  };
  extensions.add(TransformFeedbackSystem);

  // node_modules/pixijs/core/view/ViewSystem.mjs
  var ViewSystem = class {
    constructor(renderer) {
      this.renderer = renderer;
    }
    init(options) {
      this.screen = new Rectangle(0, 0, options.width, options.height);
      this.element = options.view || settings.ADAPTER.createCanvas();
      this.resolution = options.resolution || settings.RESOLUTION;
      this.autoDensity = !!options.autoDensity;
    }
    resizeView(desiredScreenWidth, desiredScreenHeight) {
      this.element.width = Math.round(desiredScreenWidth * this.resolution);
      this.element.height = Math.round(desiredScreenHeight * this.resolution);
      const screenWidth = this.element.width / this.resolution;
      const screenHeight = this.element.height / this.resolution;
      this.screen.width = screenWidth;
      this.screen.height = screenHeight;
      if (this.autoDensity) {
        this.element.style.width = `${screenWidth}px`;
        this.element.style.height = `${screenHeight}px`;
      }
      this.renderer.emit("resize", screenWidth, screenHeight);
      this.renderer.runners.resize.emit(this.screen.width, this.screen.height);
    }
    destroy(removeView) {
      var _a;
      if (removeView) {
        (_a = this.element.parentNode) == null ? void 0 : _a.removeChild(this.element);
      }
      this.renderer = null;
      this.element = null;
      this.screen = null;
    }
  };
  ViewSystem.extension = {
    type: [
      ExtensionType.RendererSystem,
      ExtensionType.CanvasRendererSystem
    ],
    name: "_view"
  };
  extensions.add(ViewSystem);

  // node_modules/pixijs/core/settings.mjs
  settings.PREFER_ENV = ENV.WEBGL2;
  settings.STRICT_TEXTURE_CACHE = false;
  Object.defineProperties(settings, {
    WRAP_MODE: {
      get() {
        return BaseTexture.defaultOptions.wrapMode;
      },
      set(value) {
        deprecation("7.1.0", "settings.WRAP_MODE is deprecated, use BaseTexture.defaultOptions.wrapMode");
        BaseTexture.defaultOptions.wrapMode = value;
      }
    },
    SCALE_MODE: {
      get() {
        return BaseTexture.defaultOptions.scaleMode;
      },
      set(value) {
        deprecation("7.1.0", "settings.SCALE_MODE is deprecated, use BaseTexture.defaultOptions.scaleMode");
        BaseTexture.defaultOptions.scaleMode = value;
      }
    },
    MIPMAP_TEXTURES: {
      get() {
        return BaseTexture.defaultOptions.mipmap;
      },
      set(value) {
        deprecation("7.1.0", "settings.MIPMAP_TEXTURES is deprecated, use BaseTexture.defaultOptions.mipmap");
        BaseTexture.defaultOptions.mipmap = value;
      }
    },
    ANISOTROPIC_LEVEL: {
      get() {
        return BaseTexture.defaultOptions.anisotropicLevel;
      },
      set(value) {
        deprecation("7.1.0", "settings.ANISOTROPIC_LEVEL is deprecated, use BaseTexture.defaultOptions.anisotropicLevel");
        BaseTexture.defaultOptions.anisotropicLevel = value;
      }
    },
    FILTER_RESOLUTION: {
      get() {
        deprecation("7.1.0", "settings.FILTER_RESOLUTION is deprecated, use Filter.defaultResolution");
        return Filter.defaultResolution;
      },
      set(value) {
        Filter.defaultResolution = value;
      }
    },
    FILTER_MULTISAMPLE: {
      get() {
        deprecation("7.1.0", "settings.FILTER_MULTISAMPLE is deprecated, use Filter.defaultMultisample");
        return Filter.defaultMultisample;
      },
      set(value) {
        Filter.defaultMultisample = value;
      }
    },
    SPRITE_MAX_TEXTURES: {
      get() {
        return BatchRenderer.defaultMaxTextures;
      },
      set(value) {
        deprecation("7.1.0", "settings.SPRITE_MAX_TEXTURES is deprecated, use BatchRenderer.defaultMaxTextures");
        BatchRenderer.defaultMaxTextures = value;
      }
    },
    SPRITE_BATCH_SIZE: {
      get() {
        return BatchRenderer.defaultBatchSize;
      },
      set(value) {
        deprecation("7.1.0", "settings.SPRITE_BATCH_SIZE is deprecated, use BatchRenderer.defaultBatchSize");
        BatchRenderer.defaultBatchSize = value;
      }
    },
    CAN_UPLOAD_SAME_BUFFER: {
      get() {
        return BatchRenderer.canUploadSameBuffer;
      },
      set(value) {
        deprecation("7.1.0", "settings.CAN_UPLOAD_SAME_BUFFER is deprecated, use BatchRenderer.canUploadSameBuffer");
        BatchRenderer.canUploadSameBuffer = value;
      }
    },
    GC_MODE: {
      get() {
        return TextureGCSystem.defaultMode;
      },
      set(value) {
        deprecation("7.1.0", "settings.GC_MODE is deprecated, use TextureGCSystem.defaultMode");
        TextureGCSystem.defaultMode = value;
      }
    },
    GC_MAX_IDLE: {
      get() {
        return TextureGCSystem.defaultMaxIdle;
      },
      set(value) {
        deprecation("7.1.0", "settings.GC_MAX_IDLE is deprecated, use TextureGCSystem.defaultMaxIdle");
        TextureGCSystem.defaultMaxIdle = value;
      }
    },
    GC_MAX_CHECK_COUNT: {
      get() {
        return TextureGCSystem.defaultCheckCountMax;
      },
      set(value) {
        deprecation("7.1.0", "settings.GC_MAX_CHECK_COUNT is deprecated, use TextureGCSystem.defaultCheckCountMax");
        TextureGCSystem.defaultCheckCountMax = value;
      }
    },
    PRECISION_VERTEX: {
      get() {
        return Program.defaultVertexPrecision;
      },
      set(value) {
        deprecation("7.1.0", "settings.PRECISION_VERTEX is deprecated, use Program.defaultVertexPrecision");
        Program.defaultVertexPrecision = value;
      }
    },
    PRECISION_FRAGMENT: {
      get() {
        return Program.defaultFragmentPrecision;
      },
      set(value) {
        deprecation("7.1.0", "settings.PRECISION_FRAGMENT is deprecated, use Program.defaultFragmentPrecision");
        Program.defaultFragmentPrecision = value;
      }
    }
  });

  // node_modules/pixijs/ticker/const.mjs
  var UPDATE_PRIORITY = /* @__PURE__ */ ((UPDATE_PRIORITY2) => {
    UPDATE_PRIORITY2[UPDATE_PRIORITY2["HIGH"] = 25] = "HIGH";
    UPDATE_PRIORITY2[UPDATE_PRIORITY2["NORMAL"] = 0] = "NORMAL";
    UPDATE_PRIORITY2[UPDATE_PRIORITY2["LOW"] = -25] = "LOW";
    UPDATE_PRIORITY2[UPDATE_PRIORITY2["UTILITY"] = -50] = "UTILITY";
    return UPDATE_PRIORITY2;
  })(UPDATE_PRIORITY || {});

  // node_modules/pixijs/ticker/TickerListener.mjs
  var TickerListener = class {
    constructor(fn, context2 = null, priority = 0, once = false) {
      this.next = null;
      this.previous = null;
      this._destroyed = false;
      this.fn = fn;
      this.context = context2;
      this.priority = priority;
      this.once = once;
    }
    match(fn, context2 = null) {
      return this.fn === fn && this.context === context2;
    }
    emit(deltaTime) {
      if (this.fn) {
        if (this.context) {
          this.fn.call(this.context, deltaTime);
        } else {
          this.fn(deltaTime);
        }
      }
      const redirect = this.next;
      if (this.once) {
        this.destroy(true);
      }
      if (this._destroyed) {
        this.next = null;
      }
      return redirect;
    }
    connect(previous) {
      this.previous = previous;
      if (previous.next) {
        previous.next.previous = this;
      }
      this.next = previous.next;
      previous.next = this;
    }
    destroy(hard = false) {
      this._destroyed = true;
      this.fn = null;
      this.context = null;
      if (this.previous) {
        this.previous.next = this.next;
      }
      if (this.next) {
        this.next.previous = this.previous;
      }
      const redirect = this.next;
      this.next = hard ? null : redirect;
      this.previous = null;
      return redirect;
    }
  };

  // node_modules/pixijs/ticker/Ticker.mjs
  var _Ticker = class {
    constructor() {
      this.autoStart = false;
      this.deltaTime = 1;
      this.lastTime = -1;
      this.speed = 1;
      this.started = false;
      this._requestId = null;
      this._maxElapsedMS = 100;
      this._minElapsedMS = 0;
      this._protected = false;
      this._lastFrame = -1;
      this._head = new TickerListener(null, null, Infinity);
      this.deltaMS = 1 / _Ticker.targetFPMS;
      this.elapsedMS = 1 / _Ticker.targetFPMS;
      this._tick = (time) => {
        this._requestId = null;
        if (this.started) {
          this.update(time);
          if (this.started && this._requestId === null && this._head.next) {
            this._requestId = requestAnimationFrame(this._tick);
          }
        }
      };
    }
    _requestIfNeeded() {
      if (this._requestId === null && this._head.next) {
        this.lastTime = performance.now();
        this._lastFrame = this.lastTime;
        this._requestId = requestAnimationFrame(this._tick);
      }
    }
    _cancelIfNeeded() {
      if (this._requestId !== null) {
        cancelAnimationFrame(this._requestId);
        this._requestId = null;
      }
    }
    _startIfPossible() {
      if (this.started) {
        this._requestIfNeeded();
      } else if (this.autoStart) {
        this.start();
      }
    }
    add(fn, context2, priority = UPDATE_PRIORITY.NORMAL) {
      return this._addListener(new TickerListener(fn, context2, priority));
    }
    addOnce(fn, context2, priority = UPDATE_PRIORITY.NORMAL) {
      return this._addListener(new TickerListener(fn, context2, priority, true));
    }
    _addListener(listener) {
      let current = this._head.next;
      let previous = this._head;
      if (!current) {
        listener.connect(previous);
      } else {
        while (current) {
          if (listener.priority > current.priority) {
            listener.connect(previous);
            break;
          }
          previous = current;
          current = current.next;
        }
        if (!listener.previous) {
          listener.connect(previous);
        }
      }
      this._startIfPossible();
      return this;
    }
    remove(fn, context2) {
      let listener = this._head.next;
      while (listener) {
        if (listener.match(fn, context2)) {
          listener = listener.destroy();
        } else {
          listener = listener.next;
        }
      }
      if (!this._head.next) {
        this._cancelIfNeeded();
      }
      return this;
    }
    get count() {
      if (!this._head) {
        return 0;
      }
      let count = 0;
      let current = this._head;
      while (current = current.next) {
        count++;
      }
      return count;
    }
    start() {
      if (!this.started) {
        this.started = true;
        this._requestIfNeeded();
      }
    }
    stop() {
      if (this.started) {
        this.started = false;
        this._cancelIfNeeded();
      }
    }
    destroy() {
      if (!this._protected) {
        this.stop();
        let listener = this._head.next;
        while (listener) {
          listener = listener.destroy(true);
        }
        this._head.destroy();
        this._head = null;
      }
    }
    update(currentTime = performance.now()) {
      let elapsedMS;
      if (currentTime > this.lastTime) {
        elapsedMS = this.elapsedMS = currentTime - this.lastTime;
        if (elapsedMS > this._maxElapsedMS) {
          elapsedMS = this._maxElapsedMS;
        }
        elapsedMS *= this.speed;
        if (this._minElapsedMS) {
          const delta = currentTime - this._lastFrame | 0;
          if (delta < this._minElapsedMS) {
            return;
          }
          this._lastFrame = currentTime - delta % this._minElapsedMS;
        }
        this.deltaMS = elapsedMS;
        this.deltaTime = this.deltaMS * _Ticker.targetFPMS;
        const head = this._head;
        let listener = head.next;
        while (listener) {
          listener = listener.emit(this.deltaTime);
        }
        if (!head.next) {
          this._cancelIfNeeded();
        }
      } else {
        this.deltaTime = this.deltaMS = this.elapsedMS = 0;
      }
      this.lastTime = currentTime;
    }
    get FPS() {
      return 1e3 / this.elapsedMS;
    }
    get minFPS() {
      return 1e3 / this._maxElapsedMS;
    }
    set minFPS(fps) {
      const minFPS = Math.min(this.maxFPS, fps);
      const minFPMS = Math.min(Math.max(0, minFPS) / 1e3, _Ticker.targetFPMS);
      this._maxElapsedMS = 1 / minFPMS;
    }
    get maxFPS() {
      if (this._minElapsedMS) {
        return Math.round(1e3 / this._minElapsedMS);
      }
      return 0;
    }
    set maxFPS(fps) {
      if (fps === 0) {
        this._minElapsedMS = 0;
      } else {
        const maxFPS = Math.max(this.minFPS, fps);
        this._minElapsedMS = 1 / (maxFPS / 1e3);
      }
    }
    static get shared() {
      if (!_Ticker._shared) {
        const shared = _Ticker._shared = new _Ticker();
        shared.autoStart = true;
        shared._protected = true;
      }
      return _Ticker._shared;
    }
    static get system() {
      if (!_Ticker._system) {
        const system = _Ticker._system = new _Ticker();
        system.autoStart = true;
        system._protected = true;
      }
      return _Ticker._system;
    }
  };
  var Ticker = _Ticker;
  Ticker.targetFPMS = 0.06;

  // node_modules/pixijs/ticker/settings.mjs
  Object.defineProperties(settings, {
    TARGET_FPMS: {
      get() {
        return Ticker.targetFPMS;
      },
      set(value) {
        deprecation("7.1.0", "settings.TARGET_FPMS is deprecated, use Ticker.targetFPMS");
        Ticker.targetFPMS = value;
      }
    }
  });

  // node_modules/pixijs/ticker/TickerPlugin.mjs
  var TickerPlugin = class {
    static init(options) {
      options = Object.assign({
        autoStart: true,
        sharedTicker: false
      }, options);
      Object.defineProperty(this, "ticker", {
        set(ticker) {
          if (this._ticker) {
            this._ticker.remove(this.render, this);
          }
          this._ticker = ticker;
          if (ticker) {
            ticker.add(this.render, this, UPDATE_PRIORITY.LOW);
          }
        },
        get() {
          return this._ticker;
        }
      });
      this.stop = () => {
        this._ticker.stop();
      };
      this.start = () => {
        this._ticker.start();
      };
      this._ticker = null;
      this.ticker = options.sharedTicker ? Ticker.shared : new Ticker();
      if (options.autoStart) {
        this.start();
      }
    }
    static destroy() {
      if (this._ticker) {
        const oldTicker = this._ticker;
        this.ticker = null;
        oldTicker.destroy();
      }
    }
  };
  TickerPlugin.extension = ExtensionType.Application;
  extensions.add(TickerPlugin);

  // node_modules/pixijs/core/autoDetectRenderer.mjs
  var renderers = [];
  extensions.handleByList(ExtensionType.Renderer, renderers);
  function autoDetectRenderer(options) {
    for (const RendererType of renderers) {
      if (RendererType.test(options)) {
        return new RendererType(options);
      }
    }
    throw new Error("Unable to auto-detect a suitable renderer.");
  }

  // node_modules/pixijs/core/fragments/default.mjs
  var $defaultVertex = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}";

  // node_modules/pixijs/core/fragments/defaultFilter.mjs
  var $defaultFilterVertex = "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n";

  // node_modules/pixijs/core/fragments/index.mjs
  var defaultVertex4 = $defaultVertex;
  var defaultFilterVertex = $defaultFilterVertex;

  // node_modules/pixijs/core/framebuffer/MultisampleSystem.mjs
  var MultisampleSystem = class {
    constructor(renderer) {
      this.renderer = renderer;
    }
    contextChange(gl) {
      let samples;
      if (this.renderer.context.webGLVersion === 1) {
        const framebuffer = gl.getParameter(gl.FRAMEBUFFER_BINDING);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        samples = gl.getParameter(gl.SAMPLES);
        gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
      } else {
        const framebuffer = gl.getParameter(gl.DRAW_FRAMEBUFFER_BINDING);
        gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
        samples = gl.getParameter(gl.SAMPLES);
        gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, framebuffer);
      }
      if (samples >= MSAA_QUALITY.HIGH) {
        this.multisample = MSAA_QUALITY.HIGH;
      } else if (samples >= MSAA_QUALITY.MEDIUM) {
        this.multisample = MSAA_QUALITY.MEDIUM;
      } else if (samples >= MSAA_QUALITY.LOW) {
        this.multisample = MSAA_QUALITY.LOW;
      } else {
        this.multisample = MSAA_QUALITY.NONE;
      }
    }
    destroy() {
    }
  };
  MultisampleSystem.extension = {
    type: ExtensionType.RendererSystem,
    name: "_multisample"
  };
  extensions.add(MultisampleSystem);

  // node_modules/pixijs/core/geometry/GLBuffer.mjs
  var GLBuffer = class {
    constructor(buffer) {
      this.buffer = buffer || null;
      this.updateID = -1;
      this.byteLength = -1;
      this.refCount = 0;
    }
  };

  // node_modules/pixijs/core/geometry/BufferSystem.mjs
  var BufferSystem = class {
    constructor(renderer) {
      this.renderer = renderer;
      this.managedBuffers = {};
      this.boundBufferBases = {};
    }
    destroy() {
      this.renderer = null;
    }
    contextChange() {
      this.disposeAll(true);
      this.gl = this.renderer.gl;
      this.CONTEXT_UID = this.renderer.CONTEXT_UID;
    }
    bind(buffer) {
      const { gl, CONTEXT_UID } = this;
      const glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);
      gl.bindBuffer(buffer.type, glBuffer.buffer);
    }
    unbind(type2) {
      const { gl } = this;
      gl.bindBuffer(type2, null);
    }
    bindBufferBase(buffer, index2) {
      const { gl, CONTEXT_UID } = this;
      if (this.boundBufferBases[index2] !== buffer) {
        const glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);
        this.boundBufferBases[index2] = buffer;
        gl.bindBufferBase(gl.UNIFORM_BUFFER, index2, glBuffer.buffer);
      }
    }
    bindBufferRange(buffer, index2, offset) {
      const { gl, CONTEXT_UID } = this;
      offset = offset || 0;
      const glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);
      gl.bindBufferRange(gl.UNIFORM_BUFFER, index2 || 0, glBuffer.buffer, offset * 256, 256);
    }
    update(buffer) {
      const { gl, CONTEXT_UID } = this;
      const glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);
      if (buffer._updateID === glBuffer.updateID) {
        return;
      }
      glBuffer.updateID = buffer._updateID;
      gl.bindBuffer(buffer.type, glBuffer.buffer);
      if (glBuffer.byteLength >= buffer.data.byteLength) {
        gl.bufferSubData(buffer.type, 0, buffer.data);
      } else {
        const drawType = buffer.static ? gl.STATIC_DRAW : gl.DYNAMIC_DRAW;
        glBuffer.byteLength = buffer.data.byteLength;
        gl.bufferData(buffer.type, buffer.data, drawType);
      }
    }
    dispose(buffer, contextLost) {
      if (!this.managedBuffers[buffer.id]) {
        return;
      }
      delete this.managedBuffers[buffer.id];
      const glBuffer = buffer._glBuffers[this.CONTEXT_UID];
      const gl = this.gl;
      buffer.disposeRunner.remove(this);
      if (!glBuffer) {
        return;
      }
      if (!contextLost) {
        gl.deleteBuffer(glBuffer.buffer);
      }
      delete buffer._glBuffers[this.CONTEXT_UID];
    }
    disposeAll(contextLost) {
      const all = Object.keys(this.managedBuffers);
      for (let i = 0; i < all.length; i++) {
        this.dispose(this.managedBuffers[all[i]], contextLost);
      }
    }
    createGLBuffer(buffer) {
      const { CONTEXT_UID, gl } = this;
      buffer._glBuffers[CONTEXT_UID] = new GLBuffer(gl.createBuffer());
      this.managedBuffers[buffer.id] = buffer;
      buffer.disposeRunner.add(this);
      return buffer._glBuffers[CONTEXT_UID];
    }
  };
  BufferSystem.extension = {
    type: ExtensionType.RendererSystem,
    name: "buffer"
  };
  extensions.add(BufferSystem);

  // node_modules/pixijs/core/render/ObjectRendererSystem.mjs
  var ObjectRendererSystem = class {
    constructor(renderer) {
      this.renderer = renderer;
    }
    render(displayObject, options) {
      const renderer = this.renderer;
      let renderTexture;
      let clear;
      let transform2;
      let skipUpdateTransform;
      if (options) {
        renderTexture = options.renderTexture;
        clear = options.clear;
        transform2 = options.transform;
        skipUpdateTransform = options.skipUpdateTransform;
      }
      this.renderingToScreen = !renderTexture;
      renderer.runners.prerender.emit();
      renderer.emit("prerender");
      renderer.projection.transform = transform2;
      if (renderer.context.isLost) {
        return;
      }
      if (!renderTexture) {
        this.lastObjectRendered = displayObject;
      }
      if (!skipUpdateTransform) {
        const cacheParent = displayObject.enableTempParent();
        displayObject.updateTransform();
        displayObject.disableTempParent(cacheParent);
      }
      renderer.renderTexture.bind(renderTexture);
      renderer.batch.currentRenderer.start();
      if (clear != null ? clear : renderer.background.clearBeforeRender) {
        renderer.renderTexture.clear();
      }
      displayObject.render(renderer);
      renderer.batch.currentRenderer.flush();
      if (renderTexture) {
        if (options.blit) {
          renderer.framebuffer.blit();
        }
        renderTexture.baseTexture.update();
      }
      renderer.runners.postrender.emit();
      renderer.projection.transform = null;
      renderer.emit("postrender");
    }
    destroy() {
      this.renderer = null;
      this.lastObjectRendered = null;
    }
  };
  ObjectRendererSystem.extension = {
    type: ExtensionType.RendererSystem,
    name: "objectRenderer"
  };
  extensions.add(ObjectRendererSystem);

  // node_modules/pixijs/core/Renderer.mjs
  var _Renderer = class extends SystemManager {
    constructor(options) {
      var _a;
      super();
      options = Object.assign({}, settings.RENDER_OPTIONS, options);
      this.gl = null;
      this.CONTEXT_UID = 0;
      this.globalUniforms = new UniformGroup({
        projectionMatrix: new Matrix()
      }, true);
      const systemConfig = {
        runners: [
          "init",
          "destroy",
          "contextChange",
          "resolutionChange",
          "reset",
          "update",
          "postrender",
          "prerender",
          "resize"
        ],
        systems: _Renderer.__systems,
        priority: [
          "_view",
          "textureGenerator",
          "background",
          "_plugin",
          "startup",
          "context",
          "state",
          "texture",
          "buffer",
          "geometry",
          "framebuffer",
          "transformFeedback",
          "mask",
          "scissor",
          "stencil",
          "projection",
          "textureGC",
          "filter",
          "renderTexture",
          "batch",
          "objectRenderer",
          "_multisample"
        ]
      };
      this.setup(systemConfig);
      if ("useContextAlpha" in options) {
        deprecation("7.0.0", "options.useContextAlpha is deprecated, use options.premultipliedAlpha and options.backgroundAlpha instead");
        options.premultipliedAlpha = options.useContextAlpha && options.useContextAlpha !== "notMultiplied";
        options.backgroundAlpha = options.useContextAlpha === false ? 1 : options.backgroundAlpha;
      }
      const startupOptions = {
        hello: options.hello,
        _plugin: _Renderer.__plugins,
        background: {
          alpha: options.backgroundAlpha,
          color: (_a = options.background) != null ? _a : options.backgroundColor,
          clearBeforeRender: options.clearBeforeRender
        },
        _view: {
          height: options.height,
          width: options.width,
          autoDensity: options.autoDensity,
          resolution: options.resolution,
          view: options.view
        },
        context: {
          antialias: options.antialias,
          context: options.context,
          powerPreference: options.powerPreference,
          premultipliedAlpha: options.premultipliedAlpha,
          preserveDrawingBuffer: options.preserveDrawingBuffer
        }
      };
      this.startup.run(startupOptions);
      this.options = options;
    }
    static test(options) {
      if (options == null ? void 0 : options.forceCanvas) {
        return false;
      }
      return isWebGLSupported();
    }
    render(displayObject, options) {
      this.objectRenderer.render(displayObject, options);
    }
    resize(desiredScreenWidth, desiredScreenHeight) {
      this._view.resizeView(desiredScreenWidth, desiredScreenHeight);
    }
    reset() {
      this.runners.reset.emit();
      return this;
    }
    clear() {
      this.renderTexture.bind();
      this.renderTexture.clear();
    }
    destroy(removeView = false) {
      this.runners.destroy.items.reverse();
      this.emitWithCustomOptions(this.runners.destroy, {
        _view: removeView
      });
      super.destroy();
    }
    get plugins() {
      return this._plugin.plugins;
    }
    get multisample() {
      return this._multisample.multisample;
    }
    get width() {
      return this._view.element.width;
    }
    get height() {
      return this._view.element.height;
    }
    get resolution() {
      return this._view.resolution;
    }
    set resolution(value) {
      this._view.resolution = value;
      this.runners.resolutionChange.emit(value);
    }
    get autoDensity() {
      return this._view.autoDensity;
    }
    get view() {
      return this._view.element;
    }
    get screen() {
      return this._view.screen;
    }
    get lastObjectRendered() {
      return this.objectRenderer.lastObjectRendered;
    }
    get renderingToScreen() {
      return this.objectRenderer.renderingToScreen;
    }
    get rendererLogId() {
      return `WebGL ${this.context.webGLVersion}`;
    }
    get clearBeforeRender() {
      deprecation("7.0.0", "renderer.clearBeforeRender has been deprecated, please use renderer.background.clearBeforeRender instead.");
      return this.background.clearBeforeRender;
    }
    get useContextAlpha() {
      deprecation("7.0.0", "renderer.useContextAlpha has been deprecated, please use renderer.context.premultipliedAlpha instead.");
      return this.context.useContextAlpha;
    }
    get preserveDrawingBuffer() {
      deprecation("7.0.0", "renderer.preserveDrawingBuffer has been deprecated, we cannot truly know this unless pixi created the context");
      return this.context.preserveDrawingBuffer;
    }
    get backgroundColor() {
      deprecation("7.0.0", "renderer.backgroundColor has been deprecated, use renderer.background.color instead.");
      return this.background.color;
    }
    set backgroundColor(value) {
      deprecation("7.0.0", "renderer.backgroundColor has been deprecated, use renderer.background.color instead.");
      this.background.color = value;
    }
    get backgroundAlpha() {
      deprecation("7.0.0", "renderer.backgroundAlpha has been deprecated, use renderer.background.alpha instead.");
      return this.background.color;
    }
    set backgroundAlpha(value) {
      deprecation("7.0.0", "renderer.backgroundAlpha has been deprecated, use renderer.background.alpha instead.");
      this.background.alpha = value;
    }
    get powerPreference() {
      deprecation("7.0.0", "renderer.powerPreference has been deprecated, we can only know this if pixi creates the context");
      return this.context.powerPreference;
    }
    generateTexture(displayObject, options) {
      return this.textureGenerator.generateTexture(displayObject, options);
    }
  };
  var Renderer = _Renderer;
  Renderer.extension = {
    type: ExtensionType.Renderer,
    priority: 1
  };
  Renderer.__plugins = {};
  Renderer.__systems = {};
  extensions.handleByMap(ExtensionType.RendererPlugin, Renderer.__plugins);
  extensions.handleByMap(ExtensionType.RendererSystem, Renderer.__systems);
  extensions.add(Renderer);

  // node_modules/pixijs/core/textures/resources/AbstractMultiResource.mjs
  var AbstractMultiResource = class extends Resource {
    constructor(length, options) {
      const { width, height } = options || {};
      super(width, height);
      this.items = [];
      this.itemDirtyIds = [];
      for (let i = 0; i < length; i++) {
        const partTexture = new BaseTexture();
        this.items.push(partTexture);
        this.itemDirtyIds.push(-2);
      }
      this.length = length;
      this._load = null;
      this.baseTexture = null;
    }
    initFromArray(resources, options) {
      for (let i = 0; i < this.length; i++) {
        if (!resources[i]) {
          continue;
        }
        if (resources[i].castToBaseTexture) {
          this.addBaseTextureAt(resources[i].castToBaseTexture(), i);
        } else if (resources[i] instanceof Resource) {
          this.addResourceAt(resources[i], i);
        } else {
          this.addResourceAt(autoDetectResource(resources[i], options), i);
        }
      }
    }
    dispose() {
      for (let i = 0, len = this.length; i < len; i++) {
        this.items[i].destroy();
      }
      this.items = null;
      this.itemDirtyIds = null;
      this._load = null;
    }
    addResourceAt(resource, index2) {
      if (!this.items[index2]) {
        throw new Error(`Index ${index2} is out of bounds`);
      }
      if (resource.valid && !this.valid) {
        this.resize(resource.width, resource.height);
      }
      this.items[index2].setResource(resource);
      return this;
    }
    bind(baseTexture) {
      if (this.baseTexture !== null) {
        throw new Error("Only one base texture per TextureArray is allowed");
      }
      super.bind(baseTexture);
      for (let i = 0; i < this.length; i++) {
        this.items[i].parentTextureArray = baseTexture;
        this.items[i].on("update", baseTexture.update, baseTexture);
      }
    }
    unbind(baseTexture) {
      super.unbind(baseTexture);
      for (let i = 0; i < this.length; i++) {
        this.items[i].parentTextureArray = null;
        this.items[i].off("update", baseTexture.update, baseTexture);
      }
    }
    load() {
      if (this._load) {
        return this._load;
      }
      const resources = this.items.map((item) => item.resource).filter((item) => item);
      const promises = resources.map((item) => item.load());
      this._load = Promise.all(promises).then(() => {
        const { realWidth, realHeight } = this.items[0];
        this.resize(realWidth, realHeight);
        return Promise.resolve(this);
      });
      return this._load;
    }
  };

  // node_modules/pixijs/core/textures/resources/ArrayResource.mjs
  var ArrayResource = class extends AbstractMultiResource {
    constructor(source, options) {
      const { width, height } = options || {};
      let urls;
      let length;
      if (Array.isArray(source)) {
        urls = source;
        length = source.length;
      } else {
        length = source;
      }
      super(length, { width, height });
      if (urls) {
        this.initFromArray(urls, options);
      }
    }
    addBaseTextureAt(baseTexture, index2) {
      if (baseTexture.resource) {
        this.addResourceAt(baseTexture.resource, index2);
      } else {
        throw new Error("ArrayResource does not support RenderTexture");
      }
      return this;
    }
    bind(baseTexture) {
      super.bind(baseTexture);
      baseTexture.target = TARGETS.TEXTURE_2D_ARRAY;
    }
    upload(renderer, texture, glTexture) {
      const { length, itemDirtyIds, items } = this;
      const { gl } = renderer;
      if (glTexture.dirtyId < 0) {
        gl.texImage3D(gl.TEXTURE_2D_ARRAY, 0, glTexture.internalFormat, this._width, this._height, length, 0, texture.format, glTexture.type, null);
      }
      for (let i = 0; i < length; i++) {
        const item = items[i];
        if (itemDirtyIds[i] < item.dirtyId) {
          itemDirtyIds[i] = item.dirtyId;
          if (item.valid) {
            gl.texSubImage3D(gl.TEXTURE_2D_ARRAY, 0, 0, 0, i, item.resource.width, item.resource.height, 1, texture.format, glTexture.type, item.resource.source);
          }
        }
      }
      return true;
    }
  };

  // node_modules/pixijs/core/textures/resources/CanvasResource.mjs
  var CanvasResource = class extends BaseImageResource {
    constructor(source) {
      super(source);
    }
    static test(source) {
      const { OffscreenCanvas: OffscreenCanvas2 } = globalThis;
      if (OffscreenCanvas2 && source instanceof OffscreenCanvas2) {
        return true;
      }
      return globalThis.HTMLCanvasElement && source instanceof HTMLCanvasElement;
    }
  };

  // node_modules/pixijs/core/textures/resources/CubeResource.mjs
  var _CubeResource = class extends AbstractMultiResource {
    constructor(source, options) {
      const { width, height, autoLoad, linkBaseTexture } = options || {};
      if (source && source.length !== _CubeResource.SIDES) {
        throw new Error(`Invalid length. Got ${source.length}, expected 6`);
      }
      super(6, { width, height });
      for (let i = 0; i < _CubeResource.SIDES; i++) {
        this.items[i].target = TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X + i;
      }
      this.linkBaseTexture = linkBaseTexture !== false;
      if (source) {
        this.initFromArray(source, options);
      }
      if (autoLoad !== false) {
        this.load();
      }
    }
    bind(baseTexture) {
      super.bind(baseTexture);
      baseTexture.target = TARGETS.TEXTURE_CUBE_MAP;
    }
    addBaseTextureAt(baseTexture, index2, linkBaseTexture) {
      if (linkBaseTexture === void 0) {
        linkBaseTexture = this.linkBaseTexture;
      }
      if (!this.items[index2]) {
        throw new Error(`Index ${index2} is out of bounds`);
      }
      if (!this.linkBaseTexture || baseTexture.parentTextureArray || Object.keys(baseTexture._glTextures).length > 0) {
        if (baseTexture.resource) {
          this.addResourceAt(baseTexture.resource, index2);
        } else {
          throw new Error(`CubeResource does not support copying of renderTexture.`);
        }
      } else {
        baseTexture.target = TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X + index2;
        baseTexture.parentTextureArray = this.baseTexture;
        this.items[index2] = baseTexture;
      }
      if (baseTexture.valid && !this.valid) {
        this.resize(baseTexture.realWidth, baseTexture.realHeight);
      }
      this.items[index2] = baseTexture;
      return this;
    }
    upload(renderer, _baseTexture, glTexture) {
      const dirty = this.itemDirtyIds;
      for (let i = 0; i < _CubeResource.SIDES; i++) {
        const side = this.items[i];
        if (dirty[i] < side.dirtyId || glTexture.dirtyId < _baseTexture.dirtyId) {
          if (side.valid && side.resource) {
            side.resource.upload(renderer, side, glTexture);
            dirty[i] = side.dirtyId;
          } else if (dirty[i] < -1) {
            renderer.gl.texImage2D(side.target, 0, glTexture.internalFormat, _baseTexture.realWidth, _baseTexture.realHeight, 0, _baseTexture.format, glTexture.type, null);
            dirty[i] = -1;
          }
        }
      }
      return true;
    }
    static test(source) {
      return Array.isArray(source) && source.length === _CubeResource.SIDES;
    }
  };
  var CubeResource = _CubeResource;
  CubeResource.SIDES = 6;

  // node_modules/pixijs/core/textures/resources/ImageBitmapResource.mjs
  var ImageBitmapResource = class extends BaseImageResource {
    constructor(source, options) {
      var _a;
      options = options || {};
      let baseSource;
      let url2;
      if (typeof source === "string") {
        baseSource = ImageBitmapResource.EMPTY;
        url2 = source;
      } else {
        baseSource = source;
        url2 = null;
      }
      super(baseSource);
      this.url = url2;
      this.crossOrigin = (_a = options.crossOrigin) != null ? _a : true;
      this.alphaMode = typeof options.alphaMode === "number" ? options.alphaMode : null;
      this._load = null;
      if (options.autoLoad !== false) {
        this.load();
      }
    }
    load() {
      if (this._load) {
        return this._load;
      }
      this._load = new Promise(async (resolve2, reject) => {
        if (this.url === null) {
          resolve2(this);
          return;
        }
        try {
          const response = await settings.ADAPTER.fetch(this.url, {
            mode: this.crossOrigin ? "cors" : "no-cors"
          });
          if (this.destroyed)
            return;
          const imageBlob = await response.blob();
          if (this.destroyed)
            return;
          const imageBitmap = await createImageBitmap(imageBlob, {
            premultiplyAlpha: this.alphaMode === null || this.alphaMode === ALPHA_MODES.UNPACK ? "premultiply" : "none"
          });
          if (this.destroyed)
            return;
          this.source = imageBitmap;
          this.update();
          resolve2(this);
        } catch (e) {
          if (this.destroyed)
            return;
          reject(e);
          this.onError.emit(e);
        }
      });
      return this._load;
    }
    upload(renderer, baseTexture, glTexture) {
      if (!(this.source instanceof ImageBitmap)) {
        this.load();
        return false;
      }
      if (typeof this.alphaMode === "number") {
        baseTexture.alphaMode = this.alphaMode;
      }
      return super.upload(renderer, baseTexture, glTexture);
    }
    dispose() {
      if (this.source instanceof ImageBitmap) {
        this.source.close();
      }
      super.dispose();
      this._load = null;
    }
    static test(source) {
      return !!globalThis.createImageBitmap && typeof ImageBitmap !== "undefined" && (typeof source === "string" || source instanceof ImageBitmap);
    }
    static get EMPTY() {
      var _a;
      ImageBitmapResource._EMPTY = (_a = ImageBitmapResource._EMPTY) != null ? _a : settings.ADAPTER.createCanvas(0, 0);
      return ImageBitmapResource._EMPTY;
    }
  };

  // node_modules/pixijs/core/textures/resources/SVGResource.mjs
  var _SVGResource = class extends BaseImageResource {
    constructor(sourceBase64, options) {
      options = options || {};
      super(settings.ADAPTER.createCanvas());
      this._width = 0;
      this._height = 0;
      this.svg = sourceBase64;
      this.scale = options.scale || 1;
      this._overrideWidth = options.width;
      this._overrideHeight = options.height;
      this._resolve = null;
      this._crossorigin = options.crossorigin;
      this._load = null;
      if (options.autoLoad !== false) {
        this.load();
      }
    }
    load() {
      if (this._load) {
        return this._load;
      }
      this._load = new Promise((resolve2) => {
        this._resolve = () => {
          this.resize(this.source.width, this.source.height);
          resolve2(this);
        };
        if (_SVGResource.SVG_XML.test(this.svg.trim())) {
          if (!btoa) {
            throw new Error("Your browser doesn't support base64 conversions.");
          }
          this.svg = `data:image/svg+xml;base64,${btoa(unescape(encodeURIComponent(this.svg)))}`;
        }
        this._loadSvg();
      });
      return this._load;
    }
    _loadSvg() {
      const tempImage = new Image();
      BaseImageResource.crossOrigin(tempImage, this.svg, this._crossorigin);
      tempImage.src = this.svg;
      tempImage.onerror = (event) => {
        if (!this._resolve) {
          return;
        }
        tempImage.onerror = null;
        this.onError.emit(event);
      };
      tempImage.onload = () => {
        if (!this._resolve) {
          return;
        }
        const svgWidth = tempImage.width;
        const svgHeight = tempImage.height;
        if (!svgWidth || !svgHeight) {
          throw new Error("The SVG image must have width and height defined (in pixels), canvas API needs them.");
        }
        let width = svgWidth * this.scale;
        let height = svgHeight * this.scale;
        if (this._overrideWidth || this._overrideHeight) {
          width = this._overrideWidth || this._overrideHeight / svgHeight * svgWidth;
          height = this._overrideHeight || this._overrideWidth / svgWidth * svgHeight;
        }
        width = Math.round(width);
        height = Math.round(height);
        const canvas = this.source;
        canvas.width = width;
        canvas.height = height;
        canvas._pixiId = `canvas_${uid()}`;
        canvas.getContext("2d").drawImage(tempImage, 0, 0, svgWidth, svgHeight, 0, 0, width, height);
        this._resolve();
        this._resolve = null;
      };
    }
    static getSize(svgString) {
      const sizeMatch = _SVGResource.SVG_SIZE.exec(svgString);
      const size = {};
      if (sizeMatch) {
        size[sizeMatch[1]] = Math.round(parseFloat(sizeMatch[3]));
        size[sizeMatch[5]] = Math.round(parseFloat(sizeMatch[7]));
      }
      return size;
    }
    dispose() {
      super.dispose();
      this._resolve = null;
      this._crossorigin = null;
    }
    static test(source, extension) {
      return extension === "svg" || typeof source === "string" && source.startsWith("data:image/svg+xml") || typeof source === "string" && _SVGResource.SVG_XML.test(source);
    }
  };
  var SVGResource = _SVGResource;
  SVGResource.SVG_XML = /^(<\?xml[^?]+\?>)?\s*(<!--[^(-->)]*-->)?\s*\<svg/m;
  SVGResource.SVG_SIZE = /<svg[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*>/i;

  // node_modules/pixijs/core/textures/resources/VideoResource.mjs
  var _VideoResource = class extends BaseImageResource {
    constructor(source, options) {
      options = options || {};
      if (!(source instanceof HTMLVideoElement)) {
        const videoElement = document.createElement("video");
        videoElement.setAttribute("preload", "auto");
        videoElement.setAttribute("webkit-playsinline", "");
        videoElement.setAttribute("playsinline", "");
        if (typeof source === "string") {
          source = [source];
        }
        const firstSrc = source[0].src || source[0];
        BaseImageResource.crossOrigin(videoElement, firstSrc, options.crossorigin);
        for (let i = 0; i < source.length; ++i) {
          const sourceElement = document.createElement("source");
          let { src, mime } = source[i];
          src = src || source[i];
          const baseSrc = src.split("?").shift().toLowerCase();
          const ext = baseSrc.slice(baseSrc.lastIndexOf(".") + 1);
          mime = mime || _VideoResource.MIME_TYPES[ext] || `video/${ext}`;
          sourceElement.src = src;
          sourceElement.type = mime;
          videoElement.appendChild(sourceElement);
        }
        source = videoElement;
      }
      super(source);
      this.noSubImage = true;
      this._autoUpdate = true;
      this._isConnectedToTicker = false;
      this._updateFPS = options.updateFPS || 0;
      this._msToNextUpdate = 0;
      this.autoPlay = options.autoPlay !== false;
      this._load = null;
      this._resolve = null;
      this._onCanPlay = this._onCanPlay.bind(this);
      this._onError = this._onError.bind(this);
      if (options.autoLoad !== false) {
        this.load();
      }
    }
    update(_deltaTime = 0) {
      if (!this.destroyed) {
        const elapsedMS = Ticker.shared.elapsedMS * this.source.playbackRate;
        this._msToNextUpdate = Math.floor(this._msToNextUpdate - elapsedMS);
        if (!this._updateFPS || this._msToNextUpdate <= 0) {
          super.update();
          this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0;
        }
      }
    }
    load() {
      if (this._load) {
        return this._load;
      }
      const source = this.source;
      if ((source.readyState === source.HAVE_ENOUGH_DATA || source.readyState === source.HAVE_FUTURE_DATA) && source.width && source.height) {
        source.complete = true;
      }
      source.addEventListener("play", this._onPlayStart.bind(this));
      source.addEventListener("pause", this._onPlayStop.bind(this));
      if (!this._isSourceReady()) {
        source.addEventListener("canplay", this._onCanPlay);
        source.addEventListener("canplaythrough", this._onCanPlay);
        source.addEventListener("error", this._onError, true);
      } else {
        this._onCanPlay();
      }
      this._load = new Promise((resolve2) => {
        if (this.valid) {
          resolve2(this);
        } else {
          this._resolve = resolve2;
          source.load();
        }
      });
      return this._load;
    }
    _onError(event) {
      this.source.removeEventListener("error", this._onError, true);
      this.onError.emit(event);
    }
    _isSourcePlaying() {
      const source = this.source;
      return !source.paused && !source.ended && this._isSourceReady();
    }
    _isSourceReady() {
      const source = this.source;
      return source.readyState > 2;
    }
    _onPlayStart() {
      if (!this.valid) {
        this._onCanPlay();
      }
      if (this.autoUpdate && !this._isConnectedToTicker) {
        Ticker.shared.add(this.update, this);
        this._isConnectedToTicker = true;
      }
    }
    _onPlayStop() {
      if (this._isConnectedToTicker) {
        Ticker.shared.remove(this.update, this);
        this._isConnectedToTicker = false;
      }
    }
    _onCanPlay() {
      const source = this.source;
      source.removeEventListener("canplay", this._onCanPlay);
      source.removeEventListener("canplaythrough", this._onCanPlay);
      const valid = this.valid;
      this.resize(source.videoWidth, source.videoHeight);
      if (!valid && this._resolve) {
        this._resolve(this);
        this._resolve = null;
      }
      if (this._isSourcePlaying()) {
        this._onPlayStart();
      } else if (this.autoPlay) {
        source.play();
      }
    }
    dispose() {
      if (this._isConnectedToTicker) {
        Ticker.shared.remove(this.update, this);
        this._isConnectedToTicker = false;
      }
      const source = this.source;
      if (source) {
        source.removeEventListener("error", this._onError, true);
        source.pause();
        source.src = "";
        source.load();
      }
      super.dispose();
    }
    get autoUpdate() {
      return this._autoUpdate;
    }
    set autoUpdate(value) {
      if (value !== this._autoUpdate) {
        this._autoUpdate = value;
        if (!this._autoUpdate && this._isConnectedToTicker) {
          Ticker.shared.remove(this.update, this);
          this._isConnectedToTicker = false;
        } else if (this._autoUpdate && !this._isConnectedToTicker && this._isSourcePlaying()) {
          Ticker.shared.add(this.update, this);
          this._isConnectedToTicker = true;
        }
      }
    }
    get updateFPS() {
      return this._updateFPS;
    }
    set updateFPS(value) {
      if (value !== this._updateFPS) {
        this._updateFPS = value;
      }
    }
    static test(source, extension) {
      return globalThis.HTMLVideoElement && source instanceof HTMLVideoElement || _VideoResource.TYPES.includes(extension);
    }
  };
  var VideoResource = _VideoResource;
  VideoResource.TYPES = ["mp4", "m4v", "webm", "ogg", "ogv", "h264", "avi", "mov"];
  VideoResource.MIME_TYPES = {
    ogv: "video/ogg",
    mov: "video/quicktime",
    m4v: "video/mp4"
  };

  // node_modules/pixijs/core/textures/resources/index.mjs
  INSTALLED.push(ImageBitmapResource, ImageResource, CanvasResource, VideoResource, SVGResource, BufferResource, CubeResource, ArrayResource);

  // node_modules/pixijs/display/Bounds.mjs
  var Bounds = class {
    constructor() {
      this.minX = Infinity;
      this.minY = Infinity;
      this.maxX = -Infinity;
      this.maxY = -Infinity;
      this.rect = null;
      this.updateID = -1;
    }
    isEmpty() {
      return this.minX > this.maxX || this.minY > this.maxY;
    }
    clear() {
      this.minX = Infinity;
      this.minY = Infinity;
      this.maxX = -Infinity;
      this.maxY = -Infinity;
    }
    getRectangle(rect) {
      if (this.minX > this.maxX || this.minY > this.maxY) {
        return Rectangle.EMPTY;
      }
      rect = rect || new Rectangle(0, 0, 1, 1);
      rect.x = this.minX;
      rect.y = this.minY;
      rect.width = this.maxX - this.minX;
      rect.height = this.maxY - this.minY;
      return rect;
    }
    addPoint(point) {
      this.minX = Math.min(this.minX, point.x);
      this.maxX = Math.max(this.maxX, point.x);
      this.minY = Math.min(this.minY, point.y);
      this.maxY = Math.max(this.maxY, point.y);
    }
    addPointMatrix(matrix, point) {
      const { a: a2, b, c: c2, d, tx, ty } = matrix;
      const x3 = a2 * point.x + c2 * point.y + tx;
      const y3 = b * point.x + d * point.y + ty;
      this.minX = Math.min(this.minX, x3);
      this.maxX = Math.max(this.maxX, x3);
      this.minY = Math.min(this.minY, y3);
      this.maxY = Math.max(this.maxY, y3);
    }
    addQuad(vertices) {
      let minX = this.minX;
      let minY = this.minY;
      let maxX = this.maxX;
      let maxY = this.maxY;
      let x3 = vertices[0];
      let y3 = vertices[1];
      minX = x3 < minX ? x3 : minX;
      minY = y3 < minY ? y3 : minY;
      maxX = x3 > maxX ? x3 : maxX;
      maxY = y3 > maxY ? y3 : maxY;
      x3 = vertices[2];
      y3 = vertices[3];
      minX = x3 < minX ? x3 : minX;
      minY = y3 < minY ? y3 : minY;
      maxX = x3 > maxX ? x3 : maxX;
      maxY = y3 > maxY ? y3 : maxY;
      x3 = vertices[4];
      y3 = vertices[5];
      minX = x3 < minX ? x3 : minX;
      minY = y3 < minY ? y3 : minY;
      maxX = x3 > maxX ? x3 : maxX;
      maxY = y3 > maxY ? y3 : maxY;
      x3 = vertices[6];
      y3 = vertices[7];
      minX = x3 < minX ? x3 : minX;
      minY = y3 < minY ? y3 : minY;
      maxX = x3 > maxX ? x3 : maxX;
      maxY = y3 > maxY ? y3 : maxY;
      this.minX = minX;
      this.minY = minY;
      this.maxX = maxX;
      this.maxY = maxY;
    }
    addFrame(transform2, x0, y0, x1, y1) {
      this.addFrameMatrix(transform2.worldTransform, x0, y0, x1, y1);
    }
    addFrameMatrix(matrix, x0, y0, x1, y1) {
      const a2 = matrix.a;
      const b = matrix.b;
      const c2 = matrix.c;
      const d = matrix.d;
      const tx = matrix.tx;
      const ty = matrix.ty;
      let minX = this.minX;
      let minY = this.minY;
      let maxX = this.maxX;
      let maxY = this.maxY;
      let x3 = a2 * x0 + c2 * y0 + tx;
      let y3 = b * x0 + d * y0 + ty;
      minX = x3 < minX ? x3 : minX;
      minY = y3 < minY ? y3 : minY;
      maxX = x3 > maxX ? x3 : maxX;
      maxY = y3 > maxY ? y3 : maxY;
      x3 = a2 * x1 + c2 * y0 + tx;
      y3 = b * x1 + d * y0 + ty;
      minX = x3 < minX ? x3 : minX;
      minY = y3 < minY ? y3 : minY;
      maxX = x3 > maxX ? x3 : maxX;
      maxY = y3 > maxY ? y3 : maxY;
      x3 = a2 * x0 + c2 * y1 + tx;
      y3 = b * x0 + d * y1 + ty;
      minX = x3 < minX ? x3 : minX;
      minY = y3 < minY ? y3 : minY;
      maxX = x3 > maxX ? x3 : maxX;
      maxY = y3 > maxY ? y3 : maxY;
      x3 = a2 * x1 + c2 * y1 + tx;
      y3 = b * x1 + d * y1 + ty;
      minX = x3 < minX ? x3 : minX;
      minY = y3 < minY ? y3 : minY;
      maxX = x3 > maxX ? x3 : maxX;
      maxY = y3 > maxY ? y3 : maxY;
      this.minX = minX;
      this.minY = minY;
      this.maxX = maxX;
      this.maxY = maxY;
    }
    addVertexData(vertexData, beginOffset, endOffset) {
      let minX = this.minX;
      let minY = this.minY;
      let maxX = this.maxX;
      let maxY = this.maxY;
      for (let i = beginOffset; i < endOffset; i += 2) {
        const x3 = vertexData[i];
        const y3 = vertexData[i + 1];
        minX = x3 < minX ? x3 : minX;
        minY = y3 < minY ? y3 : minY;
        maxX = x3 > maxX ? x3 : maxX;
        maxY = y3 > maxY ? y3 : maxY;
      }
      this.minX = minX;
      this.minY = minY;
      this.maxX = maxX;
      this.maxY = maxY;
    }
    addVertices(transform2, vertices, beginOffset, endOffset) {
      this.addVerticesMatrix(transform2.worldTransform, vertices, beginOffset, endOffset);
    }
    addVerticesMatrix(matrix, vertices, beginOffset, endOffset, padX = 0, padY = padX) {
      const a2 = matrix.a;
      const b = matrix.b;
      const c2 = matrix.c;
      const d = matrix.d;
      const tx = matrix.tx;
      const ty = matrix.ty;
      let minX = this.minX;
      let minY = this.minY;
      let maxX = this.maxX;
      let maxY = this.maxY;
      for (let i = beginOffset; i < endOffset; i += 2) {
        const rawX = vertices[i];
        const rawY = vertices[i + 1];
        const x3 = a2 * rawX + c2 * rawY + tx;
        const y3 = d * rawY + b * rawX + ty;
        minX = Math.min(minX, x3 - padX);
        maxX = Math.max(maxX, x3 + padX);
        minY = Math.min(minY, y3 - padY);
        maxY = Math.max(maxY, y3 + padY);
      }
      this.minX = minX;
      this.minY = minY;
      this.maxX = maxX;
      this.maxY = maxY;
    }
    addBounds(bounds) {
      const minX = this.minX;
      const minY = this.minY;
      const maxX = this.maxX;
      const maxY = this.maxY;
      this.minX = bounds.minX < minX ? bounds.minX : minX;
      this.minY = bounds.minY < minY ? bounds.minY : minY;
      this.maxX = bounds.maxX > maxX ? bounds.maxX : maxX;
      this.maxY = bounds.maxY > maxY ? bounds.maxY : maxY;
    }
    addBoundsMask(bounds, mask) {
      const _minX = bounds.minX > mask.minX ? bounds.minX : mask.minX;
      const _minY = bounds.minY > mask.minY ? bounds.minY : mask.minY;
      const _maxX = bounds.maxX < mask.maxX ? bounds.maxX : mask.maxX;
      const _maxY = bounds.maxY < mask.maxY ? bounds.maxY : mask.maxY;
      if (_minX <= _maxX && _minY <= _maxY) {
        const minX = this.minX;
        const minY = this.minY;
        const maxX = this.maxX;
        const maxY = this.maxY;
        this.minX = _minX < minX ? _minX : minX;
        this.minY = _minY < minY ? _minY : minY;
        this.maxX = _maxX > maxX ? _maxX : maxX;
        this.maxY = _maxY > maxY ? _maxY : maxY;
      }
    }
    addBoundsMatrix(bounds, matrix) {
      this.addFrameMatrix(matrix, bounds.minX, bounds.minY, bounds.maxX, bounds.maxY);
    }
    addBoundsArea(bounds, area) {
      const _minX = bounds.minX > area.x ? bounds.minX : area.x;
      const _minY = bounds.minY > area.y ? bounds.minY : area.y;
      const _maxX = bounds.maxX < area.x + area.width ? bounds.maxX : area.x + area.width;
      const _maxY = bounds.maxY < area.y + area.height ? bounds.maxY : area.y + area.height;
      if (_minX <= _maxX && _minY <= _maxY) {
        const minX = this.minX;
        const minY = this.minY;
        const maxX = this.maxX;
        const maxY = this.maxY;
        this.minX = _minX < minX ? _minX : minX;
        this.minY = _minY < minY ? _minY : minY;
        this.maxX = _maxX > maxX ? _maxX : maxX;
        this.maxY = _maxY > maxY ? _maxY : maxY;
      }
    }
    pad(paddingX = 0, paddingY = paddingX) {
      if (!this.isEmpty()) {
        this.minX -= paddingX;
        this.maxX += paddingX;
        this.minY -= paddingY;
        this.maxY += paddingY;
      }
    }
    addFramePad(x0, y0, x1, y1, padX, padY) {
      x0 -= padX;
      y0 -= padY;
      x1 += padX;
      y1 += padY;
      this.minX = this.minX < x0 ? this.minX : x0;
      this.maxX = this.maxX > x1 ? this.maxX : x1;
      this.minY = this.minY < y0 ? this.minY : y0;
      this.maxY = this.maxY > y1 ? this.maxY : y1;
    }
  };

  // node_modules/pixijs/display/DisplayObject.mjs
  var DisplayObject = class extends utils_exports.EventEmitter {
    constructor() {
      super();
      this.tempDisplayObjectParent = null;
      this.transform = new Transform2();
      this.alpha = 1;
      this.visible = true;
      this.renderable = true;
      this.cullable = false;
      this.cullArea = null;
      this.parent = null;
      this.worldAlpha = 1;
      this._lastSortedIndex = 0;
      this._zIndex = 0;
      this.filterArea = null;
      this.filters = null;
      this._enabledFilters = null;
      this._bounds = new Bounds();
      this._localBounds = null;
      this._boundsID = 0;
      this._boundsRect = null;
      this._localBoundsRect = null;
      this._mask = null;
      this._maskRefCount = 0;
      this._destroyed = false;
      this.isSprite = false;
      this.isMask = false;
    }
    static mixin(source) {
      const keys = Object.keys(source);
      for (let i = 0; i < keys.length; ++i) {
        const propertyName = keys[i];
        Object.defineProperty(DisplayObject.prototype, propertyName, Object.getOwnPropertyDescriptor(source, propertyName));
      }
    }
    get destroyed() {
      return this._destroyed;
    }
    _recursivePostUpdateTransform() {
      if (this.parent) {
        this.parent._recursivePostUpdateTransform();
        this.transform.updateTransform(this.parent.transform);
      } else {
        this.transform.updateTransform(this._tempDisplayObjectParent.transform);
      }
    }
    updateTransform() {
      this._boundsID++;
      this.transform.updateTransform(this.parent.transform);
      this.worldAlpha = this.alpha * this.parent.worldAlpha;
    }
    getBounds(skipUpdate, rect) {
      if (!skipUpdate) {
        if (!this.parent) {
          this.parent = this._tempDisplayObjectParent;
          this.updateTransform();
          this.parent = null;
        } else {
          this._recursivePostUpdateTransform();
          this.updateTransform();
        }
      }
      if (this._bounds.updateID !== this._boundsID) {
        this.calculateBounds();
        this._bounds.updateID = this._boundsID;
      }
      if (!rect) {
        if (!this._boundsRect) {
          this._boundsRect = new Rectangle();
        }
        rect = this._boundsRect;
      }
      return this._bounds.getRectangle(rect);
    }
    getLocalBounds(rect) {
      if (!rect) {
        if (!this._localBoundsRect) {
          this._localBoundsRect = new Rectangle();
        }
        rect = this._localBoundsRect;
      }
      if (!this._localBounds) {
        this._localBounds = new Bounds();
      }
      const transformRef = this.transform;
      const parentRef = this.parent;
      this.parent = null;
      this.transform = this._tempDisplayObjectParent.transform;
      const worldBounds = this._bounds;
      const worldBoundsID = this._boundsID;
      this._bounds = this._localBounds;
      const bounds = this.getBounds(false, rect);
      this.parent = parentRef;
      this.transform = transformRef;
      this._bounds = worldBounds;
      this._bounds.updateID += this._boundsID - worldBoundsID;
      return bounds;
    }
    toGlobal(position, point, skipUpdate = false) {
      if (!skipUpdate) {
        this._recursivePostUpdateTransform();
        if (!this.parent) {
          this.parent = this._tempDisplayObjectParent;
          this.displayObjectUpdateTransform();
          this.parent = null;
        } else {
          this.displayObjectUpdateTransform();
        }
      }
      return this.worldTransform.apply(position, point);
    }
    toLocal(position, from, point, skipUpdate) {
      if (from) {
        position = from.toGlobal(position, point, skipUpdate);
      }
      if (!skipUpdate) {
        this._recursivePostUpdateTransform();
        if (!this.parent) {
          this.parent = this._tempDisplayObjectParent;
          this.displayObjectUpdateTransform();
          this.parent = null;
        } else {
          this.displayObjectUpdateTransform();
        }
      }
      return this.worldTransform.applyInverse(position, point);
    }
    setParent(container) {
      if (!container || !container.addChild) {
        throw new Error("setParent: Argument must be a Container");
      }
      container.addChild(this);
      return container;
    }
    removeFromParent() {
      var _a;
      (_a = this.parent) == null ? void 0 : _a.removeChild(this);
    }
    setTransform(x3 = 0, y3 = 0, scaleX = 1, scaleY = 1, rotation = 0, skewX = 0, skewY = 0, pivotX = 0, pivotY = 0) {
      this.position.x = x3;
      this.position.y = y3;
      this.scale.x = !scaleX ? 1 : scaleX;
      this.scale.y = !scaleY ? 1 : scaleY;
      this.rotation = rotation;
      this.skew.x = skewX;
      this.skew.y = skewY;
      this.pivot.x = pivotX;
      this.pivot.y = pivotY;
      return this;
    }
    destroy(_options) {
      this.removeFromParent();
      this._destroyed = true;
      this.transform = null;
      this.parent = null;
      this._bounds = null;
      this.mask = null;
      this.cullArea = null;
      this.filters = null;
      this.filterArea = null;
      this.hitArea = null;
      this.interactive = false;
      this.interactiveChildren = false;
      this.emit("destroyed");
      this.removeAllListeners();
    }
    get _tempDisplayObjectParent() {
      if (this.tempDisplayObjectParent === null) {
        this.tempDisplayObjectParent = new TemporaryDisplayObject();
      }
      return this.tempDisplayObjectParent;
    }
    enableTempParent() {
      const myParent = this.parent;
      this.parent = this._tempDisplayObjectParent;
      return myParent;
    }
    disableTempParent(cacheParent) {
      this.parent = cacheParent;
    }
    get x() {
      return this.position.x;
    }
    set x(value) {
      this.transform.position.x = value;
    }
    get y() {
      return this.position.y;
    }
    set y(value) {
      this.transform.position.y = value;
    }
    get worldTransform() {
      return this.transform.worldTransform;
    }
    get localTransform() {
      return this.transform.localTransform;
    }
    get position() {
      return this.transform.position;
    }
    set position(value) {
      this.transform.position.copyFrom(value);
    }
    get scale() {
      return this.transform.scale;
    }
    set scale(value) {
      this.transform.scale.copyFrom(value);
    }
    get pivot() {
      return this.transform.pivot;
    }
    set pivot(value) {
      this.transform.pivot.copyFrom(value);
    }
    get skew() {
      return this.transform.skew;
    }
    set skew(value) {
      this.transform.skew.copyFrom(value);
    }
    get rotation() {
      return this.transform.rotation;
    }
    set rotation(value) {
      this.transform.rotation = value;
    }
    get angle() {
      return this.transform.rotation * RAD_TO_DEG;
    }
    set angle(value) {
      this.transform.rotation = value * DEG_TO_RAD;
    }
    get zIndex() {
      return this._zIndex;
    }
    set zIndex(value) {
      this._zIndex = value;
      if (this.parent) {
        this.parent.sortDirty = true;
      }
    }
    get worldVisible() {
      let item = this;
      do {
        if (!item.visible) {
          return false;
        }
        item = item.parent;
      } while (item);
      return true;
    }
    get mask() {
      return this._mask;
    }
    set mask(value) {
      if (this._mask === value) {
        return;
      }
      if (this._mask) {
        const maskObject = this._mask.isMaskData ? this._mask.maskObject : this._mask;
        if (maskObject) {
          maskObject._maskRefCount--;
          if (maskObject._maskRefCount === 0) {
            maskObject.renderable = true;
            maskObject.isMask = false;
          }
        }
      }
      this._mask = value;
      if (this._mask) {
        const maskObject = this._mask.isMaskData ? this._mask.maskObject : this._mask;
        if (maskObject) {
          if (maskObject._maskRefCount === 0) {
            maskObject.renderable = false;
            maskObject.isMask = true;
          }
          maskObject._maskRefCount++;
        }
      }
    }
  };
  var TemporaryDisplayObject = class extends DisplayObject {
    constructor() {
      super(...arguments);
      this.sortDirty = null;
    }
  };
  DisplayObject.prototype.displayObjectUpdateTransform = DisplayObject.prototype.updateTransform;

  // node_modules/pixijs/display/Container.mjs
  var tempMatrix3 = new Matrix();
  function sortChildren(a2, b) {
    if (a2.zIndex === b.zIndex) {
      return a2._lastSortedIndex - b._lastSortedIndex;
    }
    return a2.zIndex - b.zIndex;
  }
  var _Container = class extends DisplayObject {
    constructor() {
      super();
      this.children = [];
      this.sortableChildren = _Container.defaultSortableChildren;
      this.sortDirty = false;
    }
    onChildrenChange(_length) {
    }
    addChild(...children2) {
      if (children2.length > 1) {
        for (let i = 0; i < children2.length; i++) {
          this.addChild(children2[i]);
        }
      } else {
        const child = children2[0];
        if (child.parent) {
          child.parent.removeChild(child);
        }
        child.parent = this;
        this.sortDirty = true;
        child.transform._parentID = -1;
        this.children.push(child);
        this._boundsID++;
        this.onChildrenChange(this.children.length - 1);
        this.emit("childAdded", child, this, this.children.length - 1);
        child.emit("added", this);
      }
      return children2[0];
    }
    addChildAt(child, index2) {
      if (index2 < 0 || index2 > this.children.length) {
        throw new Error(`${child}addChildAt: The index ${index2} supplied is out of bounds ${this.children.length}`);
      }
      if (child.parent) {
        child.parent.removeChild(child);
      }
      child.parent = this;
      this.sortDirty = true;
      child.transform._parentID = -1;
      this.children.splice(index2, 0, child);
      this._boundsID++;
      this.onChildrenChange(index2);
      child.emit("added", this);
      this.emit("childAdded", child, this, index2);
      return child;
    }
    swapChildren(child, child2) {
      if (child === child2) {
        return;
      }
      const index1 = this.getChildIndex(child);
      const index2 = this.getChildIndex(child2);
      this.children[index1] = child2;
      this.children[index2] = child;
      this.onChildrenChange(index1 < index2 ? index1 : index2);
    }
    getChildIndex(child) {
      const index2 = this.children.indexOf(child);
      if (index2 === -1) {
        throw new Error("The supplied DisplayObject must be a child of the caller");
      }
      return index2;
    }
    setChildIndex(child, index2) {
      if (index2 < 0 || index2 >= this.children.length) {
        throw new Error(`The index ${index2} supplied is out of bounds ${this.children.length}`);
      }
      const currentIndex = this.getChildIndex(child);
      utils_exports.removeItems(this.children, currentIndex, 1);
      this.children.splice(index2, 0, child);
      this.onChildrenChange(index2);
    }
    getChildAt(index2) {
      if (index2 < 0 || index2 >= this.children.length) {
        throw new Error(`getChildAt: Index (${index2}) does not exist.`);
      }
      return this.children[index2];
    }
    removeChild(...children2) {
      if (children2.length > 1) {
        for (let i = 0; i < children2.length; i++) {
          this.removeChild(children2[i]);
        }
      } else {
        const child = children2[0];
        const index2 = this.children.indexOf(child);
        if (index2 === -1)
          return null;
        child.parent = null;
        child.transform._parentID = -1;
        utils_exports.removeItems(this.children, index2, 1);
        this._boundsID++;
        this.onChildrenChange(index2);
        child.emit("removed", this);
        this.emit("childRemoved", child, this, index2);
      }
      return children2[0];
    }
    removeChildAt(index2) {
      const child = this.getChildAt(index2);
      child.parent = null;
      child.transform._parentID = -1;
      utils_exports.removeItems(this.children, index2, 1);
      this._boundsID++;
      this.onChildrenChange(index2);
      child.emit("removed", this);
      this.emit("childRemoved", child, this, index2);
      return child;
    }
    removeChildren(beginIndex = 0, endIndex = this.children.length) {
      const begin = beginIndex;
      const end = endIndex;
      const range = end - begin;
      let removed;
      if (range > 0 && range <= end) {
        removed = this.children.splice(begin, range);
        for (let i = 0; i < removed.length; ++i) {
          removed[i].parent = null;
          if (removed[i].transform) {
            removed[i].transform._parentID = -1;
          }
        }
        this._boundsID++;
        this.onChildrenChange(beginIndex);
        for (let i = 0; i < removed.length; ++i) {
          removed[i].emit("removed", this);
          this.emit("childRemoved", removed[i], this, i);
        }
        return removed;
      } else if (range === 0 && this.children.length === 0) {
        return [];
      }
      throw new RangeError("removeChildren: numeric values are outside the acceptable range.");
    }
    sortChildren() {
      let sortRequired = false;
      for (let i = 0, j = this.children.length; i < j; ++i) {
        const child = this.children[i];
        child._lastSortedIndex = i;
        if (!sortRequired && child.zIndex !== 0) {
          sortRequired = true;
        }
      }
      if (sortRequired && this.children.length > 1) {
        this.children.sort(sortChildren);
      }
      this.sortDirty = false;
    }
    updateTransform() {
      if (this.sortableChildren && this.sortDirty) {
        this.sortChildren();
      }
      this._boundsID++;
      this.transform.updateTransform(this.parent.transform);
      this.worldAlpha = this.alpha * this.parent.worldAlpha;
      for (let i = 0, j = this.children.length; i < j; ++i) {
        const child = this.children[i];
        if (child.visible) {
          child.updateTransform();
        }
      }
    }
    calculateBounds() {
      this._bounds.clear();
      this._calculateBounds();
      for (let i = 0; i < this.children.length; i++) {
        const child = this.children[i];
        if (!child.visible || !child.renderable) {
          continue;
        }
        child.calculateBounds();
        if (child._mask) {
          const maskObject = child._mask.isMaskData ? child._mask.maskObject : child._mask;
          if (maskObject) {
            maskObject.calculateBounds();
            this._bounds.addBoundsMask(child._bounds, maskObject._bounds);
          } else {
            this._bounds.addBounds(child._bounds);
          }
        } else if (child.filterArea) {
          this._bounds.addBoundsArea(child._bounds, child.filterArea);
        } else {
          this._bounds.addBounds(child._bounds);
        }
      }
      this._bounds.updateID = this._boundsID;
    }
    getLocalBounds(rect, skipChildrenUpdate = false) {
      const result = super.getLocalBounds(rect);
      if (!skipChildrenUpdate) {
        for (let i = 0, j = this.children.length; i < j; ++i) {
          const child = this.children[i];
          if (child.visible) {
            child.updateTransform();
          }
        }
      }
      return result;
    }
    _calculateBounds() {
    }
    _renderWithCulling(renderer) {
      const sourceFrame = renderer.renderTexture.sourceFrame;
      if (!(sourceFrame.width > 0 && sourceFrame.height > 0)) {
        return;
      }
      let bounds;
      let transform2;
      if (this.cullArea) {
        bounds = this.cullArea;
        transform2 = this.worldTransform;
      } else if (this._render !== _Container.prototype._render) {
        bounds = this.getBounds(true);
      }
      const projectionTransform = renderer.projection.transform;
      if (projectionTransform) {
        if (transform2) {
          transform2 = tempMatrix3.copyFrom(transform2);
          transform2.prepend(projectionTransform);
        } else {
          transform2 = projectionTransform;
        }
      }
      if (bounds && sourceFrame.intersects(bounds, transform2)) {
        this._render(renderer);
      } else if (this.cullArea) {
        return;
      }
      for (let i = 0, j = this.children.length; i < j; ++i) {
        const child = this.children[i];
        const childCullable = child.cullable;
        child.cullable = childCullable || !this.cullArea;
        child.render(renderer);
        child.cullable = childCullable;
      }
    }
    render(renderer) {
      var _a;
      if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {
        return;
      }
      if (this._mask || ((_a = this.filters) == null ? void 0 : _a.length)) {
        this.renderAdvanced(renderer);
      } else if (this.cullable) {
        this._renderWithCulling(renderer);
      } else {
        this._render(renderer);
        for (let i = 0, j = this.children.length; i < j; ++i) {
          this.children[i].render(renderer);
        }
      }
    }
    renderAdvanced(renderer) {
      var _a, _b, _c;
      const filters2 = this.filters;
      const mask = this._mask;
      if (filters2) {
        if (!this._enabledFilters) {
          this._enabledFilters = [];
        }
        this._enabledFilters.length = 0;
        for (let i = 0; i < filters2.length; i++) {
          if (filters2[i].enabled) {
            this._enabledFilters.push(filters2[i]);
          }
        }
      }
      const flush = filters2 && ((_a = this._enabledFilters) == null ? void 0 : _a.length) || mask && (!mask.isMaskData || mask.enabled && (mask.autoDetect || mask.type !== MASK_TYPES.NONE));
      if (flush) {
        renderer.batch.flush();
      }
      if (filters2 && ((_b = this._enabledFilters) == null ? void 0 : _b.length)) {
        renderer.filter.push(this, this._enabledFilters);
      }
      if (mask) {
        renderer.mask.push(this, this._mask);
      }
      if (this.cullable) {
        this._renderWithCulling(renderer);
      } else {
        this._render(renderer);
        for (let i = 0, j = this.children.length; i < j; ++i) {
          this.children[i].render(renderer);
        }
      }
      if (flush) {
        renderer.batch.flush();
      }
      if (mask) {
        renderer.mask.pop(this);
      }
      if (filters2 && ((_c = this._enabledFilters) == null ? void 0 : _c.length)) {
        renderer.filter.pop();
      }
    }
    _render(_renderer) {
    }
    destroy(options) {
      super.destroy();
      this.sortDirty = false;
      const destroyChildren = typeof options === "boolean" ? options : options == null ? void 0 : options.children;
      const oldChildren = this.removeChildren(0, this.children.length);
      if (destroyChildren) {
        for (let i = 0; i < oldChildren.length; ++i) {
          oldChildren[i].destroy(options);
        }
      }
    }
    get width() {
      return this.scale.x * this.getLocalBounds().width;
    }
    set width(value) {
      const width = this.getLocalBounds().width;
      if (width !== 0) {
        this.scale.x = value / width;
      } else {
        this.scale.x = 1;
      }
      this._width = value;
    }
    get height() {
      return this.scale.y * this.getLocalBounds().height;
    }
    set height(value) {
      const height = this.getLocalBounds().height;
      if (height !== 0) {
        this.scale.y = value / height;
      } else {
        this.scale.y = 1;
      }
      this._height = value;
    }
  };
  var Container = _Container;
  Container.defaultSortableChildren = false;
  Container.prototype.containerUpdateTransform = Container.prototype.updateTransform;

  // node_modules/pixijs/display/settings.mjs
  Object.defineProperties(settings, {
    SORTABLE_CHILDREN: {
      get() {
        return Container.defaultSortableChildren;
      },
      set(value) {
        utils_exports.deprecation("7.1.0", "settings.SORTABLE_CHILDREN is deprecated, use Container.defaultSortableChildren");
        Container.defaultSortableChildren = value;
      }
    }
  });

  // node_modules/pixijs/sprite/Sprite.mjs
  var tempPoint = new Point();
  var indices = new Uint16Array([0, 1, 2, 0, 2, 3]);
  var Sprite = class extends Container {
    constructor(texture) {
      super();
      this._anchor = new ObservablePoint(this._onAnchorUpdate, this, texture ? texture.defaultAnchor.x : 0, texture ? texture.defaultAnchor.y : 0);
      this._texture = null;
      this._width = 0;
      this._height = 0;
      this._tint = null;
      this._tintRGB = null;
      this.tint = 16777215;
      this.blendMode = BLEND_MODES.NORMAL;
      this._cachedTint = 16777215;
      this.uvs = null;
      this.texture = texture || Texture.EMPTY;
      this.vertexData = new Float32Array(8);
      this.vertexTrimmedData = null;
      this._transformID = -1;
      this._textureID = -1;
      this._transformTrimmedID = -1;
      this._textureTrimmedID = -1;
      this.indices = indices;
      this.pluginName = "batch";
      this.isSprite = true;
      this._roundPixels = settings.ROUND_PIXELS;
    }
    _onTextureUpdate() {
      this._textureID = -1;
      this._textureTrimmedID = -1;
      this._cachedTint = 16777215;
      if (this._width) {
        this.scale.x = utils_exports.sign(this.scale.x) * this._width / this._texture.orig.width;
      }
      if (this._height) {
        this.scale.y = utils_exports.sign(this.scale.y) * this._height / this._texture.orig.height;
      }
    }
    _onAnchorUpdate() {
      this._transformID = -1;
      this._transformTrimmedID = -1;
    }
    calculateVertices() {
      const texture = this._texture;
      if (this._transformID === this.transform._worldID && this._textureID === texture._updateID) {
        return;
      }
      if (this._textureID !== texture._updateID) {
        this.uvs = this._texture._uvs.uvsFloat32;
      }
      this._transformID = this.transform._worldID;
      this._textureID = texture._updateID;
      const wt = this.transform.worldTransform;
      const a2 = wt.a;
      const b = wt.b;
      const c2 = wt.c;
      const d = wt.d;
      const tx = wt.tx;
      const ty = wt.ty;
      const vertexData = this.vertexData;
      const trim = texture.trim;
      const orig = texture.orig;
      const anchor = this._anchor;
      let w0 = 0;
      let w1 = 0;
      let h0 = 0;
      let h1 = 0;
      if (trim) {
        w1 = trim.x - anchor._x * orig.width;
        w0 = w1 + trim.width;
        h1 = trim.y - anchor._y * orig.height;
        h0 = h1 + trim.height;
      } else {
        w1 = -anchor._x * orig.width;
        w0 = w1 + orig.width;
        h1 = -anchor._y * orig.height;
        h0 = h1 + orig.height;
      }
      vertexData[0] = a2 * w1 + c2 * h1 + tx;
      vertexData[1] = d * h1 + b * w1 + ty;
      vertexData[2] = a2 * w0 + c2 * h1 + tx;
      vertexData[3] = d * h1 + b * w0 + ty;
      vertexData[4] = a2 * w0 + c2 * h0 + tx;
      vertexData[5] = d * h0 + b * w0 + ty;
      vertexData[6] = a2 * w1 + c2 * h0 + tx;
      vertexData[7] = d * h0 + b * w1 + ty;
      if (this._roundPixels) {
        const resolution = settings.RESOLUTION;
        for (let i = 0; i < vertexData.length; ++i) {
          vertexData[i] = Math.round(vertexData[i] * resolution) / resolution;
        }
      }
    }
    calculateTrimmedVertices() {
      if (!this.vertexTrimmedData) {
        this.vertexTrimmedData = new Float32Array(8);
      } else if (this._transformTrimmedID === this.transform._worldID && this._textureTrimmedID === this._texture._updateID) {
        return;
      }
      this._transformTrimmedID = this.transform._worldID;
      this._textureTrimmedID = this._texture._updateID;
      const texture = this._texture;
      const vertexData = this.vertexTrimmedData;
      const orig = texture.orig;
      const anchor = this._anchor;
      const wt = this.transform.worldTransform;
      const a2 = wt.a;
      const b = wt.b;
      const c2 = wt.c;
      const d = wt.d;
      const tx = wt.tx;
      const ty = wt.ty;
      const w1 = -anchor._x * orig.width;
      const w0 = w1 + orig.width;
      const h1 = -anchor._y * orig.height;
      const h0 = h1 + orig.height;
      vertexData[0] = a2 * w1 + c2 * h1 + tx;
      vertexData[1] = d * h1 + b * w1 + ty;
      vertexData[2] = a2 * w0 + c2 * h1 + tx;
      vertexData[3] = d * h1 + b * w0 + ty;
      vertexData[4] = a2 * w0 + c2 * h0 + tx;
      vertexData[5] = d * h0 + b * w0 + ty;
      vertexData[6] = a2 * w1 + c2 * h0 + tx;
      vertexData[7] = d * h0 + b * w1 + ty;
    }
    _render(renderer) {
      this.calculateVertices();
      renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);
      renderer.plugins[this.pluginName].render(this);
    }
    _calculateBounds() {
      const trim = this._texture.trim;
      const orig = this._texture.orig;
      if (!trim || trim.width === orig.width && trim.height === orig.height) {
        this.calculateVertices();
        this._bounds.addQuad(this.vertexData);
      } else {
        this.calculateTrimmedVertices();
        this._bounds.addQuad(this.vertexTrimmedData);
      }
    }
    getLocalBounds(rect) {
      if (this.children.length === 0) {
        if (!this._localBounds) {
          this._localBounds = new Bounds();
        }
        this._localBounds.minX = this._texture.orig.width * -this._anchor._x;
        this._localBounds.minY = this._texture.orig.height * -this._anchor._y;
        this._localBounds.maxX = this._texture.orig.width * (1 - this._anchor._x);
        this._localBounds.maxY = this._texture.orig.height * (1 - this._anchor._y);
        if (!rect) {
          if (!this._localBoundsRect) {
            this._localBoundsRect = new Rectangle();
          }
          rect = this._localBoundsRect;
        }
        return this._localBounds.getRectangle(rect);
      }
      return super.getLocalBounds.call(this, rect);
    }
    containsPoint(point) {
      this.worldTransform.applyInverse(point, tempPoint);
      const width = this._texture.orig.width;
      const height = this._texture.orig.height;
      const x1 = -width * this.anchor.x;
      let y1 = 0;
      if (tempPoint.x >= x1 && tempPoint.x < x1 + width) {
        y1 = -height * this.anchor.y;
        if (tempPoint.y >= y1 && tempPoint.y < y1 + height) {
          return true;
        }
      }
      return false;
    }
    destroy(options) {
      super.destroy(options);
      this._texture.off("update", this._onTextureUpdate, this);
      this._anchor = null;
      const destroyTexture = typeof options === "boolean" ? options : options == null ? void 0 : options.texture;
      if (destroyTexture) {
        const destroyBaseTexture = typeof options === "boolean" ? options : options == null ? void 0 : options.baseTexture;
        this._texture.destroy(!!destroyBaseTexture);
      }
      this._texture = null;
    }
    static from(source, options) {
      const texture = source instanceof Texture ? source : Texture.from(source, options);
      return new Sprite(texture);
    }
    set roundPixels(value) {
      if (this._roundPixels !== value) {
        this._transformID = -1;
      }
      this._roundPixels = value;
    }
    get roundPixels() {
      return this._roundPixels;
    }
    get width() {
      return Math.abs(this.scale.x) * this._texture.orig.width;
    }
    set width(value) {
      const s = utils_exports.sign(this.scale.x) || 1;
      this.scale.x = s * value / this._texture.orig.width;
      this._width = value;
    }
    get height() {
      return Math.abs(this.scale.y) * this._texture.orig.height;
    }
    set height(value) {
      const s = utils_exports.sign(this.scale.y) || 1;
      this.scale.y = s * value / this._texture.orig.height;
      this._height = value;
    }
    get anchor() {
      return this._anchor;
    }
    set anchor(value) {
      this._anchor.copyFrom(value);
    }
    get tint() {
      return this._tint;
    }
    set tint(value) {
      this._tint = value;
      this._tintRGB = (value >> 16) + (value & 65280) + ((value & 255) << 16);
    }
    get texture() {
      return this._texture;
    }
    set texture(value) {
      if (this._texture === value) {
        return;
      }
      if (this._texture) {
        this._texture.off("update", this._onTextureUpdate, this);
      }
      this._texture = value || Texture.EMPTY;
      this._cachedTint = 16777215;
      this._textureID = -1;
      this._textureTrimmedID = -1;
      if (value) {
        if (value.baseTexture.valid) {
          this._onTextureUpdate();
        } else {
          value.once("update", this._onTextureUpdate, this);
        }
      }
    }
  };

  // node_modules/pixijs/display-cache-as-bitmap/index.mjs
  var _tempMatrix = new Matrix();
  DisplayObject.prototype._cacheAsBitmap = false;
  DisplayObject.prototype._cacheData = null;
  DisplayObject.prototype._cacheAsBitmapResolution = null;
  DisplayObject.prototype._cacheAsBitmapMultisample = null;
  var CacheData = class {
    constructor() {
      this.textureCacheId = null;
      this.originalRender = null;
      this.originalRenderCanvas = null;
      this.originalCalculateBounds = null;
      this.originalGetLocalBounds = null;
      this.originalUpdateTransform = null;
      this.originalDestroy = null;
      this.originalMask = null;
      this.originalFilterArea = null;
      this.originalContainsPoint = null;
      this.sprite = null;
    }
  };
  Object.defineProperties(DisplayObject.prototype, {
    cacheAsBitmapResolution: {
      get() {
        return this._cacheAsBitmapResolution;
      },
      set(resolution) {
        if (resolution === this._cacheAsBitmapResolution) {
          return;
        }
        this._cacheAsBitmapResolution = resolution;
        if (this.cacheAsBitmap) {
          this.cacheAsBitmap = false;
          this.cacheAsBitmap = true;
        }
      }
    },
    cacheAsBitmapMultisample: {
      get() {
        return this._cacheAsBitmapMultisample;
      },
      set(multisample) {
        if (multisample === this._cacheAsBitmapMultisample) {
          return;
        }
        this._cacheAsBitmapMultisample = multisample;
        if (this.cacheAsBitmap) {
          this.cacheAsBitmap = false;
          this.cacheAsBitmap = true;
        }
      }
    },
    cacheAsBitmap: {
      get() {
        return this._cacheAsBitmap;
      },
      set(value) {
        if (this._cacheAsBitmap === value) {
          return;
        }
        this._cacheAsBitmap = value;
        let data;
        if (value) {
          if (!this._cacheData) {
            this._cacheData = new CacheData();
          }
          data = this._cacheData;
          data.originalRender = this.render;
          data.originalRenderCanvas = this.renderCanvas;
          data.originalUpdateTransform = this.updateTransform;
          data.originalCalculateBounds = this.calculateBounds;
          data.originalGetLocalBounds = this.getLocalBounds;
          data.originalDestroy = this.destroy;
          data.originalContainsPoint = this.containsPoint;
          data.originalMask = this._mask;
          data.originalFilterArea = this.filterArea;
          this.render = this._renderCached;
          this.renderCanvas = this._renderCachedCanvas;
          this.destroy = this._cacheAsBitmapDestroy;
        } else {
          data = this._cacheData;
          if (data.sprite) {
            this._destroyCachedDisplayObject();
          }
          this.render = data.originalRender;
          this.renderCanvas = data.originalRenderCanvas;
          this.calculateBounds = data.originalCalculateBounds;
          this.getLocalBounds = data.originalGetLocalBounds;
          this.destroy = data.originalDestroy;
          this.updateTransform = data.originalUpdateTransform;
          this.containsPoint = data.originalContainsPoint;
          this._mask = data.originalMask;
          this.filterArea = data.originalFilterArea;
        }
      }
    }
  });
  DisplayObject.prototype._renderCached = function _renderCached(renderer) {
    if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {
      return;
    }
    this._initCachedDisplayObject(renderer);
    this._cacheData.sprite.transform._worldID = this.transform._worldID;
    this._cacheData.sprite.worldAlpha = this.worldAlpha;
    this._cacheData.sprite._render(renderer);
  };
  DisplayObject.prototype._initCachedDisplayObject = function _initCachedDisplayObject(renderer) {
    var _a, _b, _c;
    if ((_a = this._cacheData) == null ? void 0 : _a.sprite) {
      return;
    }
    const cacheAlpha = this.alpha;
    this.alpha = 1;
    renderer.batch.flush();
    const bounds = this.getLocalBounds(null, true).clone();
    if ((_b = this.filters) == null ? void 0 : _b.length) {
      const padding = this.filters[0].padding;
      bounds.pad(padding);
    }
    bounds.ceil(settings.RESOLUTION);
    const cachedRenderTexture = renderer.renderTexture.current;
    const cachedSourceFrame = renderer.renderTexture.sourceFrame.clone();
    const cachedDestinationFrame = renderer.renderTexture.destinationFrame.clone();
    const cachedProjectionTransform = renderer.projection.transform;
    const renderTexture = RenderTexture.create({
      width: bounds.width,
      height: bounds.height,
      resolution: this.cacheAsBitmapResolution || renderer.resolution,
      multisample: (_c = this.cacheAsBitmapMultisample) != null ? _c : renderer.multisample
    });
    const textureCacheId = `cacheAsBitmap_${utils_exports.uid()}`;
    this._cacheData.textureCacheId = textureCacheId;
    BaseTexture.addToCache(renderTexture.baseTexture, textureCacheId);
    Texture.addToCache(renderTexture, textureCacheId);
    const m2 = this.transform.localTransform.copyTo(_tempMatrix).invert().translate(-bounds.x, -bounds.y);
    this.render = this._cacheData.originalRender;
    renderer.render(this, { renderTexture, clear: true, transform: m2, skipUpdateTransform: false });
    renderer.framebuffer.blit();
    renderer.projection.transform = cachedProjectionTransform;
    renderer.renderTexture.bind(cachedRenderTexture, cachedSourceFrame, cachedDestinationFrame);
    this.render = this._renderCached;
    this.updateTransform = this.displayObjectUpdateTransform;
    this.calculateBounds = this._calculateCachedBounds;
    this.getLocalBounds = this._getCachedLocalBounds;
    this._mask = null;
    this.filterArea = null;
    this.alpha = cacheAlpha;
    const cachedSprite = new Sprite(renderTexture);
    cachedSprite.transform.worldTransform = this.transform.worldTransform;
    cachedSprite.anchor.x = -(bounds.x / bounds.width);
    cachedSprite.anchor.y = -(bounds.y / bounds.height);
    cachedSprite.alpha = cacheAlpha;
    cachedSprite._bounds = this._bounds;
    this._cacheData.sprite = cachedSprite;
    this.transform._parentID = -1;
    if (!this.parent) {
      this.enableTempParent();
      this.updateTransform();
      this.disableTempParent(null);
    } else {
      this.updateTransform();
    }
    this.containsPoint = cachedSprite.containsPoint.bind(cachedSprite);
  };
  DisplayObject.prototype._renderCachedCanvas = function _renderCachedCanvas(renderer) {
    if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {
      return;
    }
    this._initCachedDisplayObjectCanvas(renderer);
    this._cacheData.sprite.worldAlpha = this.worldAlpha;
    this._cacheData.sprite._renderCanvas(renderer);
  };
  DisplayObject.prototype._initCachedDisplayObjectCanvas = function _initCachedDisplayObjectCanvas(renderer) {
    var _a;
    if ((_a = this._cacheData) == null ? void 0 : _a.sprite) {
      return;
    }
    const bounds = this.getLocalBounds(null, true);
    const cacheAlpha = this.alpha;
    this.alpha = 1;
    const cachedRenderTarget = renderer.canvasContext.activeContext;
    const cachedProjectionTransform = renderer._projTransform;
    bounds.ceil(settings.RESOLUTION);
    const renderTexture = RenderTexture.create({ width: bounds.width, height: bounds.height });
    const textureCacheId = `cacheAsBitmap_${utils_exports.uid()}`;
    this._cacheData.textureCacheId = textureCacheId;
    BaseTexture.addToCache(renderTexture.baseTexture, textureCacheId);
    Texture.addToCache(renderTexture, textureCacheId);
    const m2 = _tempMatrix;
    this.transform.localTransform.copyTo(m2);
    m2.invert();
    m2.tx -= bounds.x;
    m2.ty -= bounds.y;
    this.renderCanvas = this._cacheData.originalRenderCanvas;
    renderer.render(this, { renderTexture, clear: true, transform: m2, skipUpdateTransform: false });
    renderer.canvasContext.activeContext = cachedRenderTarget;
    renderer._projTransform = cachedProjectionTransform;
    this.renderCanvas = this._renderCachedCanvas;
    this.updateTransform = this.displayObjectUpdateTransform;
    this.calculateBounds = this._calculateCachedBounds;
    this.getLocalBounds = this._getCachedLocalBounds;
    this._mask = null;
    this.filterArea = null;
    this.alpha = cacheAlpha;
    const cachedSprite = new Sprite(renderTexture);
    cachedSprite.transform.worldTransform = this.transform.worldTransform;
    cachedSprite.anchor.x = -(bounds.x / bounds.width);
    cachedSprite.anchor.y = -(bounds.y / bounds.height);
    cachedSprite.alpha = cacheAlpha;
    cachedSprite._bounds = this._bounds;
    this._cacheData.sprite = cachedSprite;
    this.transform._parentID = -1;
    if (!this.parent) {
      this.parent = renderer._tempDisplayObjectParent;
      this.updateTransform();
      this.parent = null;
    } else {
      this.updateTransform();
    }
    this.containsPoint = cachedSprite.containsPoint.bind(cachedSprite);
  };
  DisplayObject.prototype._calculateCachedBounds = function _calculateCachedBounds() {
    this._bounds.clear();
    this._cacheData.sprite.transform._worldID = this.transform._worldID;
    this._cacheData.sprite._calculateBounds();
    this._bounds.updateID = this._boundsID;
  };
  DisplayObject.prototype._getCachedLocalBounds = function _getCachedLocalBounds() {
    return this._cacheData.sprite.getLocalBounds(null);
  };
  DisplayObject.prototype._destroyCachedDisplayObject = function _destroyCachedDisplayObject() {
    this._cacheData.sprite._texture.destroy(true);
    this._cacheData.sprite = null;
    BaseTexture.removeFromCache(this._cacheData.textureCacheId);
    Texture.removeFromCache(this._cacheData.textureCacheId);
    this._cacheData.textureCacheId = null;
  };
  DisplayObject.prototype._cacheAsBitmapDestroy = function _cacheAsBitmapDestroy(options) {
    this.cacheAsBitmap = false;
    this.destroy(options);
  };

  // node_modules/pixijs/display-get-child-by-name/index.mjs
  DisplayObject.prototype.name = null;
  Container.prototype.getChildByName = function getChildByName(name, deep) {
    for (let i = 0, j = this.children.length; i < j; i++) {
      if (this.children[i].name === name) {
        return this.children[i];
      }
    }
    if (deep) {
      for (let i = 0, j = this.children.length; i < j; i++) {
        const child = this.children[i];
        if (!child.getChildByName) {
          continue;
        }
        const target = child.getChildByName(name, true);
        if (target) {
          return target;
        }
      }
    }
    return null;
  };

  // node_modules/pixijs/display-get-global-position/index.mjs
  DisplayObject.prototype.getGlobalPosition = function getGlobalPosition(point = new Point(), skipUpdate = false) {
    if (this.parent) {
      this.parent.toGlobal(this.position, point, skipUpdate);
    } else {
      point.x = this.position.x;
      point.y = this.position.y;
    }
    return point;
  };

  // node_modules/pixijs/filter-alpha/alpha.mjs
  var fragment2 = "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform float uAlpha;\n\nvoid main(void)\n{\n   gl_FragColor = texture2D(uSampler, vTextureCoord) * uAlpha;\n}\n";

  // node_modules/pixijs/filter-alpha/AlphaFilter.mjs
  var AlphaFilter = class extends Filter {
    constructor(alpha = 1) {
      super(defaultVertex4, fragment2, { uAlpha: 1 });
      this.alpha = alpha;
    }
    get alpha() {
      return this.uniforms.uAlpha;
    }
    set alpha(value) {
      this.uniforms.uAlpha = value;
    }
  };

  // node_modules/pixijs/filter-blur/generateBlurFragSource.mjs
  var GAUSSIAN_VALUES = {
    5: [0.153388, 0.221461, 0.250301],
    7: [0.071303, 0.131514, 0.189879, 0.214607],
    9: [0.028532, 0.067234, 0.124009, 0.179044, 0.20236],
    11: [93e-4, 0.028002, 0.065984, 0.121703, 0.175713, 0.198596],
    13: [2406e-6, 9255e-6, 0.027867, 0.065666, 0.121117, 0.174868, 0.197641],
    15: [489e-6, 2403e-6, 9246e-6, 0.02784, 0.065602, 0.120999, 0.174697, 0.197448]
  };
  var fragTemplate2 = [
    "varying vec2 vBlurTexCoords[%size%];",
    "uniform sampler2D uSampler;",
    "void main(void)",
    "{",
    "    gl_FragColor = vec4(0.0);",
    "    %blur%",
    "}"
  ].join("\n");
  function generateBlurFragSource(kernelSize) {
    const kernel = GAUSSIAN_VALUES[kernelSize];
    const halfLength = kernel.length;
    let fragSource = fragTemplate2;
    let blurLoop = "";
    const template = "gl_FragColor += texture2D(uSampler, vBlurTexCoords[%index%]) * %value%;";
    let value;
    for (let i = 0; i < kernelSize; i++) {
      let blur = template.replace("%index%", i.toString());
      value = i;
      if (i >= halfLength) {
        value = kernelSize - i - 1;
      }
      blur = blur.replace("%value%", kernel[value].toString());
      blurLoop += blur;
      blurLoop += "\n";
    }
    fragSource = fragSource.replace("%blur%", blurLoop);
    fragSource = fragSource.replace("%size%", kernelSize.toString());
    return fragSource;
  }

  // node_modules/pixijs/filter-blur/generateBlurVertSource.mjs
  var vertTemplate = `
    attribute vec2 aVertexPosition;

    uniform mat3 projectionMatrix;

    uniform float strength;

    varying vec2 vBlurTexCoords[%size%];

    uniform vec4 inputSize;
    uniform vec4 outputFrame;

    vec4 filterVertexPosition( void )
    {
        vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

        return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
    }

    vec2 filterTextureCoord( void )
    {
        return aVertexPosition * (outputFrame.zw * inputSize.zw);
    }

    void main(void)
    {
        gl_Position = filterVertexPosition();

        vec2 textureCoord = filterTextureCoord();
        %blur%
    }`;
  function generateBlurVertSource(kernelSize, x3) {
    const halfLength = Math.ceil(kernelSize / 2);
    let vertSource = vertTemplate;
    let blurLoop = "";
    let template;
    if (x3) {
      template = "vBlurTexCoords[%index%] =  textureCoord + vec2(%sampleIndex% * strength, 0.0);";
    } else {
      template = "vBlurTexCoords[%index%] =  textureCoord + vec2(0.0, %sampleIndex% * strength);";
    }
    for (let i = 0; i < kernelSize; i++) {
      let blur = template.replace("%index%", i.toString());
      blur = blur.replace("%sampleIndex%", `${i - (halfLength - 1)}.0`);
      blurLoop += blur;
      blurLoop += "\n";
    }
    vertSource = vertSource.replace("%blur%", blurLoop);
    vertSource = vertSource.replace("%size%", kernelSize.toString());
    return vertSource;
  }

  // node_modules/pixijs/filter-blur/BlurFilterPass.mjs
  var BlurFilterPass = class extends Filter {
    constructor(horizontal, strength = 8, quality = 4, resolution = Filter.defaultResolution, kernelSize = 5) {
      const vertSrc = generateBlurVertSource(kernelSize, horizontal);
      const fragSrc = generateBlurFragSource(kernelSize);
      super(vertSrc, fragSrc);
      this.horizontal = horizontal;
      this.resolution = resolution;
      this._quality = 0;
      this.quality = quality;
      this.blur = strength;
    }
    apply(filterManager, input, output, clearMode) {
      if (output) {
        if (this.horizontal) {
          this.uniforms.strength = 1 / output.width * (output.width / input.width);
        } else {
          this.uniforms.strength = 1 / output.height * (output.height / input.height);
        }
      } else {
        if (this.horizontal) {
          this.uniforms.strength = 1 / filterManager.renderer.width * (filterManager.renderer.width / input.width);
        } else {
          this.uniforms.strength = 1 / filterManager.renderer.height * (filterManager.renderer.height / input.height);
        }
      }
      this.uniforms.strength *= this.strength;
      this.uniforms.strength /= this.passes;
      if (this.passes === 1) {
        filterManager.applyFilter(this, input, output, clearMode);
      } else {
        const renderTarget = filterManager.getFilterTexture();
        const renderer = filterManager.renderer;
        let flip = input;
        let flop = renderTarget;
        this.state.blend = false;
        filterManager.applyFilter(this, flip, flop, CLEAR_MODES.CLEAR);
        for (let i = 1; i < this.passes - 1; i++) {
          filterManager.bindAndClear(flip, CLEAR_MODES.BLIT);
          this.uniforms.uSampler = flop;
          const temp2 = flop;
          flop = flip;
          flip = temp2;
          renderer.shader.bind(this);
          renderer.geometry.draw(5);
        }
        this.state.blend = true;
        filterManager.applyFilter(this, flop, output, clearMode);
        filterManager.returnFilterTexture(renderTarget);
      }
    }
    get blur() {
      return this.strength;
    }
    set blur(value) {
      this.padding = 1 + Math.abs(value) * 2;
      this.strength = value;
    }
    get quality() {
      return this._quality;
    }
    set quality(value) {
      this._quality = value;
      this.passes = value;
    }
  };

  // node_modules/pixijs/filter-blur/BlurFilter.mjs
  var BlurFilter = class extends Filter {
    constructor(strength = 8, quality = 4, resolution = Filter.defaultResolution, kernelSize = 5) {
      super();
      this.blurXFilter = new BlurFilterPass(true, strength, quality, resolution, kernelSize);
      this.blurYFilter = new BlurFilterPass(false, strength, quality, resolution, kernelSize);
      this.resolution = resolution;
      this.quality = quality;
      this.blur = strength;
      this.repeatEdgePixels = false;
    }
    apply(filterManager, input, output, clearMode) {
      const xStrength = Math.abs(this.blurXFilter.strength);
      const yStrength = Math.abs(this.blurYFilter.strength);
      if (xStrength && yStrength) {
        const renderTarget = filterManager.getFilterTexture();
        this.blurXFilter.apply(filterManager, input, renderTarget, CLEAR_MODES.CLEAR);
        this.blurYFilter.apply(filterManager, renderTarget, output, clearMode);
        filterManager.returnFilterTexture(renderTarget);
      } else if (yStrength) {
        this.blurYFilter.apply(filterManager, input, output, clearMode);
      } else {
        this.blurXFilter.apply(filterManager, input, output, clearMode);
      }
    }
    updatePadding() {
      if (this._repeatEdgePixels) {
        this.padding = 0;
      } else {
        this.padding = Math.max(Math.abs(this.blurXFilter.strength), Math.abs(this.blurYFilter.strength)) * 2;
      }
    }
    get blur() {
      return this.blurXFilter.blur;
    }
    set blur(value) {
      this.blurXFilter.blur = this.blurYFilter.blur = value;
      this.updatePadding();
    }
    get quality() {
      return this.blurXFilter.quality;
    }
    set quality(value) {
      this.blurXFilter.quality = this.blurYFilter.quality = value;
    }
    get blurX() {
      return this.blurXFilter.blur;
    }
    set blurX(value) {
      this.blurXFilter.blur = value;
      this.updatePadding();
    }
    get blurY() {
      return this.blurYFilter.blur;
    }
    set blurY(value) {
      this.blurYFilter.blur = value;
      this.updatePadding();
    }
    get blendMode() {
      return this.blurYFilter.blendMode;
    }
    set blendMode(value) {
      this.blurYFilter.blendMode = value;
    }
    get repeatEdgePixels() {
      return this._repeatEdgePixels;
    }
    set repeatEdgePixels(value) {
      this._repeatEdgePixels = value;
      this.updatePadding();
    }
  };

  // node_modules/pixijs/filter-color-matrix/colorMatrix.mjs
  var fragment3 = "varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform float m[20];\nuniform float uAlpha;\n\nvoid main(void)\n{\n    vec4 c = texture2D(uSampler, vTextureCoord);\n\n    if (uAlpha == 0.0) {\n        gl_FragColor = c;\n        return;\n    }\n\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (c.a > 0.0) {\n      c.rgb /= c.a;\n    }\n\n    vec4 result;\n\n    result.r = (m[0] * c.r);\n        result.r += (m[1] * c.g);\n        result.r += (m[2] * c.b);\n        result.r += (m[3] * c.a);\n        result.r += m[4];\n\n    result.g = (m[5] * c.r);\n        result.g += (m[6] * c.g);\n        result.g += (m[7] * c.b);\n        result.g += (m[8] * c.a);\n        result.g += m[9];\n\n    result.b = (m[10] * c.r);\n       result.b += (m[11] * c.g);\n       result.b += (m[12] * c.b);\n       result.b += (m[13] * c.a);\n       result.b += m[14];\n\n    result.a = (m[15] * c.r);\n       result.a += (m[16] * c.g);\n       result.a += (m[17] * c.b);\n       result.a += (m[18] * c.a);\n       result.a += m[19];\n\n    vec3 rgb = mix(c.rgb, result.rgb, uAlpha);\n\n    // Premultiply alpha again.\n    rgb *= result.a;\n\n    gl_FragColor = vec4(rgb, result.a);\n}\n";

  // node_modules/pixijs/filter-color-matrix/ColorMatrixFilter.mjs
  var ColorMatrixFilter = class extends Filter {
    constructor() {
      const uniforms = {
        m: new Float32Array([
          1,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ]),
        uAlpha: 1
      };
      super(defaultFilterVertex, fragment3, uniforms);
      this.alpha = 1;
    }
    _loadMatrix(matrix, multiply = false) {
      let newMatrix = matrix;
      if (multiply) {
        this._multiply(newMatrix, this.uniforms.m, matrix);
        newMatrix = this._colorMatrix(newMatrix);
      }
      this.uniforms.m = newMatrix;
    }
    _multiply(out, a2, b) {
      out[0] = a2[0] * b[0] + a2[1] * b[5] + a2[2] * b[10] + a2[3] * b[15];
      out[1] = a2[0] * b[1] + a2[1] * b[6] + a2[2] * b[11] + a2[3] * b[16];
      out[2] = a2[0] * b[2] + a2[1] * b[7] + a2[2] * b[12] + a2[3] * b[17];
      out[3] = a2[0] * b[3] + a2[1] * b[8] + a2[2] * b[13] + a2[3] * b[18];
      out[4] = a2[0] * b[4] + a2[1] * b[9] + a2[2] * b[14] + a2[3] * b[19] + a2[4];
      out[5] = a2[5] * b[0] + a2[6] * b[5] + a2[7] * b[10] + a2[8] * b[15];
      out[6] = a2[5] * b[1] + a2[6] * b[6] + a2[7] * b[11] + a2[8] * b[16];
      out[7] = a2[5] * b[2] + a2[6] * b[7] + a2[7] * b[12] + a2[8] * b[17];
      out[8] = a2[5] * b[3] + a2[6] * b[8] + a2[7] * b[13] + a2[8] * b[18];
      out[9] = a2[5] * b[4] + a2[6] * b[9] + a2[7] * b[14] + a2[8] * b[19] + a2[9];
      out[10] = a2[10] * b[0] + a2[11] * b[5] + a2[12] * b[10] + a2[13] * b[15];
      out[11] = a2[10] * b[1] + a2[11] * b[6] + a2[12] * b[11] + a2[13] * b[16];
      out[12] = a2[10] * b[2] + a2[11] * b[7] + a2[12] * b[12] + a2[13] * b[17];
      out[13] = a2[10] * b[3] + a2[11] * b[8] + a2[12] * b[13] + a2[13] * b[18];
      out[14] = a2[10] * b[4] + a2[11] * b[9] + a2[12] * b[14] + a2[13] * b[19] + a2[14];
      out[15] = a2[15] * b[0] + a2[16] * b[5] + a2[17] * b[10] + a2[18] * b[15];
      out[16] = a2[15] * b[1] + a2[16] * b[6] + a2[17] * b[11] + a2[18] * b[16];
      out[17] = a2[15] * b[2] + a2[16] * b[7] + a2[17] * b[12] + a2[18] * b[17];
      out[18] = a2[15] * b[3] + a2[16] * b[8] + a2[17] * b[13] + a2[18] * b[18];
      out[19] = a2[15] * b[4] + a2[16] * b[9] + a2[17] * b[14] + a2[18] * b[19] + a2[19];
      return out;
    }
    _colorMatrix(matrix) {
      const m2 = new Float32Array(matrix);
      m2[4] /= 255;
      m2[9] /= 255;
      m2[14] /= 255;
      m2[19] /= 255;
      return m2;
    }
    brightness(b, multiply) {
      const matrix = [
        b,
        0,
        0,
        0,
        0,
        0,
        b,
        0,
        0,
        0,
        0,
        0,
        b,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix, multiply);
    }
    tint(color2, multiply) {
      const r = color2 >> 16 & 255;
      const g = color2 >> 8 & 255;
      const b = color2 & 255;
      const matrix = [
        r / 255,
        0,
        0,
        0,
        0,
        0,
        g / 255,
        0,
        0,
        0,
        0,
        0,
        b / 255,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix, multiply);
    }
    greyscale(scale, multiply) {
      const matrix = [
        scale,
        scale,
        scale,
        0,
        0,
        scale,
        scale,
        scale,
        0,
        0,
        scale,
        scale,
        scale,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix, multiply);
    }
    blackAndWhite(multiply) {
      const matrix = [
        0.3,
        0.6,
        0.1,
        0,
        0,
        0.3,
        0.6,
        0.1,
        0,
        0,
        0.3,
        0.6,
        0.1,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix, multiply);
    }
    hue(rotation, multiply) {
      rotation = (rotation || 0) / 180 * Math.PI;
      const cosR = Math.cos(rotation);
      const sinR = Math.sin(rotation);
      const sqrt = Math.sqrt;
      const w = 1 / 3;
      const sqrW = sqrt(w);
      const a00 = cosR + (1 - cosR) * w;
      const a01 = w * (1 - cosR) - sqrW * sinR;
      const a02 = w * (1 - cosR) + sqrW * sinR;
      const a10 = w * (1 - cosR) + sqrW * sinR;
      const a11 = cosR + w * (1 - cosR);
      const a12 = w * (1 - cosR) - sqrW * sinR;
      const a20 = w * (1 - cosR) - sqrW * sinR;
      const a21 = w * (1 - cosR) + sqrW * sinR;
      const a22 = cosR + w * (1 - cosR);
      const matrix = [
        a00,
        a01,
        a02,
        0,
        0,
        a10,
        a11,
        a12,
        0,
        0,
        a20,
        a21,
        a22,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix, multiply);
    }
    contrast(amount, multiply) {
      const v = (amount || 0) + 1;
      const o = -0.5 * (v - 1);
      const matrix = [
        v,
        0,
        0,
        0,
        o,
        0,
        v,
        0,
        0,
        o,
        0,
        0,
        v,
        0,
        o,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix, multiply);
    }
    saturate(amount = 0, multiply) {
      const x3 = amount * 2 / 3 + 1;
      const y3 = (x3 - 1) * -0.5;
      const matrix = [
        x3,
        y3,
        y3,
        0,
        0,
        y3,
        x3,
        y3,
        0,
        0,
        y3,
        y3,
        x3,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix, multiply);
    }
    desaturate() {
      this.saturate(-1);
    }
    negative(multiply) {
      const matrix = [
        -1,
        0,
        0,
        1,
        0,
        0,
        -1,
        0,
        1,
        0,
        0,
        0,
        -1,
        1,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix, multiply);
    }
    sepia(multiply) {
      const matrix = [
        0.393,
        0.7689999,
        0.18899999,
        0,
        0,
        0.349,
        0.6859999,
        0.16799999,
        0,
        0,
        0.272,
        0.5339999,
        0.13099999,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix, multiply);
    }
    technicolor(multiply) {
      const matrix = [
        1.9125277891456083,
        -0.8545344976951645,
        -0.09155508482755585,
        0,
        11.793603434377337,
        -0.3087833385928097,
        1.7658908555458428,
        -0.10601743074722245,
        0,
        -70.35205161461398,
        -0.231103377548616,
        -0.7501899197440212,
        1.847597816108189,
        0,
        30.950940869491138,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix, multiply);
    }
    polaroid(multiply) {
      const matrix = [
        1.438,
        -0.062,
        -0.062,
        0,
        0,
        -0.122,
        1.378,
        -0.122,
        0,
        0,
        -0.016,
        -0.016,
        1.483,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix, multiply);
    }
    toBGR(multiply) {
      const matrix = [
        0,
        0,
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix, multiply);
    }
    kodachrome(multiply) {
      const matrix = [
        1.1285582396593525,
        -0.3967382283601348,
        -0.03992559172921793,
        0,
        63.72958762196502,
        -0.16404339962244616,
        1.0835251566291304,
        -0.05498805115633132,
        0,
        24.732407896706203,
        -0.16786010706155763,
        -0.5603416277695248,
        1.6014850761964943,
        0,
        35.62982807460946,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix, multiply);
    }
    browni(multiply) {
      const matrix = [
        0.5997023498159715,
        0.34553243048391263,
        -0.2708298674538042,
        0,
        47.43192855600873,
        -0.037703249837783157,
        0.8609577587992641,
        0.15059552388459913,
        0,
        -36.96841498319127,
        0.24113635128153335,
        -0.07441037908422492,
        0.44972182064877153,
        0,
        -7.562075277591283,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix, multiply);
    }
    vintage(multiply) {
      const matrix = [
        0.6279345635605994,
        0.3202183420819367,
        -0.03965408211312453,
        0,
        9.651285835294123,
        0.02578397704808868,
        0.6441188644374771,
        0.03259127616149294,
        0,
        7.462829176470591,
        0.0466055556782719,
        -0.0851232987247891,
        0.5241648018700465,
        0,
        5.159190588235296,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix, multiply);
    }
    colorTone(desaturation, toned, lightColor, darkColor, multiply) {
      desaturation = desaturation || 0.2;
      toned = toned || 0.15;
      lightColor = lightColor || 16770432;
      darkColor = darkColor || 3375104;
      const lR = (lightColor >> 16 & 255) / 255;
      const lG = (lightColor >> 8 & 255) / 255;
      const lB = (lightColor & 255) / 255;
      const dR = (darkColor >> 16 & 255) / 255;
      const dG = (darkColor >> 8 & 255) / 255;
      const dB = (darkColor & 255) / 255;
      const matrix = [
        0.3,
        0.59,
        0.11,
        0,
        0,
        lR,
        lG,
        lB,
        desaturation,
        0,
        dR,
        dG,
        dB,
        toned,
        0,
        lR - dR,
        lG - dG,
        lB - dB,
        0,
        0
      ];
      this._loadMatrix(matrix, multiply);
    }
    night(intensity, multiply) {
      intensity = intensity || 0.1;
      const matrix = [
        intensity * -2,
        -intensity,
        0,
        0,
        0,
        -intensity,
        0,
        intensity,
        0,
        0,
        0,
        intensity,
        intensity * 2,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix, multiply);
    }
    predator(amount, multiply) {
      const matrix = [
        11.224130630493164 * amount,
        -4.794486999511719 * amount,
        -2.8746118545532227 * amount,
        0 * amount,
        0.40342438220977783 * amount,
        -3.6330697536468506 * amount,
        9.193157196044922 * amount,
        -2.951810836791992 * amount,
        0 * amount,
        -1.316135048866272 * amount,
        -3.2184197902679443 * amount,
        -4.2375030517578125 * amount,
        7.476448059082031 * amount,
        0 * amount,
        0.8044459223747253 * amount,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix, multiply);
    }
    lsd(multiply) {
      const matrix = [
        2,
        -0.4,
        0.5,
        0,
        0,
        -0.5,
        2,
        -0.4,
        0,
        0,
        -0.4,
        -0.5,
        3,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix, multiply);
    }
    reset() {
      const matrix = [
        1,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix, false);
    }
    get matrix() {
      return this.uniforms.m;
    }
    set matrix(value) {
      this.uniforms.m = value;
    }
    get alpha() {
      return this.uniforms.uAlpha;
    }
    set alpha(value) {
      this.uniforms.uAlpha = value;
    }
  };
  ColorMatrixFilter.prototype.grayscale = ColorMatrixFilter.prototype.greyscale;

  // node_modules/pixijs/filter-displacement/displacement.mjs
  var fragment4 = "varying vec2 vFilterCoord;\nvarying vec2 vTextureCoord;\n\nuniform vec2 scale;\nuniform mat2 rotation;\nuniform sampler2D uSampler;\nuniform sampler2D mapSampler;\n\nuniform highp vec4 inputSize;\nuniform vec4 inputClamp;\n\nvoid main(void)\n{\n  vec4 map =  texture2D(mapSampler, vFilterCoord);\n\n  map -= 0.5;\n  map.xy = scale * inputSize.zw * (rotation * map.xy);\n\n  gl_FragColor = texture2D(uSampler, clamp(vec2(vTextureCoord.x + map.x, vTextureCoord.y + map.y), inputClamp.xy, inputClamp.zw));\n}\n";

  // node_modules/pixijs/filter-displacement/displacement2.mjs
  var vertex2 = "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\nuniform mat3 filterMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec2 vFilterCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n	gl_Position = filterVertexPosition();\n	vTextureCoord = filterTextureCoord();\n	vFilterCoord = ( filterMatrix * vec3( vTextureCoord, 1.0)  ).xy;\n}\n";

  // node_modules/pixijs/filter-displacement/DisplacementFilter.mjs
  var DisplacementFilter = class extends Filter {
    constructor(sprite, scale) {
      const maskMatrix = new Matrix();
      sprite.renderable = false;
      super(vertex2, fragment4, {
        mapSampler: sprite._texture,
        filterMatrix: maskMatrix,
        scale: { x: 1, y: 1 },
        rotation: new Float32Array([1, 0, 0, 1])
      });
      this.maskSprite = sprite;
      this.maskMatrix = maskMatrix;
      if (scale === null || scale === void 0) {
        scale = 20;
      }
      this.scale = new Point(scale, scale);
    }
    apply(filterManager, input, output, clearMode) {
      this.uniforms.filterMatrix = filterManager.calculateSpriteMatrix(this.maskMatrix, this.maskSprite);
      this.uniforms.scale.x = this.scale.x;
      this.uniforms.scale.y = this.scale.y;
      const wt = this.maskSprite.worldTransform;
      const lenX = Math.sqrt(wt.a * wt.a + wt.b * wt.b);
      const lenY = Math.sqrt(wt.c * wt.c + wt.d * wt.d);
      if (lenX !== 0 && lenY !== 0) {
        this.uniforms.rotation[0] = wt.a / lenX;
        this.uniforms.rotation[1] = wt.b / lenX;
        this.uniforms.rotation[2] = wt.c / lenY;
        this.uniforms.rotation[3] = wt.d / lenY;
      }
      filterManager.applyFilter(this, input, output, clearMode);
    }
    get map() {
      return this.uniforms.mapSampler;
    }
    set map(value) {
      this.uniforms.mapSampler = value;
    }
  };

  // node_modules/pixijs/filter-fxaa/fxaa.mjs
  var fragment5 = `varying vec2 v_rgbNW;
varying vec2 v_rgbNE;
varying vec2 v_rgbSW;
varying vec2 v_rgbSE;
varying vec2 v_rgbM;

varying vec2 vFragCoord;
uniform sampler2D uSampler;
uniform highp vec4 inputSize;


/**
 Basic FXAA implementation based on the code on geeks3d.com with the
 modification that the texture2DLod stuff was removed since it's
 unsupported by WebGL.

 --

 From:
 https://github.com/mitsuhiko/webgl-meincraft

 Copyright (c) 2011 by Armin Ronacher.

 Some rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are
 met:

 * Redistributions of source code must retain the above copyright
 notice, this list of conditions and the following disclaimer.

 * Redistributions in binary form must reproduce the above
 copyright notice, this list of conditions and the following
 disclaimer in the documentation and/or other materials provided
 with the distribution.

 * The names of the contributors may not be used to endorse or
 promote products derived from this software without specific
 prior written permission.

 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef FXAA_REDUCE_MIN
#define FXAA_REDUCE_MIN   (1.0/ 128.0)
#endif
#ifndef FXAA_REDUCE_MUL
#define FXAA_REDUCE_MUL   (1.0 / 8.0)
#endif
#ifndef FXAA_SPAN_MAX
#define FXAA_SPAN_MAX     8.0
#endif

//optimized version for mobile, where dependent
//texture reads can be a bottleneck
vec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 inverseVP,
          vec2 v_rgbNW, vec2 v_rgbNE,
          vec2 v_rgbSW, vec2 v_rgbSE,
          vec2 v_rgbM) {
    vec4 color;
    vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;
    vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;
    vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;
    vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;
    vec4 texColor = texture2D(tex, v_rgbM);
    vec3 rgbM  = texColor.xyz;
    vec3 luma = vec3(0.299, 0.587, 0.114);
    float lumaNW = dot(rgbNW, luma);
    float lumaNE = dot(rgbNE, luma);
    float lumaSW = dot(rgbSW, luma);
    float lumaSE = dot(rgbSE, luma);
    float lumaM  = dot(rgbM,  luma);
    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));
    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));

    mediump vec2 dir;
    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));
    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));

    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *
                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);

    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);
    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),
              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),
                  dir * rcpDirMin)) * inverseVP;

    vec3 rgbA = 0.5 * (
                       texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +
                       texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);
    vec3 rgbB = rgbA * 0.5 + 0.25 * (
                                     texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +
                                     texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);

    float lumaB = dot(rgbB, luma);
    if ((lumaB < lumaMin) || (lumaB > lumaMax))
        color = vec4(rgbA, texColor.a);
    else
        color = vec4(rgbB, texColor.a);
    return color;
}

void main() {

      vec4 color;

      color = fxaa(uSampler, vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);

      gl_FragColor = color;
}
`;

  // node_modules/pixijs/filter-fxaa/fxaa2.mjs
  var vertex3 = "\nattribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 v_rgbNW;\nvarying vec2 v_rgbNE;\nvarying vec2 v_rgbSW;\nvarying vec2 v_rgbSE;\nvarying vec2 v_rgbM;\n\nvarying vec2 vFragCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvoid texcoords(vec2 fragCoord, vec2 inverseVP,\n               out vec2 v_rgbNW, out vec2 v_rgbNE,\n               out vec2 v_rgbSW, out vec2 v_rgbSE,\n               out vec2 v_rgbM) {\n    v_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;\n    v_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;\n    v_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;\n    v_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;\n    v_rgbM = vec2(fragCoord * inverseVP);\n}\n\nvoid main(void) {\n\n   gl_Position = filterVertexPosition();\n\n   vFragCoord = aVertexPosition * outputFrame.zw;\n\n   texcoords(vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n}\n";

  // node_modules/pixijs/filter-fxaa/FXAAFilter.mjs
  var FXAAFilter = class extends Filter {
    constructor() {
      super(vertex3, fragment5);
    }
  };

  // node_modules/pixijs/filter-noise/noise.mjs
  var fragment6 = "precision highp float;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform float uNoise;\nuniform float uSeed;\nuniform sampler2D uSampler;\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main()\n{\n    vec4 color = texture2D(uSampler, vTextureCoord);\n    float randomValue = rand(gl_FragCoord.xy * uSeed);\n    float diff = (randomValue - 0.5) * uNoise;\n\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (color.a > 0.0) {\n        color.rgb /= color.a;\n    }\n\n    color.r += diff;\n    color.g += diff;\n    color.b += diff;\n\n    // Premultiply alpha again.\n    color.rgb *= color.a;\n\n    gl_FragColor = color;\n}\n";

  // node_modules/pixijs/filter-noise/NoiseFilter.mjs
  var NoiseFilter = class extends Filter {
    constructor(noise = 0.5, seed = Math.random()) {
      super(defaultFilterVertex, fragment6, {
        uNoise: 0,
        uSeed: 0
      });
      this.noise = noise;
      this.seed = seed;
    }
    get noise() {
      return this.uniforms.uNoise;
    }
    set noise(value) {
      this.uniforms.uNoise = value;
    }
    get seed() {
      return this.uniforms.uSeed;
    }
    set seed(value) {
      this.uniforms.uSeed = value;
    }
  };

  // node_modules/pixijs/browser/filters.mjs
  var filters = {
    AlphaFilter,
    BlurFilter,
    BlurFilterPass,
    ColorMatrixFilter,
    DisplacementFilter,
    FXAAFilter,
    NoiseFilter
  };
  Object.entries(filters).forEach(([key, FilterClass]) => {
    Object.defineProperty(filters, key, {
      get() {
        utils_exports.deprecation("7.1.0", `filters.${key} has moved to ${key}`);
        return FilterClass;
      }
    });
  });

  // node_modules/pixijs/events/FederatedEvent.mjs
  var FederatedEvent = class {
    constructor(manager) {
      this.bubbles = true;
      this.cancelBubble = true;
      this.cancelable = false;
      this.composed = false;
      this.defaultPrevented = false;
      this.eventPhase = FederatedEvent.prototype.NONE;
      this.propagationStopped = false;
      this.propagationImmediatelyStopped = false;
      this.layer = new Point();
      this.page = new Point();
      this.AT_TARGET = 1;
      this.BUBBLING_PHASE = 2;
      this.CAPTURING_PHASE = 3;
      this.NONE = 0;
      this.manager = manager;
    }
    get layerX() {
      return this.layer.x;
    }
    get layerY() {
      return this.layer.y;
    }
    get pageX() {
      return this.page.x;
    }
    get pageY() {
      return this.page.y;
    }
    get data() {
      return this;
    }
    composedPath() {
      if (this.manager && (!this.path || this.path[this.path.length - 1] !== this.target)) {
        this.path = this.target ? this.manager.propagationPath(this.target) : [];
      }
      return this.path;
    }
    initEvent(_type, _bubbles, _cancelable) {
      throw new Error("initEvent() is a legacy DOM API. It is not implemented in the Federated Events API.");
    }
    initUIEvent(_typeArg, _bubblesArg, _cancelableArg, _viewArg, _detailArg) {
      throw new Error("initUIEvent() is a legacy DOM API. It is not implemented in the Federated Events API.");
    }
    preventDefault() {
      if (this.nativeEvent instanceof Event && this.nativeEvent.cancelable) {
        this.nativeEvent.preventDefault();
      }
      this.defaultPrevented = true;
    }
    stopImmediatePropagation() {
      this.propagationImmediatelyStopped = true;
    }
    stopPropagation() {
      this.propagationStopped = true;
    }
  };

  // node_modules/pixijs/events/FederatedMouseEvent.mjs
  var FederatedMouseEvent = class extends FederatedEvent {
    constructor() {
      super(...arguments);
      this.client = new Point();
      this.movement = new Point();
      this.offset = new Point();
      this.global = new Point();
      this.screen = new Point();
    }
    get clientX() {
      return this.client.x;
    }
    get clientY() {
      return this.client.y;
    }
    get x() {
      return this.clientX;
    }
    get y() {
      return this.clientY;
    }
    get movementX() {
      return this.movement.x;
    }
    get movementY() {
      return this.movement.y;
    }
    get offsetX() {
      return this.offset.x;
    }
    get offsetY() {
      return this.offset.y;
    }
    get globalX() {
      return this.global.x;
    }
    get globalY() {
      return this.global.y;
    }
    get screenX() {
      return this.screen.x;
    }
    get screenY() {
      return this.screen.y;
    }
    getModifierState(key) {
      return "getModifierState" in this.nativeEvent && this.nativeEvent.getModifierState(key);
    }
    initMouseEvent(_typeArg, _canBubbleArg, _cancelableArg, _viewArg, _detailArg, _screenXArg, _screenYArg, _clientXArg, _clientYArg, _ctrlKeyArg, _altKeyArg, _shiftKeyArg, _metaKeyArg, _buttonArg, _relatedTargetArg) {
      throw new Error("Method not implemented.");
    }
  };

  // node_modules/pixijs/events/FederatedPointerEvent.mjs
  var FederatedPointerEvent = class extends FederatedMouseEvent {
    constructor() {
      super(...arguments);
      this.width = 0;
      this.height = 0;
      this.isPrimary = false;
    }
    getCoalescedEvents() {
      if (this.type === "pointermove" || this.type === "mousemove" || this.type === "touchmove") {
        return [this];
      }
      return [];
    }
    getPredictedEvents() {
      throw new Error("getPredictedEvents is not supported!");
    }
  };

  // node_modules/pixijs/events/FederatedWheelEvent.mjs
  var FederatedWheelEvent = class extends FederatedMouseEvent {
    constructor() {
      super(...arguments);
      this.DOM_DELTA_LINE = 0;
      this.DOM_DELTA_PAGE = 1;
      this.DOM_DELTA_PIXEL = 2;
    }
  };

  // node_modules/pixijs/events/EventBoundary.mjs
  var PROPAGATION_LIMIT = 2048;
  var tempHitLocation = new Point();
  var tempLocalMapping = new Point();
  var EventBoundary = class {
    constructor(rootTarget) {
      this.dispatch = new utils_exports.EventEmitter();
      this.moveOnAll = false;
      this.mappingState = {
        trackingData: {}
      };
      this.eventPool = /* @__PURE__ */ new Map();
      this.rootTarget = rootTarget;
      this.hitPruneFn = this.hitPruneFn.bind(this);
      this.hitTestFn = this.hitTestFn.bind(this);
      this.mapPointerDown = this.mapPointerDown.bind(this);
      this.mapPointerMove = this.mapPointerMove.bind(this);
      this.mapPointerOut = this.mapPointerOut.bind(this);
      this.mapPointerOver = this.mapPointerOver.bind(this);
      this.mapPointerUp = this.mapPointerUp.bind(this);
      this.mapPointerUpOutside = this.mapPointerUpOutside.bind(this);
      this.mapWheel = this.mapWheel.bind(this);
      this.mappingTable = {};
      this.addEventMapping("pointerdown", this.mapPointerDown);
      this.addEventMapping("pointermove", this.mapPointerMove);
      this.addEventMapping("pointerout", this.mapPointerOut);
      this.addEventMapping("pointerleave", this.mapPointerOut);
      this.addEventMapping("pointerover", this.mapPointerOver);
      this.addEventMapping("pointerup", this.mapPointerUp);
      this.addEventMapping("pointerupoutside", this.mapPointerUpOutside);
      this.addEventMapping("wheel", this.mapWheel);
    }
    addEventMapping(type2, fn) {
      if (!this.mappingTable[type2]) {
        this.mappingTable[type2] = [];
      }
      this.mappingTable[type2].push({
        fn,
        priority: 0
      });
      this.mappingTable[type2].sort((a2, b) => a2.priority - b.priority);
    }
    dispatchEvent(e, type2) {
      e.propagationStopped = false;
      e.propagationImmediatelyStopped = false;
      this.propagate(e, type2);
      this.dispatch.emit(type2 || e.type, e);
    }
    mapEvent(e) {
      if (!this.rootTarget) {
        return;
      }
      const mappers = this.mappingTable[e.type];
      if (mappers) {
        for (let i = 0, j = mappers.length; i < j; i++) {
          mappers[i].fn(e);
        }
      } else {
        console.warn(`[EventBoundary]: Event mapping not defined for ${e.type}`);
      }
    }
    hitTest(x3, y3) {
      const invertedPath = this.hitTestRecursive(this.rootTarget, this.rootTarget.interactive, tempHitLocation.set(x3, y3), this.hitTestFn, this.hitPruneFn);
      return invertedPath && invertedPath[0];
    }
    propagate(e, type2) {
      if (!e.target) {
        return;
      }
      const composedPath = e.composedPath();
      e.eventPhase = e.CAPTURING_PHASE;
      for (let i = 0, j = composedPath.length - 1; i < j; i++) {
        e.currentTarget = composedPath[i];
        this.notifyTarget(e, type2);
        if (e.propagationStopped || e.propagationImmediatelyStopped)
          return;
      }
      e.eventPhase = e.AT_TARGET;
      e.currentTarget = e.target;
      this.notifyTarget(e, type2);
      if (e.propagationStopped || e.propagationImmediatelyStopped)
        return;
      e.eventPhase = e.BUBBLING_PHASE;
      for (let i = composedPath.length - 2; i >= 0; i--) {
        e.currentTarget = composedPath[i];
        this.notifyTarget(e, type2);
        if (e.propagationStopped || e.propagationImmediatelyStopped)
          return;
      }
    }
    all(e, type2, target = this.rootTarget) {
      e.eventPhase = e.BUBBLING_PHASE;
      const children2 = target.children;
      if (children2) {
        for (let i = 0; i < children2.length; i++) {
          this.all(e, type2, children2[i]);
        }
      }
      e.currentTarget = target;
      this.notifyTarget(e, type2);
    }
    propagationPath(target) {
      const propagationPath = [target];
      for (let i = 0; i < PROPAGATION_LIMIT && target !== this.rootTarget; i++) {
        if (!target.parent) {
          throw new Error("Cannot find propagation path to disconnected target");
        }
        propagationPath.push(target.parent);
        target = target.parent;
      }
      propagationPath.reverse();
      return propagationPath;
    }
    hitTestRecursive(currentTarget, interactive, location, testFn, pruneFn) {
      if (!currentTarget || !currentTarget.visible) {
        return null;
      }
      if (pruneFn(currentTarget, location)) {
        return null;
      }
      if (currentTarget.interactiveChildren && currentTarget.children) {
        const children2 = currentTarget.children;
        for (let i = children2.length - 1; i >= 0; i--) {
          const child = children2[i];
          const nestedHit = this.hitTestRecursive(child, interactive || child.interactive, location, testFn, pruneFn);
          if (nestedHit) {
            if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent) {
              continue;
            }
            if (nestedHit.length > 0 || currentTarget.interactive) {
              nestedHit.push(currentTarget);
            }
            return nestedHit;
          }
        }
      }
      if (interactive && testFn(currentTarget, location)) {
        return currentTarget.interactive ? [currentTarget] : [];
      }
      return null;
    }
    hitPruneFn(displayObject, location) {
      var _a;
      if (displayObject.hitArea) {
        displayObject.worldTransform.applyInverse(location, tempLocalMapping);
        if (!displayObject.hitArea.contains(tempLocalMapping.x, tempLocalMapping.y)) {
          return true;
        }
      }
      if (displayObject._mask) {
        const maskObject = displayObject._mask.isMaskData ? displayObject._mask.maskObject : displayObject._mask;
        if (maskObject && !((_a = maskObject.containsPoint) == null ? void 0 : _a.call(maskObject, location))) {
          return true;
        }
      }
      return false;
    }
    hitTestFn(displayObject, location) {
      if (displayObject.hitArea) {
        return true;
      }
      if (displayObject.containsPoint) {
        return displayObject.containsPoint(location);
      }
      return false;
    }
    notifyTarget(e, type2) {
      var _a, _b;
      type2 = type2 != null ? type2 : e.type;
      const handlerKey = `on${type2}`;
      (_b = (_a = e.currentTarget)[handlerKey]) == null ? void 0 : _b.call(_a, e);
      const key = e.eventPhase === e.CAPTURING_PHASE || e.eventPhase === e.AT_TARGET ? `${type2}capture` : type2;
      this.notifyListeners(e, key);
      if (e.eventPhase === e.AT_TARGET) {
        this.notifyListeners(e, type2);
      }
    }
    mapPointerDown(from) {
      if (!(from instanceof FederatedPointerEvent)) {
        console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
        return;
      }
      const e = this.createPointerEvent(from);
      this.dispatchEvent(e, "pointerdown");
      if (e.pointerType === "touch") {
        this.dispatchEvent(e, "touchstart");
      } else if (e.pointerType === "mouse" || e.pointerType === "pen") {
        const isRightButton = e.button === 2;
        this.dispatchEvent(e, isRightButton ? "rightdown" : "mousedown");
      }
      const trackingData = this.trackingData(from.pointerId);
      trackingData.pressTargetsByButton[from.button] = e.composedPath();
      this.freeEvent(e);
    }
    mapPointerMove(from) {
      var _a, _b;
      if (!(from instanceof FederatedPointerEvent)) {
        console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
        return;
      }
      const e = this.createPointerEvent(from);
      const isMouse = e.pointerType === "mouse" || e.pointerType === "pen";
      const trackingData = this.trackingData(from.pointerId);
      const outTarget = this.findMountedTarget(trackingData.overTargets);
      if (((_a = trackingData.overTargets) == null ? void 0 : _a.length) > 0 && outTarget !== e.target) {
        const outType = from.type === "mousemove" ? "mouseout" : "pointerout";
        const outEvent = this.createPointerEvent(from, outType, outTarget);
        this.dispatchEvent(outEvent, "pointerout");
        if (isMouse)
          this.dispatchEvent(outEvent, "mouseout");
        if (!e.composedPath().includes(outTarget)) {
          const leaveEvent = this.createPointerEvent(from, "pointerleave", outTarget);
          leaveEvent.eventPhase = leaveEvent.AT_TARGET;
          while (leaveEvent.target && !e.composedPath().includes(leaveEvent.target)) {
            leaveEvent.currentTarget = leaveEvent.target;
            this.notifyTarget(leaveEvent);
            if (isMouse)
              this.notifyTarget(leaveEvent, "mouseleave");
            leaveEvent.target = leaveEvent.target.parent;
          }
          this.freeEvent(leaveEvent);
        }
        this.freeEvent(outEvent);
      }
      if (outTarget !== e.target) {
        const overType = from.type === "mousemove" ? "mouseover" : "pointerover";
        const overEvent = this.clonePointerEvent(e, overType);
        this.dispatchEvent(overEvent, "pointerover");
        if (isMouse)
          this.dispatchEvent(overEvent, "mouseover");
        let overTargetAncestor = outTarget == null ? void 0 : outTarget.parent;
        while (overTargetAncestor && overTargetAncestor !== this.rootTarget.parent) {
          if (overTargetAncestor === e.target)
            break;
          overTargetAncestor = overTargetAncestor.parent;
        }
        const didPointerEnter = !overTargetAncestor || overTargetAncestor === this.rootTarget.parent;
        if (didPointerEnter) {
          const enterEvent = this.clonePointerEvent(e, "pointerenter");
          enterEvent.eventPhase = enterEvent.AT_TARGET;
          while (enterEvent.target && enterEvent.target !== outTarget && enterEvent.target !== this.rootTarget.parent) {
            enterEvent.currentTarget = enterEvent.target;
            this.notifyTarget(enterEvent);
            if (isMouse)
              this.notifyTarget(enterEvent, "mouseenter");
            enterEvent.target = enterEvent.target.parent;
          }
          this.freeEvent(enterEvent);
        }
        this.freeEvent(overEvent);
      }
      const propagationMethod = this.moveOnAll ? "all" : "dispatchEvent";
      this[propagationMethod](e, "pointermove");
      this.all(e, "globalpointermove");
      if (e.pointerType === "touch") {
        this[propagationMethod](e, "touchmove");
        this.all(e, "globaltouchmove");
      }
      if (isMouse) {
        this[propagationMethod](e, "mousemove");
        this.all(e, "globalmousemove");
        this.cursor = (_b = e.target) == null ? void 0 : _b.cursor;
      }
      trackingData.overTargets = e.composedPath();
      this.freeEvent(e);
    }
    mapPointerOver(from) {
      var _a;
      if (!(from instanceof FederatedPointerEvent)) {
        console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
        return;
      }
      const trackingData = this.trackingData(from.pointerId);
      const e = this.createPointerEvent(from);
      const isMouse = e.pointerType === "mouse" || e.pointerType === "pen";
      this.dispatchEvent(e, "pointerover");
      if (isMouse)
        this.dispatchEvent(e, "mouseover");
      if (e.pointerType === "mouse")
        this.cursor = (_a = e.target) == null ? void 0 : _a.cursor;
      const enterEvent = this.clonePointerEvent(e, "pointerenter");
      enterEvent.eventPhase = enterEvent.AT_TARGET;
      while (enterEvent.target && enterEvent.target !== this.rootTarget.parent) {
        enterEvent.currentTarget = enterEvent.target;
        this.notifyTarget(enterEvent);
        if (isMouse)
          this.notifyTarget(enterEvent, "mouseenter");
        enterEvent.target = enterEvent.target.parent;
      }
      trackingData.overTargets = e.composedPath();
      this.freeEvent(e);
      this.freeEvent(enterEvent);
    }
    mapPointerOut(from) {
      if (!(from instanceof FederatedPointerEvent)) {
        console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
        return;
      }
      const trackingData = this.trackingData(from.pointerId);
      if (trackingData.overTargets) {
        const isMouse = from.pointerType === "mouse" || from.pointerType === "pen";
        const outTarget = this.findMountedTarget(trackingData.overTargets);
        const outEvent = this.createPointerEvent(from, "pointerout", outTarget);
        this.dispatchEvent(outEvent);
        if (isMouse)
          this.dispatchEvent(outEvent, "mouseout");
        const leaveEvent = this.createPointerEvent(from, "pointerleave", outTarget);
        leaveEvent.eventPhase = leaveEvent.AT_TARGET;
        while (leaveEvent.target && leaveEvent.target !== this.rootTarget.parent) {
          leaveEvent.currentTarget = leaveEvent.target;
          this.notifyTarget(leaveEvent);
          if (isMouse)
            this.notifyTarget(leaveEvent, "mouseleave");
          leaveEvent.target = leaveEvent.target.parent;
        }
        trackingData.overTargets = null;
        this.freeEvent(outEvent);
        this.freeEvent(leaveEvent);
      }
      this.cursor = null;
    }
    mapPointerUp(from) {
      if (!(from instanceof FederatedPointerEvent)) {
        console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
        return;
      }
      const now2 = performance.now();
      const e = this.createPointerEvent(from);
      this.dispatchEvent(e, "pointerup");
      if (e.pointerType === "touch") {
        this.dispatchEvent(e, "touchend");
      } else if (e.pointerType === "mouse" || e.pointerType === "pen") {
        const isRightButton = e.button === 2;
        this.dispatchEvent(e, isRightButton ? "rightup" : "mouseup");
      }
      const trackingData = this.trackingData(from.pointerId);
      const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);
      let clickTarget = pressTarget;
      if (pressTarget && !e.composedPath().includes(pressTarget)) {
        let currentTarget = pressTarget;
        while (currentTarget && !e.composedPath().includes(currentTarget)) {
          e.currentTarget = currentTarget;
          this.notifyTarget(e, "pointerupoutside");
          if (e.pointerType === "touch") {
            this.notifyTarget(e, "touchendoutside");
          } else if (e.pointerType === "mouse" || e.pointerType === "pen") {
            const isRightButton = e.button === 2;
            this.notifyTarget(e, isRightButton ? "rightupoutside" : "mouseupoutside");
          }
          currentTarget = currentTarget.parent;
        }
        delete trackingData.pressTargetsByButton[from.button];
        clickTarget = currentTarget;
      }
      if (clickTarget) {
        const clickEvent = this.clonePointerEvent(e, "click");
        clickEvent.target = clickTarget;
        clickEvent.path = null;
        if (!trackingData.clicksByButton[from.button]) {
          trackingData.clicksByButton[from.button] = {
            clickCount: 0,
            target: clickEvent.target,
            timeStamp: now2
          };
        }
        const clickHistory = trackingData.clicksByButton[from.button];
        if (clickHistory.target === clickEvent.target && now2 - clickHistory.timeStamp < 200) {
          ++clickHistory.clickCount;
        } else {
          clickHistory.clickCount = 1;
        }
        clickHistory.target = clickEvent.target;
        clickHistory.timeStamp = now2;
        clickEvent.detail = clickHistory.clickCount;
        if (clickEvent.pointerType === "mouse") {
          this.dispatchEvent(clickEvent, "click");
        } else if (clickEvent.pointerType === "touch") {
          this.dispatchEvent(clickEvent, "tap");
        }
        this.dispatchEvent(clickEvent, "pointertap");
        this.freeEvent(clickEvent);
      }
      this.freeEvent(e);
    }
    mapPointerUpOutside(from) {
      if (!(from instanceof FederatedPointerEvent)) {
        console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
        return;
      }
      const trackingData = this.trackingData(from.pointerId);
      const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);
      const e = this.createPointerEvent(from);
      if (pressTarget) {
        let currentTarget = pressTarget;
        while (currentTarget) {
          e.currentTarget = currentTarget;
          this.notifyTarget(e, "pointerupoutside");
          if (e.pointerType === "touch") {
            this.notifyTarget(e, "touchendoutside");
          } else if (e.pointerType === "mouse" || e.pointerType === "pen") {
            this.notifyTarget(e, e.button === 2 ? "rightupoutside" : "mouseupoutside");
          }
          currentTarget = currentTarget.parent;
        }
        delete trackingData.pressTargetsByButton[from.button];
      }
      this.freeEvent(e);
    }
    mapWheel(from) {
      if (!(from instanceof FederatedWheelEvent)) {
        console.warn("EventBoundary cannot map a non-wheel event as a wheel event");
        return;
      }
      const wheelEvent = this.createWheelEvent(from);
      this.dispatchEvent(wheelEvent);
      this.freeEvent(wheelEvent);
    }
    findMountedTarget(propagationPath) {
      if (!propagationPath) {
        return null;
      }
      let currentTarget = propagationPath[0];
      for (let i = 1; i < propagationPath.length; i++) {
        if (propagationPath[i].parent === currentTarget) {
          currentTarget = propagationPath[i];
        } else {
          break;
        }
      }
      return currentTarget;
    }
    createPointerEvent(from, type2, target) {
      const event = this.allocateEvent(FederatedPointerEvent);
      this.copyPointerData(from, event);
      this.copyMouseData(from, event);
      this.copyData(from, event);
      event.nativeEvent = from.nativeEvent;
      event.originalEvent = from;
      event.target = target != null ? target : this.hitTest(event.global.x, event.global.y);
      if (typeof type2 === "string") {
        event.type = type2;
      }
      return event;
    }
    createWheelEvent(from) {
      const event = this.allocateEvent(FederatedWheelEvent);
      this.copyWheelData(from, event);
      this.copyMouseData(from, event);
      this.copyData(from, event);
      event.nativeEvent = from.nativeEvent;
      event.originalEvent = from;
      event.target = this.hitTest(event.global.x, event.global.y);
      return event;
    }
    clonePointerEvent(from, type2) {
      const event = this.allocateEvent(FederatedPointerEvent);
      event.nativeEvent = from.nativeEvent;
      event.originalEvent = from.originalEvent;
      this.copyPointerData(from, event);
      this.copyMouseData(from, event);
      this.copyData(from, event);
      event.target = from.target;
      event.path = from.composedPath().slice();
      event.type = type2 != null ? type2 : event.type;
      return event;
    }
    copyWheelData(from, to) {
      to.deltaMode = from.deltaMode;
      to.deltaX = from.deltaX;
      to.deltaY = from.deltaY;
      to.deltaZ = from.deltaZ;
    }
    copyPointerData(from, to) {
      if (!(from instanceof FederatedPointerEvent && to instanceof FederatedPointerEvent))
        return;
      to.pointerId = from.pointerId;
      to.width = from.width;
      to.height = from.height;
      to.isPrimary = from.isPrimary;
      to.pointerType = from.pointerType;
      to.pressure = from.pressure;
      to.tangentialPressure = from.tangentialPressure;
      to.tiltX = from.tiltX;
      to.tiltY = from.tiltY;
      to.twist = from.twist;
    }
    copyMouseData(from, to) {
      if (!(from instanceof FederatedMouseEvent && to instanceof FederatedMouseEvent))
        return;
      to.altKey = from.altKey;
      to.button = from.button;
      to.buttons = from.buttons;
      to.client.copyFrom(from.client);
      to.ctrlKey = from.ctrlKey;
      to.metaKey = from.metaKey;
      to.movement.copyFrom(from.movement);
      to.screen.copyFrom(from.screen);
      to.global.copyFrom(from.global);
    }
    copyData(from, to) {
      to.isTrusted = from.isTrusted;
      to.srcElement = from.srcElement;
      to.timeStamp = performance.now();
      to.type = from.type;
      to.detail = from.detail;
      to.view = from.view;
      to.which = from.which;
      to.layer.copyFrom(from.layer);
      to.page.copyFrom(from.page);
    }
    trackingData(id2) {
      if (!this.mappingState.trackingData[id2]) {
        this.mappingState.trackingData[id2] = {
          pressTargetsByButton: {},
          clicksByButton: {},
          overTarget: null
        };
      }
      return this.mappingState.trackingData[id2];
    }
    allocateEvent(constructor) {
      if (!this.eventPool.has(constructor)) {
        this.eventPool.set(constructor, []);
      }
      const event = this.eventPool.get(constructor).pop() || new constructor(this);
      event.eventPhase = event.NONE;
      event.currentTarget = null;
      event.path = null;
      event.target = null;
      return event;
    }
    freeEvent(event) {
      if (event.manager !== this)
        throw new Error("It is illegal to free an event not managed by this EventBoundary!");
      const constructor = event.constructor;
      if (!this.eventPool.has(constructor)) {
        this.eventPool.set(constructor, []);
      }
      this.eventPool.get(constructor).push(event);
    }
    notifyListeners(e, type2) {
      const listeners = e.currentTarget._events[type2];
      if (!listeners)
        return;
      if ("fn" in listeners) {
        listeners.fn.call(listeners.context, e);
      } else {
        for (let i = 0, j = listeners.length; i < j && !e.propagationImmediatelyStopped; i++) {
          listeners[i].fn.call(listeners[i].context, e);
        }
      }
    }
  };

  // node_modules/pixijs/events/EventSystem.mjs
  var MOUSE_POINTER_ID = 1;
  var TOUCH_TO_POINTER = {
    touchstart: "pointerdown",
    touchend: "pointerup",
    touchendoutside: "pointerupoutside",
    touchmove: "pointermove",
    touchcancel: "pointercancel"
  };
  var EventSystem = class {
    constructor(renderer) {
      this.supportsTouchEvents = "ontouchstart" in globalThis;
      this.supportsPointerEvents = !!globalThis.PointerEvent;
      this.domElement = null;
      this.resolution = 1;
      this.renderer = renderer;
      this.rootBoundary = new EventBoundary(null);
      this.autoPreventDefault = true;
      this.eventsAdded = false;
      this.rootPointerEvent = new FederatedPointerEvent(null);
      this.rootWheelEvent = new FederatedWheelEvent(null);
      this.cursorStyles = {
        default: "inherit",
        pointer: "pointer"
      };
      this.onPointerDown = this.onPointerDown.bind(this);
      this.onPointerMove = this.onPointerMove.bind(this);
      this.onPointerUp = this.onPointerUp.bind(this);
      this.onPointerOverOut = this.onPointerOverOut.bind(this);
      this.onWheel = this.onWheel.bind(this);
    }
    init() {
      const { view, resolution } = this.renderer;
      this.setTargetElement(view);
      this.resolution = resolution;
    }
    resolutionChange(resolution) {
      this.resolution = resolution;
    }
    destroy() {
      this.setTargetElement(null);
      this.renderer = null;
    }
    setCursor(mode) {
      mode = mode || "default";
      let applyStyles = true;
      if (globalThis.OffscreenCanvas && this.domElement instanceof OffscreenCanvas) {
        applyStyles = false;
      }
      if (this.currentCursor === mode) {
        return;
      }
      this.currentCursor = mode;
      const style = this.cursorStyles[mode];
      if (style) {
        switch (typeof style) {
          case "string":
            if (applyStyles) {
              this.domElement.style.cursor = style;
            }
            break;
          case "function":
            style(mode);
            break;
          case "object":
            if (applyStyles) {
              Object.assign(this.domElement.style, style);
            }
            break;
        }
      } else if (applyStyles && typeof mode === "string" && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode)) {
        this.domElement.style.cursor = mode;
      }
    }
    onPointerDown(nativeEvent) {
      this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
      if (this.supportsTouchEvents && nativeEvent.pointerType === "touch")
        return;
      const events = this.normalizeToPointerData(nativeEvent);
      if (this.autoPreventDefault && events[0].isNormalized) {
        const cancelable = nativeEvent.cancelable || !("cancelable" in nativeEvent);
        if (cancelable) {
          nativeEvent.preventDefault();
        }
      }
      for (let i = 0, j = events.length; i < j; i++) {
        const nativeEvent2 = events[i];
        const federatedEvent = this.bootstrapEvent(this.rootPointerEvent, nativeEvent2);
        this.rootBoundary.mapEvent(federatedEvent);
      }
      this.setCursor(this.rootBoundary.cursor);
    }
    onPointerMove(nativeEvent) {
      this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
      if (this.supportsTouchEvents && nativeEvent.pointerType === "touch")
        return;
      const normalizedEvents = this.normalizeToPointerData(nativeEvent);
      for (let i = 0, j = normalizedEvents.length; i < j; i++) {
        const event = this.bootstrapEvent(this.rootPointerEvent, normalizedEvents[i]);
        this.rootBoundary.mapEvent(event);
      }
      this.setCursor(this.rootBoundary.cursor);
    }
    onPointerUp(nativeEvent) {
      this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
      if (this.supportsTouchEvents && nativeEvent.pointerType === "touch")
        return;
      let target = nativeEvent.target;
      if (nativeEvent.composedPath && nativeEvent.composedPath().length > 0) {
        target = nativeEvent.composedPath()[0];
      }
      const outside = target !== this.domElement ? "outside" : "";
      const normalizedEvents = this.normalizeToPointerData(nativeEvent);
      for (let i = 0, j = normalizedEvents.length; i < j; i++) {
        const event = this.bootstrapEvent(this.rootPointerEvent, normalizedEvents[i]);
        event.type += outside;
        this.rootBoundary.mapEvent(event);
      }
      this.setCursor(this.rootBoundary.cursor);
    }
    onPointerOverOut(nativeEvent) {
      this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
      if (this.supportsTouchEvents && nativeEvent.pointerType === "touch")
        return;
      const normalizedEvents = this.normalizeToPointerData(nativeEvent);
      for (let i = 0, j = normalizedEvents.length; i < j; i++) {
        const event = this.bootstrapEvent(this.rootPointerEvent, normalizedEvents[i]);
        this.rootBoundary.mapEvent(event);
      }
      this.setCursor(this.rootBoundary.cursor);
    }
    onWheel(nativeEvent) {
      const wheelEvent = this.normalizeWheelEvent(nativeEvent);
      this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
      this.rootBoundary.mapEvent(wheelEvent);
    }
    setTargetElement(element) {
      this.removeEvents();
      this.domElement = element;
      this.addEvents();
    }
    addEvents() {
      if (this.eventsAdded || !this.domElement) {
        return;
      }
      const style = this.domElement.style;
      if (style) {
        if (globalThis.navigator.msPointerEnabled) {
          style.msContentZooming = "none";
          style.msTouchAction = "none";
        } else if (this.supportsPointerEvents) {
          style.touchAction = "none";
        }
      }
      if (this.supportsPointerEvents) {
        globalThis.document.addEventListener("pointermove", this.onPointerMove, true);
        this.domElement.addEventListener("pointerdown", this.onPointerDown, true);
        this.domElement.addEventListener("pointerleave", this.onPointerOverOut, true);
        this.domElement.addEventListener("pointerover", this.onPointerOverOut, true);
        globalThis.addEventListener("pointerup", this.onPointerUp, true);
      } else {
        globalThis.document.addEventListener("mousemove", this.onPointerMove, true);
        this.domElement.addEventListener("mousedown", this.onPointerDown, true);
        this.domElement.addEventListener("mouseout", this.onPointerOverOut, true);
        this.domElement.addEventListener("mouseover", this.onPointerOverOut, true);
        globalThis.addEventListener("mouseup", this.onPointerUp, true);
      }
      if (this.supportsTouchEvents) {
        this.domElement.addEventListener("touchstart", this.onPointerDown, true);
        this.domElement.addEventListener("touchend", this.onPointerUp, true);
        this.domElement.addEventListener("touchmove", this.onPointerMove, true);
      }
      this.domElement.addEventListener("wheel", this.onWheel, {
        passive: true,
        capture: true
      });
      this.eventsAdded = true;
    }
    removeEvents() {
      if (!this.eventsAdded || !this.domElement) {
        return;
      }
      const style = this.domElement.style;
      if (globalThis.navigator.msPointerEnabled) {
        style.msContentZooming = "";
        style.msTouchAction = "";
      } else if (this.supportsPointerEvents) {
        style.touchAction = "";
      }
      if (this.supportsPointerEvents) {
        globalThis.document.removeEventListener("pointermove", this.onPointerMove, true);
        this.domElement.removeEventListener("pointerdown", this.onPointerDown, true);
        this.domElement.removeEventListener("pointerleave", this.onPointerOverOut, true);
        this.domElement.removeEventListener("pointerover", this.onPointerOverOut, true);
        globalThis.removeEventListener("pointerup", this.onPointerUp, true);
      } else {
        globalThis.document.removeEventListener("mousemove", this.onPointerMove, true);
        this.domElement.removeEventListener("mousedown", this.onPointerDown, true);
        this.domElement.removeEventListener("mouseout", this.onPointerOverOut, true);
        this.domElement.removeEventListener("mouseover", this.onPointerOverOut, true);
        globalThis.removeEventListener("mouseup", this.onPointerUp, true);
      }
      if (this.supportsTouchEvents) {
        this.domElement.removeEventListener("touchstart", this.onPointerDown, true);
        this.domElement.removeEventListener("touchend", this.onPointerUp, true);
        this.domElement.removeEventListener("touchmove", this.onPointerMove, true);
      }
      this.domElement.removeEventListener("wheel", this.onWheel, true);
      this.domElement = null;
      this.eventsAdded = false;
    }
    mapPositionToPoint(point, x3, y3) {
      let rect;
      if (!this.domElement.parentElement) {
        rect = {
          x: 0,
          y: 0,
          width: this.domElement.width,
          height: this.domElement.height,
          left: 0,
          top: 0
        };
      } else {
        rect = this.domElement.getBoundingClientRect();
      }
      const resolutionMultiplier = 1 / this.resolution;
      point.x = (x3 - rect.left) * (this.domElement.width / rect.width) * resolutionMultiplier;
      point.y = (y3 - rect.top) * (this.domElement.height / rect.height) * resolutionMultiplier;
    }
    normalizeToPointerData(event) {
      const normalizedEvents = [];
      if (this.supportsTouchEvents && event instanceof TouchEvent) {
        for (let i = 0, li = event.changedTouches.length; i < li; i++) {
          const touch = event.changedTouches[i];
          if (typeof touch.button === "undefined")
            touch.button = 0;
          if (typeof touch.buttons === "undefined")
            touch.buttons = 1;
          if (typeof touch.isPrimary === "undefined") {
            touch.isPrimary = event.touches.length === 1 && event.type === "touchstart";
          }
          if (typeof touch.width === "undefined")
            touch.width = touch.radiusX || 1;
          if (typeof touch.height === "undefined")
            touch.height = touch.radiusY || 1;
          if (typeof touch.tiltX === "undefined")
            touch.tiltX = 0;
          if (typeof touch.tiltY === "undefined")
            touch.tiltY = 0;
          if (typeof touch.pointerType === "undefined")
            touch.pointerType = "touch";
          if (typeof touch.pointerId === "undefined")
            touch.pointerId = touch.identifier || 0;
          if (typeof touch.pressure === "undefined")
            touch.pressure = touch.force || 0.5;
          if (typeof touch.twist === "undefined")
            touch.twist = 0;
          if (typeof touch.tangentialPressure === "undefined")
            touch.tangentialPressure = 0;
          if (typeof touch.layerX === "undefined")
            touch.layerX = touch.offsetX = touch.clientX;
          if (typeof touch.layerY === "undefined")
            touch.layerY = touch.offsetY = touch.clientY;
          touch.isNormalized = true;
          touch.type = event.type;
          normalizedEvents.push(touch);
        }
      } else if (!globalThis.MouseEvent || event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof globalThis.PointerEvent))) {
        const tempEvent = event;
        if (typeof tempEvent.isPrimary === "undefined")
          tempEvent.isPrimary = true;
        if (typeof tempEvent.width === "undefined")
          tempEvent.width = 1;
        if (typeof tempEvent.height === "undefined")
          tempEvent.height = 1;
        if (typeof tempEvent.tiltX === "undefined")
          tempEvent.tiltX = 0;
        if (typeof tempEvent.tiltY === "undefined")
          tempEvent.tiltY = 0;
        if (typeof tempEvent.pointerType === "undefined")
          tempEvent.pointerType = "mouse";
        if (typeof tempEvent.pointerId === "undefined")
          tempEvent.pointerId = MOUSE_POINTER_ID;
        if (typeof tempEvent.pressure === "undefined")
          tempEvent.pressure = 0.5;
        if (typeof tempEvent.twist === "undefined")
          tempEvent.twist = 0;
        if (typeof tempEvent.tangentialPressure === "undefined")
          tempEvent.tangentialPressure = 0;
        tempEvent.isNormalized = true;
        normalizedEvents.push(tempEvent);
      } else {
        normalizedEvents.push(event);
      }
      return normalizedEvents;
    }
    normalizeWheelEvent(nativeEvent) {
      const event = this.rootWheelEvent;
      this.transferMouseData(event, nativeEvent);
      event.deltaX = nativeEvent.deltaX;
      event.deltaY = nativeEvent.deltaY;
      event.deltaZ = nativeEvent.deltaZ;
      event.deltaMode = nativeEvent.deltaMode;
      this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY);
      event.global.copyFrom(event.screen);
      event.offset.copyFrom(event.screen);
      event.nativeEvent = nativeEvent;
      event.type = nativeEvent.type;
      return event;
    }
    bootstrapEvent(event, nativeEvent) {
      event.originalEvent = null;
      event.nativeEvent = nativeEvent;
      event.pointerId = nativeEvent.pointerId;
      event.width = nativeEvent.width;
      event.height = nativeEvent.height;
      event.isPrimary = nativeEvent.isPrimary;
      event.pointerType = nativeEvent.pointerType;
      event.pressure = nativeEvent.pressure;
      event.tangentialPressure = nativeEvent.tangentialPressure;
      event.tiltX = nativeEvent.tiltX;
      event.tiltY = nativeEvent.tiltY;
      event.twist = nativeEvent.twist;
      this.transferMouseData(event, nativeEvent);
      this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY);
      event.global.copyFrom(event.screen);
      event.offset.copyFrom(event.screen);
      event.isTrusted = nativeEvent.isTrusted;
      if (event.type === "pointerleave") {
        event.type = "pointerout";
      }
      if (event.type.startsWith("mouse")) {
        event.type = event.type.replace("mouse", "pointer");
      }
      if (event.type.startsWith("touch")) {
        event.type = TOUCH_TO_POINTER[event.type] || event.type;
      }
      return event;
    }
    transferMouseData(event, nativeEvent) {
      event.isTrusted = nativeEvent.isTrusted;
      event.srcElement = nativeEvent.srcElement;
      event.timeStamp = performance.now();
      event.type = nativeEvent.type;
      event.altKey = nativeEvent.altKey;
      event.button = nativeEvent.button;
      event.buttons = nativeEvent.buttons;
      event.client.x = nativeEvent.clientX;
      event.client.y = nativeEvent.clientY;
      event.ctrlKey = nativeEvent.ctrlKey;
      event.metaKey = nativeEvent.metaKey;
      event.movement.x = nativeEvent.movementX;
      event.movement.y = nativeEvent.movementY;
      event.page.x = nativeEvent.pageX;
      event.page.y = nativeEvent.pageY;
      event.relatedTarget = null;
      event.shiftKey = nativeEvent.shiftKey;
    }
  };
  EventSystem.extension = {
    name: "events",
    type: [
      ExtensionType.RendererSystem,
      ExtensionType.CanvasRendererSystem
    ]
  };
  extensions.add(EventSystem);

  // node_modules/pixijs/events/FederatedEventTarget.mjs
  var FederatedDisplayObject = {
    onclick: null,
    onmousedown: null,
    onmouseenter: null,
    onmouseleave: null,
    onmousemove: null,
    onglobalmousemove: null,
    onmouseout: null,
    onmouseover: null,
    onmouseup: null,
    onmouseupoutside: null,
    onpointercancel: null,
    onpointerdown: null,
    onpointerenter: null,
    onpointerleave: null,
    onpointermove: null,
    onglobalpointermove: null,
    onpointerout: null,
    onpointerover: null,
    onpointertap: null,
    onpointerup: null,
    onpointerupoutside: null,
    onrightclick: null,
    onrightdown: null,
    onrightup: null,
    onrightupoutside: null,
    ontap: null,
    ontouchcancel: null,
    ontouchend: null,
    ontouchendoutside: null,
    ontouchmove: null,
    onglobaltouchmove: null,
    ontouchstart: null,
    onwheel: null,
    interactive: false,
    interactiveChildren: true,
    hitArea: null,
    addEventListener(type2, listener, options) {
      const capture = typeof options === "boolean" && options || typeof options === "object" && options.capture;
      const context2 = typeof listener === "function" ? void 0 : listener;
      type2 = capture ? `${type2}capture` : type2;
      listener = typeof listener === "function" ? listener : listener.handleEvent;
      this.on(type2, listener, context2);
    },
    removeEventListener(type2, listener, options) {
      const capture = typeof options === "boolean" && options || typeof options === "object" && options.capture;
      const context2 = typeof listener === "function" ? void 0 : listener;
      type2 = capture ? `${type2}capture` : type2;
      listener = typeof listener === "function" ? listener : listener.handleEvent;
      this.off(type2, listener, context2);
    },
    dispatchEvent(e) {
      if (!(e instanceof FederatedEvent)) {
        throw new Error("DisplayObject cannot propagate events outside of the Federated Events API");
      }
      e.defaultPrevented = false;
      e.path = null;
      e.target = this;
      e.manager.dispatchEvent(e);
      return !e.defaultPrevented;
    }
  };
  DisplayObject.mixin(FederatedDisplayObject);

  // node_modules/pixijs/accessibility/accessibleTarget.mjs
  var accessibleTarget = {
    accessible: false,
    accessibleTitle: null,
    accessibleHint: null,
    tabIndex: 0,
    _accessibleActive: false,
    _accessibleDiv: null,
    accessibleType: "button",
    accessiblePointerEvents: "auto",
    accessibleChildren: true,
    renderId: -1
  };

  // node_modules/pixijs/accessibility/AccessibilityManager.mjs
  DisplayObject.mixin(accessibleTarget);
  var KEY_CODE_TAB = 9;
  var DIV_TOUCH_SIZE = 100;
  var DIV_TOUCH_POS_X = 0;
  var DIV_TOUCH_POS_Y = 0;
  var DIV_TOUCH_ZINDEX = 2;
  var DIV_HOOK_SIZE = 1;
  var DIV_HOOK_POS_X = -1e3;
  var DIV_HOOK_POS_Y = -1e3;
  var DIV_HOOK_ZINDEX = 2;
  var AccessibilityManager = class {
    constructor(renderer) {
      this.debug = false;
      this._isActive = false;
      this._isMobileAccessibility = false;
      this.pool = [];
      this.renderId = 0;
      this.children = [];
      this.androidUpdateCount = 0;
      this.androidUpdateFrequency = 500;
      this._hookDiv = null;
      if (utils_exports.isMobile.tablet || utils_exports.isMobile.phone) {
        this.createTouchHook();
      }
      const div = document.createElement("div");
      div.style.width = `${DIV_TOUCH_SIZE}px`;
      div.style.height = `${DIV_TOUCH_SIZE}px`;
      div.style.position = "absolute";
      div.style.top = `${DIV_TOUCH_POS_X}px`;
      div.style.left = `${DIV_TOUCH_POS_Y}px`;
      div.style.zIndex = DIV_TOUCH_ZINDEX.toString();
      this.div = div;
      this.renderer = renderer;
      this._onKeyDown = this._onKeyDown.bind(this);
      this._onMouseMove = this._onMouseMove.bind(this);
      globalThis.addEventListener("keydown", this._onKeyDown, false);
    }
    get isActive() {
      return this._isActive;
    }
    get isMobileAccessibility() {
      return this._isMobileAccessibility;
    }
    createTouchHook() {
      const hookDiv = document.createElement("button");
      hookDiv.style.width = `${DIV_HOOK_SIZE}px`;
      hookDiv.style.height = `${DIV_HOOK_SIZE}px`;
      hookDiv.style.position = "absolute";
      hookDiv.style.top = `${DIV_HOOK_POS_X}px`;
      hookDiv.style.left = `${DIV_HOOK_POS_Y}px`;
      hookDiv.style.zIndex = DIV_HOOK_ZINDEX.toString();
      hookDiv.style.backgroundColor = "#FF0000";
      hookDiv.title = "select to enable accessibility for this content";
      hookDiv.addEventListener("focus", () => {
        this._isMobileAccessibility = true;
        this.activate();
        this.destroyTouchHook();
      });
      document.body.appendChild(hookDiv);
      this._hookDiv = hookDiv;
    }
    destroyTouchHook() {
      if (!this._hookDiv) {
        return;
      }
      document.body.removeChild(this._hookDiv);
      this._hookDiv = null;
    }
    activate() {
      var _a;
      if (this._isActive) {
        return;
      }
      this._isActive = true;
      globalThis.document.addEventListener("mousemove", this._onMouseMove, true);
      globalThis.removeEventListener("keydown", this._onKeyDown, false);
      this.renderer.on("postrender", this.update, this);
      (_a = this.renderer.view.parentNode) == null ? void 0 : _a.appendChild(this.div);
    }
    deactivate() {
      var _a;
      if (!this._isActive || this._isMobileAccessibility) {
        return;
      }
      this._isActive = false;
      globalThis.document.removeEventListener("mousemove", this._onMouseMove, true);
      globalThis.addEventListener("keydown", this._onKeyDown, false);
      this.renderer.off("postrender", this.update);
      (_a = this.div.parentNode) == null ? void 0 : _a.removeChild(this.div);
    }
    updateAccessibleObjects(displayObject) {
      if (!displayObject.visible || !displayObject.accessibleChildren) {
        return;
      }
      if (displayObject.accessible && displayObject.interactive) {
        if (!displayObject._accessibleActive) {
          this.addChild(displayObject);
        }
        displayObject.renderId = this.renderId;
      }
      const children2 = displayObject.children;
      if (children2) {
        for (let i = 0; i < children2.length; i++) {
          this.updateAccessibleObjects(children2[i]);
        }
      }
    }
    update() {
      const now2 = performance.now();
      if (utils_exports.isMobile.android.device && now2 < this.androidUpdateCount) {
        return;
      }
      this.androidUpdateCount = now2 + this.androidUpdateFrequency;
      if (!this.renderer.renderingToScreen) {
        return;
      }
      if (this.renderer.lastObjectRendered) {
        this.updateAccessibleObjects(this.renderer.lastObjectRendered);
      }
      const { x: x3, y: y3, width, height } = this.renderer.view.getBoundingClientRect();
      const { width: viewWidth, height: viewHeight, resolution } = this.renderer;
      const sx = width / viewWidth * resolution;
      const sy = height / viewHeight * resolution;
      let div = this.div;
      div.style.left = `${x3}px`;
      div.style.top = `${y3}px`;
      div.style.width = `${viewWidth}px`;
      div.style.height = `${viewHeight}px`;
      for (let i = 0; i < this.children.length; i++) {
        const child = this.children[i];
        if (child.renderId !== this.renderId) {
          child._accessibleActive = false;
          utils_exports.removeItems(this.children, i, 1);
          this.div.removeChild(child._accessibleDiv);
          this.pool.push(child._accessibleDiv);
          child._accessibleDiv = null;
          i--;
        } else {
          div = child._accessibleDiv;
          let hitArea = child.hitArea;
          const wt = child.worldTransform;
          if (child.hitArea) {
            div.style.left = `${(wt.tx + hitArea.x * wt.a) * sx}px`;
            div.style.top = `${(wt.ty + hitArea.y * wt.d) * sy}px`;
            div.style.width = `${hitArea.width * wt.a * sx}px`;
            div.style.height = `${hitArea.height * wt.d * sy}px`;
          } else {
            hitArea = child.getBounds();
            this.capHitArea(hitArea);
            div.style.left = `${hitArea.x * sx}px`;
            div.style.top = `${hitArea.y * sy}px`;
            div.style.width = `${hitArea.width * sx}px`;
            div.style.height = `${hitArea.height * sy}px`;
            if (div.title !== child.accessibleTitle && child.accessibleTitle !== null) {
              div.title = child.accessibleTitle;
            }
            if (div.getAttribute("aria-label") !== child.accessibleHint && child.accessibleHint !== null) {
              div.setAttribute("aria-label", child.accessibleHint);
            }
          }
          if (child.accessibleTitle !== div.title || child.tabIndex !== div.tabIndex) {
            div.title = child.accessibleTitle;
            div.tabIndex = child.tabIndex;
            if (this.debug)
              this.updateDebugHTML(div);
          }
        }
      }
      this.renderId++;
    }
    updateDebugHTML(div) {
      div.innerHTML = `type: ${div.type}</br> title : ${div.title}</br> tabIndex: ${div.tabIndex}`;
    }
    capHitArea(hitArea) {
      if (hitArea.x < 0) {
        hitArea.width += hitArea.x;
        hitArea.x = 0;
      }
      if (hitArea.y < 0) {
        hitArea.height += hitArea.y;
        hitArea.y = 0;
      }
      const { width: viewWidth, height: viewHeight } = this.renderer;
      if (hitArea.x + hitArea.width > viewWidth) {
        hitArea.width = viewWidth - hitArea.x;
      }
      if (hitArea.y + hitArea.height > viewHeight) {
        hitArea.height = viewHeight - hitArea.y;
      }
    }
    addChild(displayObject) {
      let div = this.pool.pop();
      if (!div) {
        div = document.createElement("button");
        div.style.width = `${DIV_TOUCH_SIZE}px`;
        div.style.height = `${DIV_TOUCH_SIZE}px`;
        div.style.backgroundColor = this.debug ? "rgba(255,255,255,0.5)" : "transparent";
        div.style.position = "absolute";
        div.style.zIndex = DIV_TOUCH_ZINDEX.toString();
        div.style.borderStyle = "none";
        if (navigator.userAgent.toLowerCase().includes("chrome")) {
          div.setAttribute("aria-live", "off");
        } else {
          div.setAttribute("aria-live", "polite");
        }
        if (navigator.userAgent.match(/rv:.*Gecko\//)) {
          div.setAttribute("aria-relevant", "additions");
        } else {
          div.setAttribute("aria-relevant", "text");
        }
        div.addEventListener("click", this._onClick.bind(this));
        div.addEventListener("focus", this._onFocus.bind(this));
        div.addEventListener("focusout", this._onFocusOut.bind(this));
      }
      div.style.pointerEvents = displayObject.accessiblePointerEvents;
      div.type = displayObject.accessibleType;
      if (displayObject.accessibleTitle && displayObject.accessibleTitle !== null) {
        div.title = displayObject.accessibleTitle;
      } else if (!displayObject.accessibleHint || displayObject.accessibleHint === null) {
        div.title = `displayObject ${displayObject.tabIndex}`;
      }
      if (displayObject.accessibleHint && displayObject.accessibleHint !== null) {
        div.setAttribute("aria-label", displayObject.accessibleHint);
      }
      if (this.debug)
        this.updateDebugHTML(div);
      displayObject._accessibleActive = true;
      displayObject._accessibleDiv = div;
      div.displayObject = displayObject;
      this.children.push(displayObject);
      this.div.appendChild(displayObject._accessibleDiv);
      displayObject._accessibleDiv.tabIndex = displayObject.tabIndex;
    }
    _dispatchEvent(e, type2) {
      const { displayObject: target } = e.target;
      const boundry = this.renderer.events.rootBoundary;
      const event = Object.assign(new FederatedEvent(boundry), { target });
      boundry.rootTarget = this.renderer.lastObjectRendered;
      type2.forEach((type22) => boundry.dispatchEvent(event, type22));
    }
    _onClick(e) {
      this._dispatchEvent(e, ["click", "pointertap", "tap"]);
    }
    _onFocus(e) {
      if (!e.target.getAttribute("aria-live")) {
        e.target.setAttribute("aria-live", "assertive");
      }
      this._dispatchEvent(e, ["mouseover"]);
    }
    _onFocusOut(e) {
      if (!e.target.getAttribute("aria-live")) {
        e.target.setAttribute("aria-live", "polite");
      }
      this._dispatchEvent(e, ["mouseout"]);
    }
    _onKeyDown(e) {
      if (e.keyCode !== KEY_CODE_TAB) {
        return;
      }
      this.activate();
    }
    _onMouseMove(e) {
      if (e.movementX === 0 && e.movementY === 0) {
        return;
      }
      this.deactivate();
    }
    destroy() {
      this.destroyTouchHook();
      this.div = null;
      globalThis.document.removeEventListener("mousemove", this._onMouseMove, true);
      globalThis.removeEventListener("keydown", this._onKeyDown);
      this.pool = null;
      this.children = null;
      this.renderer = null;
    }
  };
  AccessibilityManager.extension = {
    name: "accessibility",
    type: [
      ExtensionType.RendererPlugin,
      ExtensionType.CanvasRendererPlugin
    ]
  };
  extensions.add(AccessibilityManager);

  // node_modules/pixijs/app/Application.mjs
  var _Application = class {
    constructor(options) {
      this.stage = new Container();
      options = Object.assign({
        forceCanvas: false
      }, options);
      this.renderer = autoDetectRenderer(options);
      _Application._plugins.forEach((plugin) => {
        plugin.init.call(this, options);
      });
    }
    render() {
      this.renderer.render(this.stage);
    }
    get view() {
      return this.renderer.view;
    }
    get screen() {
      return this.renderer.screen;
    }
    destroy(removeView, stageOptions) {
      const plugins = _Application._plugins.slice(0);
      plugins.reverse();
      plugins.forEach((plugin) => {
        plugin.destroy.call(this);
      });
      this.stage.destroy(stageOptions);
      this.stage = null;
      this.renderer.destroy(removeView);
      this.renderer = null;
    }
  };
  var Application = _Application;
  Application._plugins = [];
  extensions.handleByList(ExtensionType.Application, Application._plugins);

  // node_modules/pixijs/app/ResizePlugin.mjs
  var ResizePlugin = class {
    static init(options) {
      Object.defineProperty(this, "resizeTo", {
        set(dom) {
          globalThis.removeEventListener("resize", this.queueResize);
          this._resizeTo = dom;
          if (dom) {
            globalThis.addEventListener("resize", this.queueResize);
            this.resize();
          }
        },
        get() {
          return this._resizeTo;
        }
      });
      this.queueResize = () => {
        if (!this._resizeTo) {
          return;
        }
        this.cancelResize();
        this._resizeId = requestAnimationFrame(() => this.resize());
      };
      this.cancelResize = () => {
        if (this._resizeId) {
          cancelAnimationFrame(this._resizeId);
          this._resizeId = null;
        }
      };
      this.resize = () => {
        if (!this._resizeTo) {
          return;
        }
        this.cancelResize();
        let width;
        let height;
        if (this._resizeTo === globalThis.window) {
          width = globalThis.innerWidth;
          height = globalThis.innerHeight;
        } else {
          const { clientWidth, clientHeight } = this._resizeTo;
          width = clientWidth;
          height = clientHeight;
        }
        this.renderer.resize(width, height);
        this.render();
      };
      this._resizeId = null;
      this._resizeTo = null;
      this.resizeTo = options.resizeTo || null;
    }
    static destroy() {
      globalThis.removeEventListener("resize", this.queueResize);
      this.cancelResize();
      this.cancelResize = null;
      this.queueResize = null;
      this.resizeTo = null;
      this.resize = null;
    }
  };
  ResizePlugin.extension = ExtensionType.Application;
  extensions.add(ResizePlugin);

  // node_modules/pixijs/assets/AssetExtension.mjs
  var assetKeyMap = {
    loader: ExtensionType.LoadParser,
    resolver: ExtensionType.ResolveParser,
    cache: ExtensionType.CacheParser,
    detection: ExtensionType.DetectionParser
  };
  extensions.handle(ExtensionType.Asset, (extension) => {
    const ref = extension.ref;
    Object.entries(assetKeyMap).filter(([key]) => !!ref[key]).forEach(([key, type2]) => {
      var _a;
      return extensions.add(Object.assign(ref[key], { extension: (_a = ref[key].extension) != null ? _a : type2 }));
    });
  }, (extension) => {
    const ref = extension.ref;
    Object.keys(assetKeyMap).filter((key) => !!ref[key]).forEach((key) => extensions.remove(ref[key]));
  });

  // node_modules/pixijs/assets/BackgroundLoader.mjs
  var BackgroundLoader = class {
    constructor(loader, verbose = false) {
      this._loader = loader;
      this._assetList = [];
      this._isLoading = false;
      this._maxConcurrent = 1;
      this.verbose = verbose;
    }
    add(assetUrls) {
      assetUrls.forEach((a2) => {
        this._assetList.push(a2);
      });
      if (this.verbose)
        console.log("[BackgroundLoader] assets: ", this._assetList);
      if (this._isActive && !this._isLoading) {
        this._next();
      }
    }
    async _next() {
      if (this._assetList.length && this._isActive) {
        this._isLoading = true;
        const toLoad = [];
        const toLoadAmount = Math.min(this._assetList.length, this._maxConcurrent);
        for (let i = 0; i < toLoadAmount; i++) {
          toLoad.push(this._assetList.pop());
        }
        await this._loader.load(toLoad);
        this._isLoading = false;
        this._next();
      }
    }
    get active() {
      return this._isActive;
    }
    set active(value) {
      if (this._isActive === value)
        return;
      this._isActive = value;
      if (value && !this._isLoading) {
        this._next();
      }
    }
  };

  // node_modules/pixijs/assets/utils/checkDataUrl.mjs
  function checkDataUrl(url2, mimes) {
    if (Array.isArray(mimes)) {
      for (const mime of mimes) {
        if (url2.startsWith(`data:${mime}`))
          return true;
      }
      return false;
    }
    return url2.startsWith(`data:${mimes}`);
  }

  // node_modules/pixijs/assets/utils/checkExtension.mjs
  function checkExtension(url2, extension) {
    const tempURL = url2.split("?")[0];
    const ext = utils_exports.path.extname(tempURL).toLowerCase();
    if (Array.isArray(extension)) {
      return extension.includes(ext);
    }
    return ext === extension;
  }

  // node_modules/pixijs/assets/utils/convertToList.mjs
  var convertToList = (input, transform2) => {
    if (!Array.isArray(input)) {
      input = [input];
    }
    if (!transform2) {
      return input;
    }
    return input.map((item) => {
      if (typeof item === "string") {
        return transform2(item);
      }
      return item;
    });
  };

  // node_modules/pixijs/assets/utils/copySearchParams.mjs
  var copySearchParams = (targetUrl, sourceUrl) => {
    const searchParams = sourceUrl.split("?")[1];
    if (searchParams) {
      targetUrl += `?${searchParams}`;
    }
    return targetUrl;
  };

  // node_modules/pixijs/assets/utils/createStringVariations.mjs
  function processX(base, ids, depth, result, tags) {
    const id2 = ids[depth];
    for (let i = 0; i < id2.length; i++) {
      const value = id2[i];
      if (depth < ids.length - 1) {
        processX(base.replace(result[depth], value), ids, depth + 1, result, tags);
      } else {
        tags.push(base.replace(result[depth], value));
      }
    }
  }
  function createStringVariations(string) {
    const regex = /\{(.*?)\}/g;
    const result = string.match(regex);
    const tags = [];
    if (result) {
      const ids = [];
      result.forEach((vars) => {
        const split = vars.substring(1, vars.length - 1).split(",");
        ids.push(split);
      });
      processX(string, ids, 0, result, tags);
    } else {
      tags.push(string);
    }
    return tags;
  }

  // node_modules/pixijs/assets/utils/isSingleItem.mjs
  var isSingleItem = (item) => !Array.isArray(item);

  // node_modules/pixijs/assets/cache/Cache.mjs
  var CacheClass = class {
    constructor() {
      this._parsers = [];
      this._cache = /* @__PURE__ */ new Map();
      this._cacheMap = /* @__PURE__ */ new Map();
    }
    reset() {
      this._cacheMap.clear();
      this._cache.clear();
    }
    has(key) {
      return this._cache.has(key);
    }
    get(key) {
      const result = this._cache.get(key);
      if (!result) {
        console.warn(`[Assets] Asset id ${key} was not found in the Cache`);
      }
      return result;
    }
    set(key, value) {
      const keys = convertToList(key);
      let cacheableAssets;
      for (let i = 0; i < this.parsers.length; i++) {
        const parser = this.parsers[i];
        if (parser.test(value)) {
          cacheableAssets = parser.getCacheableAssets(keys, value);
          break;
        }
      }
      if (!cacheableAssets) {
        cacheableAssets = {};
        keys.forEach((key2) => {
          cacheableAssets[key2] = value;
        });
      }
      const cacheKeys = Object.keys(cacheableAssets);
      const cachedAssets = {
        cacheKeys,
        keys
      };
      keys.forEach((key2) => {
        this._cacheMap.set(key2, cachedAssets);
      });
      cacheKeys.forEach((key2) => {
        if (this._cache.has(key2) && this._cache.get(key2) !== value) {
          console.warn("[Cache] already has key:", key2);
        }
        this._cache.set(key2, cacheableAssets[key2]);
      });
      if (value instanceof Texture) {
        const texture = value;
        keys.forEach((key2) => {
          if (texture.baseTexture !== Texture.EMPTY.baseTexture) {
            BaseTexture.addToCache(texture.baseTexture, key2);
          }
          Texture.addToCache(texture, key2);
        });
      }
    }
    remove(key) {
      this._cacheMap.get(key);
      if (!this._cacheMap.has(key)) {
        console.warn(`[Assets] Asset id ${key} was not found in the Cache`);
        return;
      }
      const cacheMap = this._cacheMap.get(key);
      const cacheKeys = cacheMap.cacheKeys;
      cacheKeys.forEach((key2) => {
        this._cache.delete(key2);
      });
      cacheMap.keys.forEach((key2) => {
        this._cacheMap.delete(key2);
      });
    }
    get parsers() {
      return this._parsers;
    }
  };
  var Cache = new CacheClass();

  // node_modules/pixijs/assets/loader/Loader.mjs
  var Loader = class {
    constructor() {
      this._parsers = [];
      this.promiseCache = {};
    }
    reset() {
      this.promiseCache = {};
    }
    _getLoadPromiseAndParser(url2, data) {
      const result = {
        promise: null,
        parser: null
      };
      result.promise = (async () => {
        var _a, _b;
        let asset = null;
        for (let i = 0; i < this.parsers.length; i++) {
          const parser = this.parsers[i];
          if (parser.load && ((_a = parser.test) == null ? void 0 : _a.call(parser, url2, data, this))) {
            asset = await parser.load(url2, data, this);
            result.parser = parser;
            break;
          }
        }
        if (!result.parser) {
          console.warn(`[Assets] ${url2} could not be loaded as we don't know how to parse it, ensure the correct parser has being added`);
          return null;
        }
        for (let i = 0; i < this.parsers.length; i++) {
          const parser = this.parsers[i];
          if (parser.parse) {
            if (parser.parse && await ((_b = parser.testParse) == null ? void 0 : _b.call(parser, asset, data, this))) {
              asset = await parser.parse(asset, data, this) || asset;
              result.parser = parser;
            }
          }
        }
        return asset;
      })();
      return result;
    }
    async load(assetsToLoadIn, onProgress) {
      let count = 0;
      const assets = {};
      const singleAsset = isSingleItem(assetsToLoadIn);
      const assetsToLoad = convertToList(assetsToLoadIn, (item) => ({
        src: item
      }));
      const total = assetsToLoad.length;
      const promises = assetsToLoad.map(async (asset) => {
        const url2 = utils_exports.path.toAbsolute(asset.src);
        if (!assets[asset.src]) {
          try {
            if (!this.promiseCache[url2]) {
              this.promiseCache[url2] = this._getLoadPromiseAndParser(url2, asset);
            }
            assets[asset.src] = await this.promiseCache[url2].promise;
            if (onProgress)
              onProgress(++count / total);
          } catch (e) {
            delete this.promiseCache[url2];
            delete assets[asset.src];
            throw new Error(`[Loader.load] Failed to load ${url2}.
${e}`);
          }
        }
      });
      await Promise.all(promises);
      return singleAsset ? assets[assetsToLoad[0].src] : assets;
    }
    async unload(assetsToUnloadIn) {
      const assetsToUnload = convertToList(assetsToUnloadIn, (item) => ({
        src: item
      }));
      const promises = assetsToUnload.map(async (asset) => {
        var _a, _b;
        const url2 = utils_exports.path.toAbsolute(asset.src);
        const loadPromise = this.promiseCache[url2];
        if (loadPromise) {
          const loadedAsset = await loadPromise.promise;
          (_b = (_a = loadPromise.parser) == null ? void 0 : _a.unload) == null ? void 0 : _b.call(_a, loadedAsset, asset, this);
          delete this.promiseCache[url2];
        }
      });
      await Promise.all(promises);
    }
    get parsers() {
      return this._parsers;
    }
  };

  // node_modules/pixijs/assets/loader/parsers/LoaderParser.mjs
  var LoaderParserPriority = /* @__PURE__ */ ((LoaderParserPriority2) => {
    LoaderParserPriority2[LoaderParserPriority2["Low"] = 0] = "Low";
    LoaderParserPriority2[LoaderParserPriority2["Normal"] = 1] = "Normal";
    LoaderParserPriority2[LoaderParserPriority2["High"] = 2] = "High";
    return LoaderParserPriority2;
  })(LoaderParserPriority || {});

  // node_modules/pixijs/assets/loader/parsers/loadJson.mjs
  var loadJson = {
    extension: {
      type: ExtensionType.LoadParser,
      priority: LoaderParserPriority.Low
    },
    test(url2) {
      return utils_exports.path.extname(url2).toLowerCase() === ".json";
    },
    async load(url2) {
      const response = await settings.ADAPTER.fetch(url2);
      const json = await response.json();
      return json;
    }
  };
  extensions.add(loadJson);

  // node_modules/pixijs/assets/loader/parsers/loadTxt.mjs
  var loadTxt = {
    extension: {
      type: ExtensionType.LoadParser,
      priority: LoaderParserPriority.Low
    },
    test(url2) {
      return utils_exports.path.extname(url2).toLowerCase() === ".txt";
    },
    async load(url2) {
      const response = await settings.ADAPTER.fetch(url2);
      const txt = await response.text();
      return txt;
    }
  };
  extensions.add(loadTxt);

  // node_modules/pixijs/assets/loader/parsers/loadWebFont.mjs
  var validWeights = [
    "normal",
    "bold",
    "100",
    "200",
    "300",
    "400",
    "500",
    "600",
    "700",
    "800",
    "900"
  ];
  var validFontExtensions = [".ttf", ".otf", ".woff", ".woff2"];
  var validFontMIMEs = [
    "font/ttf",
    "font/otf",
    "font/woff",
    "font/woff2"
  ];
  function getFontFamilyName(url2) {
    const ext = utils_exports.path.extname(url2);
    const name = utils_exports.path.basename(url2, ext);
    const nameWithSpaces = name.replace(/(-|_)/g, " ");
    const nameTitleCase = nameWithSpaces.toLowerCase().split(" ").map((word) => word.charAt(0).toUpperCase() + word.slice(1)).join(" ");
    return nameTitleCase;
  }
  var loadWebFont = {
    extension: {
      type: ExtensionType.LoadParser,
      priority: LoaderParserPriority.Low
    },
    test(url2) {
      return checkDataUrl(url2, validFontMIMEs) || checkExtension(url2, validFontExtensions);
    },
    async load(url2, options) {
      var _a, _b, _c, _d, _e, _f;
      if (!globalThis.navigator.onLine) {
        throw new Error("[loadWebFont] Cannot load font - navigator is offline");
      }
      const fonts = settings.ADAPTER.getFontFaceSet();
      if (fonts) {
        const fontFaces = [];
        const name = (_b = (_a = options.data) == null ? void 0 : _a.family) != null ? _b : getFontFamilyName(url2);
        const weights = (_e = (_d = (_c = options.data) == null ? void 0 : _c.weights) == null ? void 0 : _d.filter((weight) => validWeights.includes(weight))) != null ? _e : ["normal"];
        const data = (_f = options.data) != null ? _f : {};
        for (let i = 0; i < weights.length; i++) {
          const weight = weights[i];
          const font = new FontFace(name, `url(${encodeURI(url2)})`, __spreadProps(__spreadValues({}, data), {
            weight
          }));
          await font.load();
          fonts.add(font);
          fontFaces.push(font);
        }
        return fontFaces.length === 1 ? fontFaces[0] : fontFaces;
      }
      console.warn("[loadWebFont] FontFace API is not supported. Skipping loading font");
      return null;
    },
    unload(font) {
      (Array.isArray(font) ? font : [font]).forEach((t) => settings.ADAPTER.getFontFaceSet().delete(t));
    }
  };
  extensions.add(loadWebFont);

  // node_modules/pixijs/assets/loader/parsers/WorkerManager.mjs
  var UUID = 0;
  var MAX_WORKERS;
  var WHITE_PNG = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMCAO+ip1sAAAAASUVORK5CYII=";
  var checkImageBitmapCode = {
    id: "checkImageBitmap",
    code: `
    async function checkImageBitmap()
    {
        try
        {
            if (typeof createImageBitmap !== 'function') return false;

            const response = await fetch('${WHITE_PNG}');
            const imageBlob =  await response.blob();
            const imageBitmap = await createImageBitmap(imageBlob);

            return imageBitmap.width === 1 && imageBitmap.height === 1;
        }
        catch (e)
        {
            return false;
        }
    }
    checkImageBitmap().then((result) => { self.postMessage(result); });
    `
  };
  var workerCode = {
    id: "loadImageBitmap",
    code: `
    async function loadImageBitmap(url)
    {
        const response = await fetch(url);

        if (!response.ok)
        {
            throw new Error(\`[WorkerManager.loadImageBitmap] Failed to fetch \${url}: \`
                + \`\${response.status} \${response.statusText}\`);
        }

        const imageBlob =  await response.blob();
        const imageBitmap = await createImageBitmap(imageBlob);

        return imageBitmap;
    }
    self.onmessage = async (event) =>
    {
        try
        {
            const imageBitmap = await loadImageBitmap(event.data.data[0]);

            self.postMessage({
                data: imageBitmap,
                uuid: event.data.uuid,
                id: event.data.id,
            }, [imageBitmap]);
        }
        catch(e)
        {
            self.postMessage({
                error: e,
                uuid: event.data.uuid,
                id: event.data.id,
            });
        }
    };`
  };
  var workerURL;
  var WorkerManagerClass = class {
    constructor() {
      this._initialized = false;
      this._createdWorkers = 0;
      this.workerPool = [];
      this.queue = [];
      this.resolveHash = {};
    }
    isImageBitmapSupported() {
      if (this._isImageBitmapSupported !== void 0)
        return this._isImageBitmapSupported;
      this._isImageBitmapSupported = new Promise((resolve2) => {
        const workerURL2 = URL.createObjectURL(new Blob([checkImageBitmapCode.code], { type: "application/javascript" }));
        const worker = new Worker(workerURL2);
        worker.addEventListener("message", (event) => {
          worker.terminate();
          URL.revokeObjectURL(workerURL2);
          resolve2(event.data);
        });
      });
      return this._isImageBitmapSupported;
    }
    loadImageBitmap(src) {
      return this._run("loadImageBitmap", [src]);
    }
    async _initWorkers() {
      if (this._initialized)
        return;
      this._initialized = true;
    }
    getWorker() {
      if (MAX_WORKERS === void 0) {
        MAX_WORKERS = navigator.hardwareConcurrency || 4;
      }
      let worker = this.workerPool.pop();
      if (!worker && this._createdWorkers < MAX_WORKERS) {
        if (!workerURL) {
          workerURL = URL.createObjectURL(new Blob([workerCode.code], { type: "application/javascript" }));
        }
        this._createdWorkers++;
        worker = new Worker(workerURL);
        worker.addEventListener("message", (event) => {
          this.complete(event.data);
          this.returnWorker(event.target);
          this.next();
        });
      }
      return worker;
    }
    returnWorker(worker) {
      this.workerPool.push(worker);
    }
    complete(data) {
      if (data.error !== void 0) {
        this.resolveHash[data.uuid].reject(data.error);
      } else {
        this.resolveHash[data.uuid].resolve(data.data);
      }
      this.resolveHash[data.uuid] = null;
    }
    async _run(id2, args) {
      await this._initWorkers();
      const promise = new Promise((resolve2, reject) => {
        this.queue.push({ id: id2, arguments: args, resolve: resolve2, reject });
      });
      this.next();
      return promise;
    }
    next() {
      if (!this.queue.length)
        return;
      const worker = this.getWorker();
      if (!worker) {
        return;
      }
      const toDo = this.queue.pop();
      const id2 = toDo.id;
      this.resolveHash[UUID] = { resolve: toDo.resolve, reject: toDo.reject };
      worker.postMessage({
        data: toDo.arguments,
        uuid: UUID++,
        id: id2
      });
    }
  };
  var WorkerManager = new WorkerManagerClass();

  // node_modules/pixijs/assets/loader/parsers/textures/utils/createTexture.mjs
  function createTexture(base, loader, url2) {
    const texture = new Texture(base);
    texture.baseTexture.on("dispose", () => {
      delete loader.promiseCache[url2];
    });
    return texture;
  }

  // node_modules/pixijs/assets/loader/parsers/textures/loadTextures.mjs
  var validImageExtensions = [".jpeg", ".jpg", ".png", ".webp", ".avif"];
  var validImageMIMEs = [
    "image/jpeg",
    "image/png",
    "image/webp",
    "image/avif"
  ];
  async function loadImageBitmap(url2) {
    const response = await settings.ADAPTER.fetch(url2);
    if (!response.ok) {
      throw new Error(`[loadImageBitmap] Failed to fetch ${url2}: ${response.status} ${response.statusText}`);
    }
    const imageBlob = await response.blob();
    const imageBitmap = await createImageBitmap(imageBlob);
    return imageBitmap;
  }
  var loadTextures = {
    extension: {
      type: ExtensionType.LoadParser,
      priority: LoaderParserPriority.High
    },
    config: {
      preferWorkers: true
    },
    test(url2) {
      return checkDataUrl(url2, validImageMIMEs) || checkExtension(url2, validImageExtensions);
    },
    async load(url2, asset, loader) {
      let src = null;
      if (globalThis.createImageBitmap) {
        if (this.config.preferWorkers && await WorkerManager.isImageBitmapSupported()) {
          src = await WorkerManager.loadImageBitmap(url2);
        } else {
          src = await loadImageBitmap(url2);
        }
      } else {
        src = await new Promise((resolve2) => {
          src = new Image();
          src.crossOrigin = "anonymous";
          src.src = url2;
          if (src.complete) {
            resolve2(src);
          } else {
            src.onload = () => {
              resolve2(src);
            };
          }
        });
      }
      const base = new BaseTexture(src, __spreadValues({
        resolution: utils_exports.getResolutionOfUrl(url2)
      }, asset.data));
      base.resource.src = url2;
      return createTexture(base, loader, url2);
    },
    unload(texture) {
      texture.destroy(true);
    }
  };
  extensions.add(loadTextures);

  // node_modules/pixijs/assets/loader/parsers/textures/loadSVG.mjs
  var loadSVG = {
    extension: {
      type: ExtensionType.LoadParser,
      priority: LoaderParserPriority.High
    },
    test(url2) {
      return utils_exports.path.extname(url2).toLowerCase() === ".svg";
    },
    async testParse(data) {
      return SVGResource.test(data);
    },
    async parse(asset, data, loader) {
      var _a, _b, _c;
      const src = new SVGResource(asset, (_a = data == null ? void 0 : data.data) == null ? void 0 : _a.resourceOptions);
      const base = new BaseTexture(src, __spreadValues({
        resolution: utils_exports.getResolutionOfUrl(asset)
      }, data == null ? void 0 : data.data));
      base.resource.src = asset;
      const texture = createTexture(base, loader, asset);
      if (!((_c = (_b = data == null ? void 0 : data.data) == null ? void 0 : _b.resourceOptions) == null ? void 0 : _c.autoLoad)) {
        await src.load();
      }
      return texture;
    },
    async load(url2, _options) {
      const response = await settings.ADAPTER.fetch(url2);
      return response.text();
    },
    unload: loadTextures.unload
  };
  extensions.add(loadSVG);

  // node_modules/pixijs/assets/resolver/Resolver.mjs
  var Resolver = class {
    constructor() {
      this._bundleIdConnector = "-";
      this._createBundleAssetId = (bundleId, assetId) => `${bundleId}${this._bundleIdConnector}${assetId}`;
      this._extractAssetIdFromBundle = (bundleId, assetBundleId) => assetBundleId.replace(`${bundleId}${this._bundleIdConnector}`, "");
      this._assetMap = {};
      this._preferredOrder = [];
      this._parsers = [];
      this._resolverHash = {};
      this._bundles = {};
    }
    setBundleIdentifier(bundleIdentifier) {
      var _a, _b, _c;
      this._bundleIdConnector = (_a = bundleIdentifier.connector) != null ? _a : this._bundleIdConnector;
      this._createBundleAssetId = (_b = bundleIdentifier.createBundleAssetId) != null ? _b : this._createBundleAssetId;
      this._extractAssetIdFromBundle = (_c = bundleIdentifier.extractAssetIdFromBundle) != null ? _c : this._extractAssetIdFromBundle;
      if (this._extractAssetIdFromBundle("foo", this._createBundleAssetId("foo", "bar")) !== "bar") {
        throw new Error("[Resolver] GenerateBundleAssetId are not working correctly");
      }
    }
    prefer(...preferOrders) {
      preferOrders.forEach((prefer) => {
        this._preferredOrder.push(prefer);
        if (!prefer.priority) {
          prefer.priority = Object.keys(prefer.params);
        }
      });
      this._resolverHash = {};
    }
    set basePath(basePath) {
      this._basePath = basePath;
    }
    get basePath() {
      return this._basePath;
    }
    set rootPath(rootPath) {
      this._rootPath = rootPath;
    }
    get rootPath() {
      return this._rootPath;
    }
    get parsers() {
      return this._parsers;
    }
    reset() {
      this._preferredOrder = [];
      this._resolverHash = {};
      this._assetMap = {};
      this._rootPath = null;
      this._basePath = null;
      this._manifest = null;
    }
    setDefaultSearchParams(searchParams) {
      if (typeof searchParams === "string") {
        this._defaultSearchParams = searchParams;
      } else {
        const queryValues = searchParams;
        this._defaultSearchParams = Object.keys(queryValues).map((key) => `${encodeURIComponent(key)}=${encodeURIComponent(queryValues[key])}`).join("&");
      }
    }
    addManifest(manifest) {
      if (this._manifest) {
        console.warn("[Resolver] Manifest already exists, this will be overwritten");
      }
      this._manifest = manifest;
      manifest.bundles.forEach((bundle) => {
        this.addBundle(bundle.name, bundle.assets);
      });
    }
    addBundle(bundleId, assets) {
      const assetNames = [];
      if (Array.isArray(assets)) {
        assets.forEach((asset) => {
          if (typeof asset.name === "string") {
            const bundleAssetId = this._createBundleAssetId(bundleId, asset.name);
            assetNames.push(bundleAssetId);
            this.add([asset.name, bundleAssetId], asset.srcs, asset.data);
          } else {
            const bundleIds = asset.name.map((name) => this._createBundleAssetId(bundleId, name));
            bundleIds.forEach((bundleId2) => {
              assetNames.push(bundleId2);
            });
            this.add([...asset.name, ...bundleIds], asset.srcs);
          }
        });
      } else {
        Object.keys(assets).forEach((key) => {
          assetNames.push(this._createBundleAssetId(bundleId, key));
          this.add([key, this._createBundleAssetId(bundleId, key)], assets[key]);
        });
      }
      this._bundles[bundleId] = assetNames;
    }
    add(keysIn, assetsIn, data) {
      const keys = convertToList(keysIn);
      keys.forEach((key) => {
        if (this._assetMap[key]) {
          console.warn(`[Resolver] already has key: ${key} overwriting`);
        }
      });
      if (!Array.isArray(assetsIn)) {
        if (typeof assetsIn === "string") {
          assetsIn = createStringVariations(assetsIn);
        } else {
          assetsIn = [assetsIn];
        }
      }
      const assetMap = assetsIn.map((asset) => {
        var _a;
        let formattedAsset = asset;
        if (typeof asset === "string") {
          let parsed = false;
          for (let i = 0; i < this._parsers.length; i++) {
            const parser = this._parsers[i];
            if (parser.test(asset)) {
              formattedAsset = parser.parse(asset);
              parsed = true;
              break;
            }
          }
          if (!parsed) {
            formattedAsset = {
              src: asset
            };
          }
        }
        if (!formattedAsset.format) {
          formattedAsset.format = formattedAsset.src.split(".").pop();
        }
        if (!formattedAsset.alias) {
          formattedAsset.alias = keys;
        }
        if (this._basePath || this._rootPath) {
          formattedAsset.src = utils_exports.path.toAbsolute(formattedAsset.src, this._basePath, this._rootPath);
        }
        formattedAsset.src = this._appendDefaultSearchParams(formattedAsset.src);
        formattedAsset.data = (_a = formattedAsset.data) != null ? _a : data;
        return formattedAsset;
      });
      keys.forEach((key) => {
        this._assetMap[key] = assetMap;
      });
    }
    resolveBundle(bundleIds) {
      const singleAsset = isSingleItem(bundleIds);
      bundleIds = convertToList(bundleIds);
      const out = {};
      bundleIds.forEach((bundleId) => {
        const assetNames = this._bundles[bundleId];
        if (assetNames) {
          const results = this.resolve(assetNames);
          const assets = {};
          for (const key in results) {
            const asset = results[key];
            assets[this._extractAssetIdFromBundle(bundleId, key)] = asset;
          }
          out[bundleId] = assets;
        }
      });
      return singleAsset ? out[bundleIds[0]] : out;
    }
    resolveUrl(key) {
      const result = this.resolve(key);
      if (typeof key !== "string") {
        const out = {};
        for (const i in result) {
          out[i] = result[i].src;
        }
        return out;
      }
      return result.src;
    }
    resolve(keys) {
      const singleAsset = isSingleItem(keys);
      keys = convertToList(keys);
      const result = {};
      keys.forEach((key) => {
        var _a;
        if (!this._resolverHash[key]) {
          if (this._assetMap[key]) {
            let assets = this._assetMap[key];
            const preferredOrder = this._getPreferredOrder(assets);
            const bestAsset = assets[0];
            preferredOrder == null ? void 0 : preferredOrder.priority.forEach((priorityKey) => {
              preferredOrder.params[priorityKey].forEach((value) => {
                const filteredAssets = assets.filter((asset) => {
                  if (asset[priorityKey]) {
                    return asset[priorityKey] === value;
                  }
                  return false;
                });
                if (filteredAssets.length) {
                  assets = filteredAssets;
                }
              });
            });
            this._resolverHash[key] = (_a = assets[0]) != null ? _a : bestAsset;
          } else {
            let src = key;
            if (this._basePath || this._rootPath) {
              src = utils_exports.path.toAbsolute(src, this._basePath, this._rootPath);
            }
            src = this._appendDefaultSearchParams(src);
            this._resolverHash[key] = {
              src
            };
          }
        }
        result[key] = this._resolverHash[key];
      });
      return singleAsset ? result[keys[0]] : result;
    }
    _getPreferredOrder(assets) {
      for (let i = 0; i < assets.length; i++) {
        const asset = assets[0];
        const preferred = this._preferredOrder.find((preference) => preference.params.format.includes(asset.format));
        if (preferred) {
          return preferred;
        }
      }
      return this._preferredOrder[0];
    }
    _appendDefaultSearchParams(url2) {
      if (!this._defaultSearchParams)
        return url2;
      const paramConnector = /\?/.test(url2) ? "&" : "?";
      return `${url2}${paramConnector}${this._defaultSearchParams}`;
    }
  };

  // node_modules/pixijs/assets/Assets.mjs
  var AssetsClass = class {
    constructor() {
      this._detections = [];
      this._initialized = false;
      this.resolver = new Resolver();
      this.loader = new Loader();
      this.cache = Cache;
      this._backgroundLoader = new BackgroundLoader(this.loader);
      this._backgroundLoader.active = true;
      this.reset();
    }
    async init(options = {}) {
      var _a, _b, _c, _d;
      if (this._initialized) {
        console.warn("[Assets]AssetManager already initialized, did you load before calling this Asset.init()?");
        return;
      }
      this._initialized = true;
      if (options.defaultSearchParams) {
        this.resolver.setDefaultSearchParams(options.defaultSearchParams);
      }
      if (options.basePath) {
        this.resolver.basePath = options.basePath;
      }
      if (options.bundleIdentifier) {
        this.resolver.setBundleIdentifier(options.bundleIdentifier);
      }
      if (options.manifest) {
        let manifest = options.manifest;
        if (typeof manifest === "string") {
          manifest = await this.load(manifest);
        }
        this.resolver.addManifest(manifest);
      }
      const resolutionPref = (_b = (_a = options.texturePreference) == null ? void 0 : _a.resolution) != null ? _b : 1;
      const resolution = typeof resolutionPref === "number" ? [resolutionPref] : resolutionPref;
      let formats2 = [];
      if ((_c = options.texturePreference) == null ? void 0 : _c.format) {
        const formatPref = (_d = options.texturePreference) == null ? void 0 : _d.format;
        formats2 = typeof formatPref === "string" ? [formatPref] : formatPref;
        for (const detection of this._detections) {
          if (!await detection.test()) {
            formats2 = await detection.remove(formats2);
          }
        }
      } else {
        for (const detection of this._detections) {
          if (await detection.test()) {
            formats2 = await detection.add(formats2);
          }
        }
      }
      this.resolver.prefer({
        params: {
          format: formats2,
          resolution
        }
      });
    }
    add(keysIn, assetsIn, data) {
      this.resolver.add(keysIn, assetsIn, data);
    }
    async load(urls, onProgress) {
      if (!this._initialized) {
        await this.init();
      }
      const singleAsset = isSingleItem(urls);
      const urlArray = convertToList(urls).map((url2) => {
        if (typeof url2 !== "string") {
          this.resolver.add(url2.src, url2);
          return url2.src;
        }
        return url2;
      });
      const resolveResults = this.resolver.resolve(urlArray);
      const out = await this._mapLoadToResolve(resolveResults, onProgress);
      return singleAsset ? out[urlArray[0]] : out;
    }
    addBundle(bundleId, assets) {
      this.resolver.addBundle(bundleId, assets);
    }
    async loadBundle(bundleIds, onProgress) {
      if (!this._initialized) {
        await this.init();
      }
      let singleAsset = false;
      if (typeof bundleIds === "string") {
        singleAsset = true;
        bundleIds = [bundleIds];
      }
      const resolveResults = this.resolver.resolveBundle(bundleIds);
      const out = {};
      const keys = Object.keys(resolveResults);
      let count = 0;
      let total = 0;
      const _onProgress = () => {
        onProgress == null ? void 0 : onProgress(++count / total);
      };
      const promises = keys.map((bundleId) => {
        const resolveResult = resolveResults[bundleId];
        total += Object.keys(resolveResult).length;
        return this._mapLoadToResolve(resolveResult, _onProgress).then((resolveResult2) => {
          out[bundleId] = resolveResult2;
        });
      });
      await Promise.all(promises);
      return singleAsset ? out[bundleIds[0]] : out;
    }
    async backgroundLoad(urls) {
      if (!this._initialized) {
        await this.init();
      }
      if (typeof urls === "string") {
        urls = [urls];
      }
      const resolveResults = this.resolver.resolve(urls);
      this._backgroundLoader.add(Object.values(resolveResults));
    }
    async backgroundLoadBundle(bundleIds) {
      if (!this._initialized) {
        await this.init();
      }
      if (typeof bundleIds === "string") {
        bundleIds = [bundleIds];
      }
      const resolveResults = this.resolver.resolveBundle(bundleIds);
      Object.values(resolveResults).forEach((resolveResult) => {
        this._backgroundLoader.add(Object.values(resolveResult));
      });
    }
    reset() {
      this.resolver.reset();
      this.loader.reset();
      this.cache.reset();
      this._initialized = false;
    }
    get(keys) {
      if (typeof keys === "string") {
        return Cache.get(keys);
      }
      const assets = {};
      for (let i = 0; i < keys.length; i++) {
        assets[i] = Cache.get(keys[i]);
      }
      return assets;
    }
    async _mapLoadToResolve(resolveResults, onProgress) {
      const resolveArray = Object.values(resolveResults);
      const resolveKeys = Object.keys(resolveResults);
      this._backgroundLoader.active = false;
      const loadedAssets = await this.loader.load(resolveArray, onProgress);
      this._backgroundLoader.active = true;
      const out = {};
      resolveArray.forEach((resolveResult, i) => {
        const asset = loadedAssets[resolveResult.src];
        const keys = [resolveResult.src];
        if (resolveResult.alias) {
          keys.push(...resolveResult.alias);
        }
        out[resolveKeys[i]] = asset;
        Cache.set(keys, asset);
      });
      return out;
    }
    async unload(urls) {
      if (!this._initialized) {
        await this.init();
      }
      const urlArray = convertToList(urls).map((url2) => typeof url2 !== "string" ? url2.src : url2);
      const resolveResults = this.resolver.resolve(urlArray);
      await this._unloadFromResolved(resolveResults);
    }
    async unloadBundle(bundleIds) {
      if (!this._initialized) {
        await this.init();
      }
      bundleIds = convertToList(bundleIds);
      const resolveResults = this.resolver.resolveBundle(bundleIds);
      const promises = Object.keys(resolveResults).map((bundleId) => this._unloadFromResolved(resolveResults[bundleId]));
      await Promise.all(promises);
    }
    async _unloadFromResolved(resolveResult) {
      const resolveArray = Object.values(resolveResult);
      resolveArray.forEach((resolveResult2) => {
        Cache.remove(resolveResult2.src);
      });
      await this.loader.unload(resolveArray);
    }
    get detections() {
      return this._detections;
    }
    get preferWorkers() {
      return loadTextures.config.preferWorkers;
    }
    set preferWorkers(value) {
      loadTextures.config.preferWorkers = value;
    }
  };
  var Assets = new AssetsClass();
  extensions.handleByList(ExtensionType.LoadParser, Assets.loader.parsers).handleByList(ExtensionType.ResolveParser, Assets.resolver.parsers).handleByList(ExtensionType.CacheParser, Assets.cache.parsers).handleByList(ExtensionType.DetectionParser, Assets.detections);

  // node_modules/pixijs/assets/cache/parsers/cacheTextureArray.mjs
  var cacheTextureArray = {
    extension: ExtensionType.CacheParser,
    test: (asset) => Array.isArray(asset) && asset.every((t) => t instanceof Texture),
    getCacheableAssets: (keys, asset) => {
      const out = {};
      keys.forEach((key) => {
        asset.forEach((item, i) => {
          out[key + (i === 0 ? "" : i + 1)] = item;
        });
      });
      return out;
    }
  };
  extensions.add(cacheTextureArray);

  // node_modules/pixijs/assets/detections/parsers/detectAvif.mjs
  var detectAvif = {
    extension: {
      type: ExtensionType.DetectionParser,
      priority: 1
    },
    test: async () => {
      if (!globalThis.createImageBitmap)
        return false;
      const avifData = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A=";
      const blob = await settings.ADAPTER.fetch(avifData).then((r) => r.blob());
      return createImageBitmap(blob).then(() => true, () => false);
    },
    add: async (formats2) => [...formats2, "avif"],
    remove: async (formats2) => formats2.filter((f) => f !== "avif")
  };
  extensions.add(detectAvif);

  // node_modules/pixijs/assets/detections/parsers/detectWebp.mjs
  var detectWebp = {
    extension: {
      type: ExtensionType.DetectionParser,
      priority: 0
    },
    test: async () => {
      if (!globalThis.createImageBitmap)
        return false;
      const webpData = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA=";
      const blob = await settings.ADAPTER.fetch(webpData).then((r) => r.blob());
      return createImageBitmap(blob).then(() => true, () => false);
    },
    add: async (formats2) => [...formats2, "webp"],
    remove: async (formats2) => formats2.filter((f) => f !== "webp")
  };
  extensions.add(detectWebp);

  // node_modules/pixijs/assets/detections/parsers/detectDefaults.mjs
  var imageFormats = ["png", "jpg", "jpeg"];
  var detectDefaults = {
    extension: {
      type: ExtensionType.DetectionParser,
      priority: -1
    },
    test: () => Promise.resolve(true),
    add: async (formats2) => [...formats2, ...imageFormats],
    remove: async (formats2) => formats2.filter((f) => !imageFormats.includes(f))
  };
  extensions.add(detectDefaults);

  // node_modules/pixijs/assets/resolver/parsers/resolveTextureUrl.mjs
  var resolveTextureUrl = {
    extension: ExtensionType.ResolveParser,
    test: loadTextures.test,
    parse: (value) => {
      var _a, _b;
      return {
        resolution: parseFloat((_b = (_a = settings.RETINA_PREFIX.exec(value)) == null ? void 0 : _a[1]) != null ? _b : "1"),
        format: value.split(".").pop(),
        src: value
      };
    }
  };
  extensions.add(resolveTextureUrl);

  // node_modules/pixijs/compressed-textures/const.mjs
  var INTERNAL_FORMATS = /* @__PURE__ */ ((INTERNAL_FORMATS2) => {
    INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB_S3TC_DXT1_EXT"] = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT";
    INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_S3TC_DXT1_EXT"] = 33777] = "COMPRESSED_RGBA_S3TC_DXT1_EXT";
    INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_S3TC_DXT3_EXT"] = 33778] = "COMPRESSED_RGBA_S3TC_DXT3_EXT";
    INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_S3TC_DXT5_EXT"] = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT";
    INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT"] = 35917] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT";
    INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT"] = 35918] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT";
    INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT"] = 35919] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT";
    INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB_S3TC_DXT1_EXT"] = 35916] = "COMPRESSED_SRGB_S3TC_DXT1_EXT";
    INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_R11_EAC"] = 37488] = "COMPRESSED_R11_EAC";
    INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SIGNED_R11_EAC"] = 37489] = "COMPRESSED_SIGNED_R11_EAC";
    INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RG11_EAC"] = 37490] = "COMPRESSED_RG11_EAC";
    INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SIGNED_RG11_EAC"] = 37491] = "COMPRESSED_SIGNED_RG11_EAC";
    INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB8_ETC2"] = 37492] = "COMPRESSED_RGB8_ETC2";
    INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA8_ETC2_EAC"] = 37496] = "COMPRESSED_RGBA8_ETC2_EAC";
    INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB8_ETC2"] = 37493] = "COMPRESSED_SRGB8_ETC2";
    INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB8_ALPHA8_ETC2_EAC"] = 37497] = "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC";
    INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37494] = "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2";
    INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37495] = "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2";
    INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB_PVRTC_4BPPV1_IMG"] = 35840] = "COMPRESSED_RGB_PVRTC_4BPPV1_IMG";
    INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_PVRTC_4BPPV1_IMG"] = 35842] = "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG";
    INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB_PVRTC_2BPPV1_IMG"] = 35841] = "COMPRESSED_RGB_PVRTC_2BPPV1_IMG";
    INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_PVRTC_2BPPV1_IMG"] = 35843] = "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG";
    INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB_ETC1_WEBGL"] = 36196] = "COMPRESSED_RGB_ETC1_WEBGL";
    INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB_ATC_WEBGL"] = 35986] = "COMPRESSED_RGB_ATC_WEBGL";
    INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL"] = 35986] = "COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL";
    INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL"] = 34798] = "COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL";
    INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_ASTC_4x4_KHR"] = 37808] = "COMPRESSED_RGBA_ASTC_4x4_KHR";
    return INTERNAL_FORMATS2;
  })(INTERNAL_FORMATS || {});
  var INTERNAL_FORMAT_TO_BYTES_PER_PIXEL = {
    [33776]: 0.5,
    [33777]: 0.5,
    [33778]: 1,
    [33779]: 1,
    [35916]: 0.5,
    [35917]: 0.5,
    [35918]: 1,
    [35919]: 1,
    [37488]: 0.5,
    [37489]: 0.5,
    [37490]: 1,
    [37491]: 1,
    [37492]: 0.5,
    [37496]: 1,
    [37493]: 0.5,
    [37497]: 1,
    [37494]: 0.5,
    [37495]: 0.5,
    [35840]: 0.5,
    [35842]: 0.5,
    [35841]: 0.25,
    [35843]: 0.25,
    [36196]: 0.5,
    [35986]: 0.5,
    [35986]: 1,
    [34798]: 1,
    [37808]: 1
  };

  // node_modules/pixijs/compressed-textures/loaders/detectCompressedTextures.mjs
  var storedGl;
  var extensions2;
  function getCompressedTextureExtensions() {
    extensions2 = {
      s3tc: storedGl.getExtension("WEBGL_compressed_texture_s3tc"),
      s3tc_sRGB: storedGl.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
      etc: storedGl.getExtension("WEBGL_compressed_texture_etc"),
      etc1: storedGl.getExtension("WEBGL_compressed_texture_etc1"),
      pvrtc: storedGl.getExtension("WEBGL_compressed_texture_pvrtc") || storedGl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
      atc: storedGl.getExtension("WEBGL_compressed_texture_atc"),
      astc: storedGl.getExtension("WEBGL_compressed_texture_astc")
    };
  }
  var detectCompressedTextures = {
    extension: {
      type: ExtensionType.DetectionParser,
      priority: 2
    },
    test: async () => {
      const canvas = settings.ADAPTER.createCanvas();
      const gl = canvas.getContext("webgl");
      if (!gl) {
        console.warn("WebGL not available for compressed textures.");
        return false;
      }
      storedGl = gl;
      return true;
    },
    add: async (formats2) => {
      if (!extensions2)
        getCompressedTextureExtensions();
      const textureFormats = [];
      for (const extensionName in extensions2) {
        const extension = extensions2[extensionName];
        if (!extension) {
          continue;
        }
        textureFormats.push(extensionName);
      }
      return [...textureFormats, ...formats2];
    },
    remove: async (formats2) => {
      if (!extensions2)
        getCompressedTextureExtensions();
      return formats2.filter((f) => !(f in extensions2));
    }
  };
  extensions.add(detectCompressedTextures);

  // node_modules/pixijs/compressed-textures/resources/BlobResource.mjs
  var BlobResource = class extends BufferResource {
    constructor(source, options = { width: 1, height: 1, autoLoad: true }) {
      let origin;
      let data;
      if (typeof source === "string") {
        origin = source;
        data = new Uint8Array();
      } else {
        origin = null;
        data = source;
      }
      super(data, options);
      this.origin = origin;
      this.buffer = data ? new ViewableBuffer(data) : null;
      if (this.origin && options.autoLoad !== false) {
        this.load();
      }
      if (data == null ? void 0 : data.length) {
        this.loaded = true;
        this.onBlobLoaded(this.buffer.rawBinaryData);
      }
    }
    onBlobLoaded(_data) {
    }
    async load() {
      const response = await fetch(this.origin);
      const blob = await response.blob();
      const arrayBuffer = await blob.arrayBuffer();
      this.data = new Uint32Array(arrayBuffer);
      this.buffer = new ViewableBuffer(arrayBuffer);
      this.loaded = true;
      this.onBlobLoaded(arrayBuffer);
      this.update();
      return this;
    }
  };

  // node_modules/pixijs/compressed-textures/resources/CompressedTextureResource.mjs
  var CompressedTextureResource = class extends BlobResource {
    constructor(source, options) {
      super(source, options);
      this.format = options.format;
      this.levels = options.levels || 1;
      this._width = options.width;
      this._height = options.height;
      this._extension = CompressedTextureResource._formatToExtension(this.format);
      if (options.levelBuffers || this.buffer) {
        this._levelBuffers = options.levelBuffers || CompressedTextureResource._createLevelBuffers(source instanceof Uint8Array ? source : this.buffer.uint8View, this.format, this.levels, 4, 4, this.width, this.height);
      }
    }
    upload(renderer, _texture, _glTexture) {
      const gl = renderer.gl;
      const extension = renderer.context.extensions[this._extension];
      if (!extension) {
        throw new Error(`${this._extension} textures are not supported on the current machine`);
      }
      if (!this._levelBuffers) {
        return false;
      }
      for (let i = 0, j = this.levels; i < j; i++) {
        const { levelID, levelWidth, levelHeight, levelBuffer } = this._levelBuffers[i];
        gl.compressedTexImage2D(gl.TEXTURE_2D, levelID, this.format, levelWidth, levelHeight, 0, levelBuffer);
      }
      return true;
    }
    onBlobLoaded() {
      this._levelBuffers = CompressedTextureResource._createLevelBuffers(this.buffer.uint8View, this.format, this.levels, 4, 4, this.width, this.height);
    }
    static _formatToExtension(format2) {
      if (format2 >= 33776 && format2 <= 33779) {
        return "s3tc";
      } else if (format2 >= 37488 && format2 <= 37497) {
        return "etc";
      } else if (format2 >= 35840 && format2 <= 35843) {
        return "pvrtc";
      } else if (format2 >= 36196) {
        return "etc1";
      } else if (format2 >= 35986 && format2 <= 34798) {
        return "atc";
      }
      throw new Error("Invalid (compressed) texture format given!");
    }
    static _createLevelBuffers(buffer, format2, levels, blockWidth, blockHeight, imageWidth, imageHeight) {
      const buffers = new Array(levels);
      let offset = buffer.byteOffset;
      let levelWidth = imageWidth;
      let levelHeight = imageHeight;
      let alignedLevelWidth = levelWidth + blockWidth - 1 & ~(blockWidth - 1);
      let alignedLevelHeight = levelHeight + blockHeight - 1 & ~(blockHeight - 1);
      let levelSize = alignedLevelWidth * alignedLevelHeight * INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[format2];
      for (let i = 0; i < levels; i++) {
        buffers[i] = {
          levelID: i,
          levelWidth: levels > 1 ? levelWidth : alignedLevelWidth,
          levelHeight: levels > 1 ? levelHeight : alignedLevelHeight,
          levelBuffer: new Uint8Array(buffer.buffer, offset, levelSize)
        };
        offset += levelSize;
        levelWidth = levelWidth >> 1 || 1;
        levelHeight = levelHeight >> 1 || 1;
        alignedLevelWidth = levelWidth + blockWidth - 1 & ~(blockWidth - 1);
        alignedLevelHeight = levelHeight + blockHeight - 1 & ~(blockHeight - 1);
        levelSize = alignedLevelWidth * alignedLevelHeight * INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[format2];
      }
      return buffers;
    }
  };

  // node_modules/pixijs/compressed-textures/parsers/parseDDS.mjs
  var DDS_MAGIC_SIZE = 4;
  var DDS_HEADER_SIZE = 124;
  var DDS_HEADER_PF_SIZE = 32;
  var DDS_HEADER_DX10_SIZE = 20;
  var DDS_MAGIC = 542327876;
  var DDS_FIELDS = {
    SIZE: 1,
    FLAGS: 2,
    HEIGHT: 3,
    WIDTH: 4,
    MIPMAP_COUNT: 7,
    PIXEL_FORMAT: 19
  };
  var DDS_PF_FIELDS = {
    SIZE: 0,
    FLAGS: 1,
    FOURCC: 2,
    RGB_BITCOUNT: 3,
    R_BIT_MASK: 4,
    G_BIT_MASK: 5,
    B_BIT_MASK: 6,
    A_BIT_MASK: 7
  };
  var DDS_DX10_FIELDS = {
    DXGI_FORMAT: 0,
    RESOURCE_DIMENSION: 1,
    MISC_FLAG: 2,
    ARRAY_SIZE: 3,
    MISC_FLAGS2: 4
  };
  var PF_FLAGS = 1;
  var DDPF_ALPHA = 2;
  var DDPF_FOURCC = 4;
  var DDPF_RGB = 64;
  var DDPF_YUV = 512;
  var DDPF_LUMINANCE = 131072;
  var FOURCC_DXT1 = 827611204;
  var FOURCC_DXT3 = 861165636;
  var FOURCC_DXT5 = 894720068;
  var FOURCC_DX10 = 808540228;
  var DDS_RESOURCE_MISC_TEXTURECUBE = 4;
  var FOURCC_TO_FORMAT = {
    [FOURCC_DXT1]: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT,
    [FOURCC_DXT3]: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT,
    [FOURCC_DXT5]: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT
  };
  var DXGI_TO_FORMAT = {
    [70]: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT,
    [71]: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT,
    [73]: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT,
    [74]: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT,
    [76]: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT,
    [77]: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT,
    [72]: INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT,
    [75]: INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT,
    [78]: INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
  };
  function parseDDS(arrayBuffer) {
    const data = new Uint32Array(arrayBuffer);
    const magicWord = data[0];
    if (magicWord !== DDS_MAGIC) {
      throw new Error("Invalid DDS file magic word");
    }
    const header = new Uint32Array(arrayBuffer, 0, DDS_HEADER_SIZE / Uint32Array.BYTES_PER_ELEMENT);
    const height = header[DDS_FIELDS.HEIGHT];
    const width = header[DDS_FIELDS.WIDTH];
    const mipmapCount = header[DDS_FIELDS.MIPMAP_COUNT];
    const pixelFormat = new Uint32Array(arrayBuffer, DDS_FIELDS.PIXEL_FORMAT * Uint32Array.BYTES_PER_ELEMENT, DDS_HEADER_PF_SIZE / Uint32Array.BYTES_PER_ELEMENT);
    const formatFlags = pixelFormat[PF_FLAGS];
    if (formatFlags & DDPF_FOURCC) {
      const fourCC = pixelFormat[DDS_PF_FIELDS.FOURCC];
      if (fourCC !== FOURCC_DX10) {
        const internalFormat2 = FOURCC_TO_FORMAT[fourCC];
        const dataOffset2 = DDS_MAGIC_SIZE + DDS_HEADER_SIZE;
        const texData = new Uint8Array(arrayBuffer, dataOffset2);
        const resource = new CompressedTextureResource(texData, {
          format: internalFormat2,
          width,
          height,
          levels: mipmapCount
        });
        return [resource];
      }
      const dx10Offset = DDS_MAGIC_SIZE + DDS_HEADER_SIZE;
      const dx10Header = new Uint32Array(data.buffer, dx10Offset, DDS_HEADER_DX10_SIZE / Uint32Array.BYTES_PER_ELEMENT);
      const dxgiFormat = dx10Header[DDS_DX10_FIELDS.DXGI_FORMAT];
      const resourceDimension = dx10Header[DDS_DX10_FIELDS.RESOURCE_DIMENSION];
      const miscFlag = dx10Header[DDS_DX10_FIELDS.MISC_FLAG];
      const arraySize = dx10Header[DDS_DX10_FIELDS.ARRAY_SIZE];
      const internalFormat = DXGI_TO_FORMAT[dxgiFormat];
      if (internalFormat === void 0) {
        throw new Error(`DDSParser cannot parse texture data with DXGI format ${dxgiFormat}`);
      }
      if (miscFlag === DDS_RESOURCE_MISC_TEXTURECUBE) {
        throw new Error("DDSParser does not support cubemap textures");
      }
      if (resourceDimension === 6) {
        throw new Error("DDSParser does not supported 3D texture data");
      }
      const imageBuffers = new Array();
      const dataOffset = DDS_MAGIC_SIZE + DDS_HEADER_SIZE + DDS_HEADER_DX10_SIZE;
      if (arraySize === 1) {
        imageBuffers.push(new Uint8Array(arrayBuffer, dataOffset));
      } else {
        const pixelSize = INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[internalFormat];
        let imageSize = 0;
        let levelWidth = width;
        let levelHeight = height;
        for (let i = 0; i < mipmapCount; i++) {
          const alignedLevelWidth = Math.max(1, levelWidth + 3 & ~3);
          const alignedLevelHeight = Math.max(1, levelHeight + 3 & ~3);
          const levelSize = alignedLevelWidth * alignedLevelHeight * pixelSize;
          imageSize += levelSize;
          levelWidth = levelWidth >>> 1;
          levelHeight = levelHeight >>> 1;
        }
        let imageOffset = dataOffset;
        for (let i = 0; i < arraySize; i++) {
          imageBuffers.push(new Uint8Array(arrayBuffer, imageOffset, imageSize));
          imageOffset += imageSize;
        }
      }
      return imageBuffers.map((buffer) => new CompressedTextureResource(buffer, {
        format: internalFormat,
        width,
        height,
        levels: mipmapCount
      }));
    }
    if (formatFlags & DDPF_RGB) {
      throw new Error("DDSParser does not support uncompressed texture data.");
    }
    if (formatFlags & DDPF_YUV) {
      throw new Error("DDSParser does not supported YUV uncompressed texture data.");
    }
    if (formatFlags & DDPF_LUMINANCE) {
      throw new Error("DDSParser does not support single-channel (lumninance) texture data!");
    }
    if (formatFlags & DDPF_ALPHA) {
      throw new Error("DDSParser does not support single-channel (alpha) texture data!");
    }
    throw new Error("DDSParser failed to load a texture file due to an unknown reason!");
  }

  // node_modules/pixijs/compressed-textures/parsers/parseKTX.mjs
  var FILE_IDENTIFIER = [171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10];
  var ENDIANNESS = 67305985;
  var KTX_FIELDS = {
    FILE_IDENTIFIER: 0,
    ENDIANNESS: 12,
    GL_TYPE: 16,
    GL_TYPE_SIZE: 20,
    GL_FORMAT: 24,
    GL_INTERNAL_FORMAT: 28,
    GL_BASE_INTERNAL_FORMAT: 32,
    PIXEL_WIDTH: 36,
    PIXEL_HEIGHT: 40,
    PIXEL_DEPTH: 44,
    NUMBER_OF_ARRAY_ELEMENTS: 48,
    NUMBER_OF_FACES: 52,
    NUMBER_OF_MIPMAP_LEVELS: 56,
    BYTES_OF_KEY_VALUE_DATA: 60
  };
  var FILE_HEADER_SIZE = 64;
  var TYPES_TO_BYTES_PER_COMPONENT = {
    [TYPES.UNSIGNED_BYTE]: 1,
    [TYPES.UNSIGNED_SHORT]: 2,
    [TYPES.INT]: 4,
    [TYPES.UNSIGNED_INT]: 4,
    [TYPES.FLOAT]: 4,
    [TYPES.HALF_FLOAT]: 8
  };
  var FORMATS_TO_COMPONENTS = {
    [FORMATS.RGBA]: 4,
    [FORMATS.RGB]: 3,
    [FORMATS.RG]: 2,
    [FORMATS.RED]: 1,
    [FORMATS.LUMINANCE]: 1,
    [FORMATS.LUMINANCE_ALPHA]: 2,
    [FORMATS.ALPHA]: 1
  };
  var TYPES_TO_BYTES_PER_PIXEL = {
    [TYPES.UNSIGNED_SHORT_4_4_4_4]: 2,
    [TYPES.UNSIGNED_SHORT_5_5_5_1]: 2,
    [TYPES.UNSIGNED_SHORT_5_6_5]: 2
  };
  function parseKTX(url2, arrayBuffer, loadKeyValueData = false) {
    const dataView = new DataView(arrayBuffer);
    if (!validate(url2, dataView)) {
      return null;
    }
    const littleEndian = dataView.getUint32(KTX_FIELDS.ENDIANNESS, true) === ENDIANNESS;
    const glType = dataView.getUint32(KTX_FIELDS.GL_TYPE, littleEndian);
    const glFormat = dataView.getUint32(KTX_FIELDS.GL_FORMAT, littleEndian);
    const glInternalFormat = dataView.getUint32(KTX_FIELDS.GL_INTERNAL_FORMAT, littleEndian);
    const pixelWidth = dataView.getUint32(KTX_FIELDS.PIXEL_WIDTH, littleEndian);
    const pixelHeight = dataView.getUint32(KTX_FIELDS.PIXEL_HEIGHT, littleEndian) || 1;
    const pixelDepth = dataView.getUint32(KTX_FIELDS.PIXEL_DEPTH, littleEndian) || 1;
    const numberOfArrayElements = dataView.getUint32(KTX_FIELDS.NUMBER_OF_ARRAY_ELEMENTS, littleEndian) || 1;
    const numberOfFaces = dataView.getUint32(KTX_FIELDS.NUMBER_OF_FACES, littleEndian);
    const numberOfMipmapLevels = dataView.getUint32(KTX_FIELDS.NUMBER_OF_MIPMAP_LEVELS, littleEndian);
    const bytesOfKeyValueData = dataView.getUint32(KTX_FIELDS.BYTES_OF_KEY_VALUE_DATA, littleEndian);
    if (pixelHeight === 0 || pixelDepth !== 1) {
      throw new Error("Only 2D textures are supported");
    }
    if (numberOfFaces !== 1) {
      throw new Error("CubeTextures are not supported by KTXLoader yet!");
    }
    if (numberOfArrayElements !== 1) {
      throw new Error("WebGL does not support array textures");
    }
    const blockWidth = 4;
    const blockHeight = 4;
    const alignedWidth = pixelWidth + 3 & ~3;
    const alignedHeight = pixelHeight + 3 & ~3;
    const imageBuffers = new Array(numberOfArrayElements);
    let imagePixels = pixelWidth * pixelHeight;
    if (glType === 0) {
      imagePixels = alignedWidth * alignedHeight;
    }
    let imagePixelByteSize;
    if (glType !== 0) {
      if (TYPES_TO_BYTES_PER_COMPONENT[glType]) {
        imagePixelByteSize = TYPES_TO_BYTES_PER_COMPONENT[glType] * FORMATS_TO_COMPONENTS[glFormat];
      } else {
        imagePixelByteSize = TYPES_TO_BYTES_PER_PIXEL[glType];
      }
    } else {
      imagePixelByteSize = INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[glInternalFormat];
    }
    if (imagePixelByteSize === void 0) {
      throw new Error("Unable to resolve the pixel format stored in the *.ktx file!");
    }
    const kvData = loadKeyValueData ? parseKvData(dataView, bytesOfKeyValueData, littleEndian) : null;
    const imageByteSize = imagePixels * imagePixelByteSize;
    let mipByteSize = imageByteSize;
    let mipWidth = pixelWidth;
    let mipHeight = pixelHeight;
    let alignedMipWidth = alignedWidth;
    let alignedMipHeight = alignedHeight;
    let imageOffset = FILE_HEADER_SIZE + bytesOfKeyValueData;
    for (let mipmapLevel = 0; mipmapLevel < numberOfMipmapLevels; mipmapLevel++) {
      const imageSize = dataView.getUint32(imageOffset, littleEndian);
      let elementOffset = imageOffset + 4;
      for (let arrayElement = 0; arrayElement < numberOfArrayElements; arrayElement++) {
        let mips = imageBuffers[arrayElement];
        if (!mips) {
          mips = imageBuffers[arrayElement] = new Array(numberOfMipmapLevels);
        }
        mips[mipmapLevel] = {
          levelID: mipmapLevel,
          levelWidth: numberOfMipmapLevels > 1 || glType !== 0 ? mipWidth : alignedMipWidth,
          levelHeight: numberOfMipmapLevels > 1 || glType !== 0 ? mipHeight : alignedMipHeight,
          levelBuffer: new Uint8Array(arrayBuffer, elementOffset, mipByteSize)
        };
        elementOffset += mipByteSize;
      }
      imageOffset += imageSize + 4;
      imageOffset = imageOffset % 4 !== 0 ? imageOffset + 4 - imageOffset % 4 : imageOffset;
      mipWidth = mipWidth >> 1 || 1;
      mipHeight = mipHeight >> 1 || 1;
      alignedMipWidth = mipWidth + blockWidth - 1 & ~(blockWidth - 1);
      alignedMipHeight = mipHeight + blockHeight - 1 & ~(blockHeight - 1);
      mipByteSize = alignedMipWidth * alignedMipHeight * imagePixelByteSize;
    }
    if (glType !== 0) {
      return {
        uncompressed: imageBuffers.map((levelBuffers) => {
          let buffer = levelBuffers[0].levelBuffer;
          let convertToInt = false;
          if (glType === TYPES.FLOAT) {
            buffer = new Float32Array(levelBuffers[0].levelBuffer.buffer, levelBuffers[0].levelBuffer.byteOffset, levelBuffers[0].levelBuffer.byteLength / 4);
          } else if (glType === TYPES.UNSIGNED_INT) {
            convertToInt = true;
            buffer = new Uint32Array(levelBuffers[0].levelBuffer.buffer, levelBuffers[0].levelBuffer.byteOffset, levelBuffers[0].levelBuffer.byteLength / 4);
          } else if (glType === TYPES.INT) {
            convertToInt = true;
            buffer = new Int32Array(levelBuffers[0].levelBuffer.buffer, levelBuffers[0].levelBuffer.byteOffset, levelBuffers[0].levelBuffer.byteLength / 4);
          }
          return {
            resource: new BufferResource(buffer, {
              width: levelBuffers[0].levelWidth,
              height: levelBuffers[0].levelHeight
            }),
            type: glType,
            format: convertToInt ? convertFormatToInteger(glFormat) : glFormat
          };
        }),
        kvData
      };
    }
    return {
      compressed: imageBuffers.map((levelBuffers) => new CompressedTextureResource(null, {
        format: glInternalFormat,
        width: pixelWidth,
        height: pixelHeight,
        levels: numberOfMipmapLevels,
        levelBuffers
      })),
      kvData
    };
  }
  function validate(url2, dataView) {
    for (let i = 0; i < FILE_IDENTIFIER.length; i++) {
      if (dataView.getUint8(i) !== FILE_IDENTIFIER[i]) {
        console.error(`${url2} is not a valid *.ktx file!`);
        return false;
      }
    }
    return true;
  }
  function convertFormatToInteger(format2) {
    switch (format2) {
      case FORMATS.RGBA:
        return FORMATS.RGBA_INTEGER;
      case FORMATS.RGB:
        return FORMATS.RGB_INTEGER;
      case FORMATS.RG:
        return FORMATS.RG_INTEGER;
      case FORMATS.RED:
        return FORMATS.RED_INTEGER;
      default:
        return format2;
    }
  }
  function parseKvData(dataView, bytesOfKeyValueData, littleEndian) {
    const kvData = /* @__PURE__ */ new Map();
    let bytesIntoKeyValueData = 0;
    while (bytesIntoKeyValueData < bytesOfKeyValueData) {
      const keyAndValueByteSize = dataView.getUint32(FILE_HEADER_SIZE + bytesIntoKeyValueData, littleEndian);
      const keyAndValueByteOffset = FILE_HEADER_SIZE + bytesIntoKeyValueData + 4;
      const valuePadding = 3 - (keyAndValueByteSize + 3) % 4;
      if (keyAndValueByteSize === 0 || keyAndValueByteSize > bytesOfKeyValueData - bytesIntoKeyValueData) {
        console.error("KTXLoader: keyAndValueByteSize out of bounds");
        break;
      }
      let keyNulByte = 0;
      for (; keyNulByte < keyAndValueByteSize; keyNulByte++) {
        if (dataView.getUint8(keyAndValueByteOffset + keyNulByte) === 0) {
          break;
        }
      }
      if (keyNulByte === -1) {
        console.error("KTXLoader: Failed to find null byte terminating kvData key");
        break;
      }
      const key = new TextDecoder().decode(new Uint8Array(dataView.buffer, keyAndValueByteOffset, keyNulByte));
      const value = new DataView(dataView.buffer, keyAndValueByteOffset + keyNulByte + 1, keyAndValueByteSize - keyNulByte - 1);
      kvData.set(key, value);
      bytesIntoKeyValueData += 4 + keyAndValueByteSize + valuePadding;
    }
    return kvData;
  }

  // node_modules/pixijs/compressed-textures/loaders/loadDDS.mjs
  var loadDDS = {
    extension: {
      type: ExtensionType.LoadParser,
      priority: LoaderParserPriority.High
    },
    test(url2) {
      return checkExtension(url2, ".dds");
    },
    async load(url2, asset, loader) {
      const response = await settings.ADAPTER.fetch(url2);
      const arrayBuffer = await response.arrayBuffer();
      const resources = parseDDS(arrayBuffer);
      const textures = resources.map((resource) => {
        const base = new BaseTexture(resource, __spreadValues({
          mipmap: MIPMAP_MODES.OFF,
          alphaMode: ALPHA_MODES.NO_PREMULTIPLIED_ALPHA,
          resolution: utils_exports.getResolutionOfUrl(url2)
        }, asset.data));
        return createTexture(base, loader, url2);
      });
      return textures.length === 1 ? textures[0] : textures;
    },
    unload(texture) {
      if (Array.isArray(texture)) {
        texture.forEach((t) => t.destroy(true));
      } else {
        texture.destroy(true);
      }
    }
  };
  extensions.add(loadDDS);

  // node_modules/pixijs/compressed-textures/loaders/loadKTX.mjs
  var loadKTX = {
    extension: {
      type: ExtensionType.LoadParser,
      priority: LoaderParserPriority.High
    },
    test(url2) {
      return checkExtension(url2, ".ktx");
    },
    async load(url2, asset, loader) {
      const response = await settings.ADAPTER.fetch(url2);
      const arrayBuffer = await response.arrayBuffer();
      const { compressed, uncompressed, kvData } = parseKTX(url2, arrayBuffer);
      const resources = compressed != null ? compressed : uncompressed;
      const options = __spreadValues({
        mipmap: MIPMAP_MODES.OFF,
        alphaMode: ALPHA_MODES.NO_PREMULTIPLIED_ALPHA,
        resolution: utils_exports.getResolutionOfUrl(url2)
      }, asset.data);
      const textures = resources.map((resource) => {
        if (resources === uncompressed) {
          Object.assign(options, {
            type: resource.type,
            format: resource.format
          });
        }
        const base = new BaseTexture(resource, options);
        base.ktxKeyValueData = kvData;
        return createTexture(base, loader, url2);
      });
      return textures.length === 1 ? textures[0] : textures;
    },
    unload(texture) {
      if (Array.isArray(texture)) {
        texture.forEach((t) => t.destroy(true));
      } else {
        texture.destroy(true);
      }
    }
  };
  extensions.add(loadKTX);

  // node_modules/pixijs/compressed-textures/loaders/resolveCompressedTextureUrl.mjs
  var resolveCompressedTextureUrl = {
    extension: ExtensionType.ResolveParser,
    test: (value) => {
      const temp2 = value.split("?")[0];
      const extension = temp2.split(".").pop();
      return ["basis", "ktx", "dds"].includes(extension);
    },
    parse: (value) => {
      var _a, _b, _c, _d;
      const temp2 = value.split("?")[0];
      const extension = temp2.split(".").pop();
      if (extension === "ktx") {
        const extensions22 = [
          ".s3tc.ktx",
          ".s3tc_sRGB.ktx",
          ".etc.ktx",
          ".etc1.ktx",
          ".pvrt.ktx",
          ".atc.ktx",
          ".astc.ktx"
        ];
        if (extensions22.some((ext) => value.endsWith(ext))) {
          return {
            resolution: parseFloat((_b = (_a = settings.RETINA_PREFIX.exec(value)) == null ? void 0 : _a[1]) != null ? _b : "1"),
            format: extensions22.find((ext) => value.endsWith(ext)),
            src: value
          };
        }
      }
      return {
        resolution: parseFloat((_d = (_c = settings.RETINA_PREFIX.exec(value)) == null ? void 0 : _c[1]) != null ? _d : "1"),
        format: value.split(".").pop(),
        src: value
      };
    }
  };
  extensions.add(resolveCompressedTextureUrl);

  // node_modules/pixijs/extract/Extract.mjs
  var TEMP_RECT = new Rectangle();
  var BYTES_PER_PIXEL = 4;
  var _Extract = class {
    constructor(renderer) {
      this.renderer = renderer;
    }
    async image(target, format2, quality) {
      const image = new Image();
      image.src = await this.base64(target, format2, quality);
      return image;
    }
    async base64(target, format2, quality) {
      const canvas = this.canvas(target);
      if (canvas.toDataURL !== void 0) {
        return canvas.toDataURL(format2, quality);
      }
      if (canvas.convertToBlob !== void 0) {
        const blob = await canvas.convertToBlob({ type: format2, quality });
        return await new Promise((resolve2) => {
          const reader = new FileReader();
          reader.onload = () => resolve2(reader.result);
          reader.readAsDataURL(blob);
        });
      }
      throw new Error("Extract.base64() requires ICanvas.toDataURL or ICanvas.convertToBlob to be implemented");
    }
    canvas(target, frame2) {
      const renderer = this.renderer;
      let resolution;
      let flipY = false;
      let renderTexture;
      let generated = false;
      if (target) {
        if (target instanceof RenderTexture) {
          renderTexture = target;
        } else {
          renderTexture = this.renderer.generateTexture(target);
          generated = true;
        }
      }
      if (renderTexture) {
        resolution = renderTexture.baseTexture.resolution;
        frame2 = frame2 != null ? frame2 : renderTexture.frame;
        flipY = false;
        renderer.renderTexture.bind(renderTexture);
      } else {
        resolution = renderer.resolution;
        if (!frame2) {
          frame2 = TEMP_RECT;
          frame2.width = renderer.width;
          frame2.height = renderer.height;
        }
        flipY = true;
        renderer.renderTexture.bind(null);
      }
      const width = Math.round(frame2.width * resolution);
      const height = Math.round(frame2.height * resolution);
      let canvasBuffer = new utils_exports.CanvasRenderTarget(width, height, 1);
      const webglPixels = new Uint8Array(BYTES_PER_PIXEL * width * height);
      const gl = renderer.gl;
      gl.readPixels(Math.round(frame2.x * resolution), Math.round(frame2.y * resolution), width, height, gl.RGBA, gl.UNSIGNED_BYTE, webglPixels);
      const canvasData = canvasBuffer.context.getImageData(0, 0, width, height);
      _Extract.arrayPostDivide(webglPixels, canvasData.data);
      canvasBuffer.context.putImageData(canvasData, 0, 0);
      if (flipY) {
        const target2 = new utils_exports.CanvasRenderTarget(canvasBuffer.width, canvasBuffer.height, 1);
        target2.context.scale(1, -1);
        target2.context.drawImage(canvasBuffer.canvas, 0, -height);
        canvasBuffer.destroy();
        canvasBuffer = target2;
      }
      if (generated) {
        renderTexture.destroy(true);
      }
      return canvasBuffer.canvas;
    }
    pixels(target, frame2) {
      const renderer = this.renderer;
      let resolution;
      let renderTexture;
      let generated = false;
      if (target) {
        if (target instanceof RenderTexture) {
          renderTexture = target;
        } else {
          renderTexture = this.renderer.generateTexture(target);
          generated = true;
        }
      }
      if (renderTexture) {
        resolution = renderTexture.baseTexture.resolution;
        frame2 = frame2 != null ? frame2 : renderTexture.frame;
        renderer.renderTexture.bind(renderTexture);
      } else {
        resolution = renderer.resolution;
        if (!frame2) {
          frame2 = TEMP_RECT;
          frame2.width = renderer.width;
          frame2.height = renderer.height;
        }
        renderer.renderTexture.bind(null);
      }
      const width = Math.round(frame2.width * resolution);
      const height = Math.round(frame2.height * resolution);
      const webglPixels = new Uint8Array(BYTES_PER_PIXEL * width * height);
      const gl = renderer.gl;
      gl.readPixels(Math.round(frame2.x * resolution), Math.round(frame2.y * resolution), width, height, gl.RGBA, gl.UNSIGNED_BYTE, webglPixels);
      if (generated) {
        renderTexture.destroy(true);
      }
      _Extract.arrayPostDivide(webglPixels, webglPixels);
      return webglPixels;
    }
    destroy() {
      this.renderer = null;
    }
    static arrayPostDivide(pixels, out) {
      for (let i = 0; i < pixels.length; i += 4) {
        const alpha = out[i + 3] = pixels[i + 3];
        if (alpha !== 0) {
          out[i] = Math.round(Math.min(pixels[i] * 255 / alpha, 255));
          out[i + 1] = Math.round(Math.min(pixels[i + 1] * 255 / alpha, 255));
          out[i + 2] = Math.round(Math.min(pixels[i + 2] * 255 / alpha, 255));
        } else {
          out[i] = pixels[i];
          out[i + 1] = pixels[i + 1];
          out[i + 2] = pixels[i + 2];
        }
      }
    }
  };
  var Extract = _Extract;
  Extract.extension = {
    name: "extract",
    type: ExtensionType.RendererSystem
  };
  extensions.add(Extract);

  // node_modules/pixijs/graphics/utils/buildCircle.mjs
  var buildCircle = {
    build(graphicsData) {
      const points = graphicsData.points;
      let x3;
      let y3;
      let dx;
      let dy;
      let rx;
      let ry;
      if (graphicsData.type === SHAPES.CIRC) {
        const circle = graphicsData.shape;
        x3 = circle.x;
        y3 = circle.y;
        rx = ry = circle.radius;
        dx = dy = 0;
      } else if (graphicsData.type === SHAPES.ELIP) {
        const ellipse = graphicsData.shape;
        x3 = ellipse.x;
        y3 = ellipse.y;
        rx = ellipse.width;
        ry = ellipse.height;
        dx = dy = 0;
      } else {
        const roundedRect = graphicsData.shape;
        const halfWidth = roundedRect.width / 2;
        const halfHeight = roundedRect.height / 2;
        x3 = roundedRect.x + halfWidth;
        y3 = roundedRect.y + halfHeight;
        rx = ry = Math.max(0, Math.min(roundedRect.radius, Math.min(halfWidth, halfHeight)));
        dx = halfWidth - rx;
        dy = halfHeight - ry;
      }
      if (!(rx >= 0 && ry >= 0 && dx >= 0 && dy >= 0)) {
        points.length = 0;
        return;
      }
      const n = Math.ceil(2.3 * Math.sqrt(rx + ry));
      const m2 = n * 8 + (dx ? 4 : 0) + (dy ? 4 : 0);
      points.length = m2;
      if (m2 === 0) {
        return;
      }
      if (n === 0) {
        points.length = 8;
        points[0] = points[6] = x3 + dx;
        points[1] = points[3] = y3 + dy;
        points[2] = points[4] = x3 - dx;
        points[5] = points[7] = y3 - dy;
        return;
      }
      let j1 = 0;
      let j2 = n * 4 + (dx ? 2 : 0) + 2;
      let j3 = j2;
      let j4 = m2;
      {
        const x0 = dx + rx;
        const y0 = dy;
        const x1 = x3 + x0;
        const x22 = x3 - x0;
        const y1 = y3 + y0;
        points[j1++] = x1;
        points[j1++] = y1;
        points[--j2] = y1;
        points[--j2] = x22;
        if (dy) {
          const y22 = y3 - y0;
          points[j3++] = x22;
          points[j3++] = y22;
          points[--j4] = y22;
          points[--j4] = x1;
        }
      }
      for (let i = 1; i < n; i++) {
        const a2 = Math.PI / 2 * (i / n);
        const x0 = dx + Math.cos(a2) * rx;
        const y0 = dy + Math.sin(a2) * ry;
        const x1 = x3 + x0;
        const x22 = x3 - x0;
        const y1 = y3 + y0;
        const y22 = y3 - y0;
        points[j1++] = x1;
        points[j1++] = y1;
        points[--j2] = y1;
        points[--j2] = x22;
        points[j3++] = x22;
        points[j3++] = y22;
        points[--j4] = y22;
        points[--j4] = x1;
      }
      {
        const x0 = dx;
        const y0 = dy + ry;
        const x1 = x3 + x0;
        const x22 = x3 - x0;
        const y1 = y3 + y0;
        const y22 = y3 - y0;
        points[j1++] = x1;
        points[j1++] = y1;
        points[--j4] = y22;
        points[--j4] = x1;
        if (dx) {
          points[j1++] = x22;
          points[j1++] = y1;
          points[--j4] = y22;
          points[--j4] = x22;
        }
      }
    },
    triangulate(graphicsData, graphicsGeometry) {
      const points = graphicsData.points;
      const verts = graphicsGeometry.points;
      const indices2 = graphicsGeometry.indices;
      if (points.length === 0) {
        return;
      }
      let vertPos = verts.length / 2;
      const center = vertPos;
      let x3;
      let y3;
      if (graphicsData.type !== SHAPES.RREC) {
        const circle = graphicsData.shape;
        x3 = circle.x;
        y3 = circle.y;
      } else {
        const roundedRect = graphicsData.shape;
        x3 = roundedRect.x + roundedRect.width / 2;
        y3 = roundedRect.y + roundedRect.height / 2;
      }
      const matrix = graphicsData.matrix;
      verts.push(graphicsData.matrix ? matrix.a * x3 + matrix.c * y3 + matrix.tx : x3, graphicsData.matrix ? matrix.b * x3 + matrix.d * y3 + matrix.ty : y3);
      vertPos++;
      verts.push(points[0], points[1]);
      for (let i = 2; i < points.length; i += 2) {
        verts.push(points[i], points[i + 1]);
        indices2.push(vertPos++, center, vertPos);
      }
      indices2.push(center + 1, center, vertPos);
    }
  };

  // node_modules/pixijs/graphics/utils/buildPoly.mjs
  function fixOrientation(points, hole = false) {
    const m2 = points.length;
    if (m2 < 6) {
      return;
    }
    let area = 0;
    for (let i = 0, x1 = points[m2 - 2], y1 = points[m2 - 1]; i < m2; i += 2) {
      const x22 = points[i];
      const y22 = points[i + 1];
      area += (x22 - x1) * (y22 + y1);
      x1 = x22;
      y1 = y22;
    }
    if (!hole && area > 0 || hole && area <= 0) {
      const n = m2 / 2;
      for (let i = n + n % 2; i < m2; i += 2) {
        const i1 = m2 - i - 2;
        const i2 = m2 - i - 1;
        const i3 = i;
        const i4 = i + 1;
        [points[i1], points[i3]] = [points[i3], points[i1]];
        [points[i2], points[i4]] = [points[i4], points[i2]];
      }
    }
  }
  var buildPoly = {
    build(graphicsData) {
      graphicsData.points = graphicsData.shape.points.slice();
    },
    triangulate(graphicsData, graphicsGeometry) {
      let points = graphicsData.points;
      const holes = graphicsData.holes;
      const verts = graphicsGeometry.points;
      const indices2 = graphicsGeometry.indices;
      if (points.length >= 6) {
        fixOrientation(points, false);
        const holeArray = [];
        for (let i = 0; i < holes.length; i++) {
          const hole = holes[i];
          fixOrientation(hole.points, true);
          holeArray.push(points.length / 2);
          points = points.concat(hole.points);
        }
        const triangles = utils_exports.earcut(points, holeArray, 2);
        if (!triangles) {
          return;
        }
        const vertPos = verts.length / 2;
        for (let i = 0; i < triangles.length; i += 3) {
          indices2.push(triangles[i] + vertPos);
          indices2.push(triangles[i + 1] + vertPos);
          indices2.push(triangles[i + 2] + vertPos);
        }
        for (let i = 0; i < points.length; i++) {
          verts.push(points[i]);
        }
      }
    }
  };

  // node_modules/pixijs/graphics/utils/buildRectangle.mjs
  var buildRectangle = {
    build(graphicsData) {
      const rectData = graphicsData.shape;
      const x3 = rectData.x;
      const y3 = rectData.y;
      const width = rectData.width;
      const height = rectData.height;
      const points = graphicsData.points;
      points.length = 0;
      if (!(width >= 0 && height >= 0)) {
        return;
      }
      points.push(x3, y3, x3 + width, y3, x3 + width, y3 + height, x3, y3 + height);
    },
    triangulate(graphicsData, graphicsGeometry) {
      const points = graphicsData.points;
      const verts = graphicsGeometry.points;
      if (points.length === 0) {
        return;
      }
      const vertPos = verts.length / 2;
      verts.push(points[0], points[1], points[2], points[3], points[6], points[7], points[4], points[5]);
      graphicsGeometry.indices.push(vertPos, vertPos + 1, vertPos + 2, vertPos + 1, vertPos + 2, vertPos + 3);
    }
  };

  // node_modules/pixijs/graphics/utils/buildRoundedRectangle.mjs
  var buildRoundedRectangle = {
    build(graphicsData) {
      buildCircle.build(graphicsData);
    },
    triangulate(graphicsData, graphicsGeometry) {
      buildCircle.triangulate(graphicsData, graphicsGeometry);
    }
  };

  // node_modules/pixijs/graphics/const.mjs
  var LINE_JOIN = /* @__PURE__ */ ((LINE_JOIN2) => {
    LINE_JOIN2["MITER"] = "miter";
    LINE_JOIN2["BEVEL"] = "bevel";
    LINE_JOIN2["ROUND"] = "round";
    return LINE_JOIN2;
  })(LINE_JOIN || {});
  var LINE_CAP = /* @__PURE__ */ ((LINE_CAP2) => {
    LINE_CAP2["BUTT"] = "butt";
    LINE_CAP2["ROUND"] = "round";
    LINE_CAP2["SQUARE"] = "square";
    return LINE_CAP2;
  })(LINE_CAP || {});
  var curves = {
    adaptive: true,
    maxLength: 10,
    minSegments: 8,
    maxSegments: 2048,
    epsilon: 1e-4,
    _segmentsCount(length, defaultSegments = 20) {
      if (!this.adaptive || !length || isNaN(length)) {
        return defaultSegments;
      }
      let result = Math.ceil(length / this.maxLength);
      if (result < this.minSegments) {
        result = this.minSegments;
      } else if (result > this.maxSegments) {
        result = this.maxSegments;
      }
      return result;
    }
  };

  // node_modules/pixijs/graphics/utils/ArcUtils.mjs
  var ArcUtils = class {
    static curveTo(x1, y1, x22, y22, radius, points) {
      const fromX = points[points.length - 2];
      const fromY = points[points.length - 1];
      const a1 = fromY - y1;
      const b1 = fromX - x1;
      const a2 = y22 - y1;
      const b2 = x22 - x1;
      const mm = Math.abs(a1 * b2 - b1 * a2);
      if (mm < 1e-8 || radius === 0) {
        if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1) {
          points.push(x1, y1);
        }
        return null;
      }
      const dd = a1 * a1 + b1 * b1;
      const cc = a2 * a2 + b2 * b2;
      const tt = a1 * a2 + b1 * b2;
      const k1 = radius * Math.sqrt(dd) / mm;
      const k2 = radius * Math.sqrt(cc) / mm;
      const j1 = k1 * tt / dd;
      const j2 = k2 * tt / cc;
      const cx = k1 * b2 + k2 * b1;
      const cy = k1 * a2 + k2 * a1;
      const px = b1 * (k2 + j1);
      const py = a1 * (k2 + j1);
      const qx = b2 * (k1 + j2);
      const qy = a2 * (k1 + j2);
      const startAngle = Math.atan2(py - cy, px - cx);
      const endAngle = Math.atan2(qy - cy, qx - cx);
      return {
        cx: cx + x1,
        cy: cy + y1,
        radius,
        startAngle,
        endAngle,
        anticlockwise: b1 * a2 > b2 * a1
      };
    }
    static arc(_startX, _startY, cx, cy, radius, startAngle, endAngle, _anticlockwise, points) {
      const sweep = endAngle - startAngle;
      const n = curves._segmentsCount(Math.abs(sweep) * radius, Math.ceil(Math.abs(sweep) / PI_2) * 40);
      const theta = sweep / (n * 2);
      const theta2 = theta * 2;
      const cTheta = Math.cos(theta);
      const sTheta = Math.sin(theta);
      const segMinus = n - 1;
      const remainder = segMinus % 1 / segMinus;
      for (let i = 0; i <= segMinus; ++i) {
        const real = i + remainder * i;
        const angle = theta + startAngle + theta2 * real;
        const c2 = Math.cos(angle);
        const s = -Math.sin(angle);
        points.push((cTheta * c2 + sTheta * s) * radius + cx, (cTheta * -s + sTheta * c2) * radius + cy);
      }
    }
  };

  // node_modules/pixijs/graphics/utils/BatchPart.mjs
  var BatchPart = class {
    constructor() {
      this.reset();
    }
    begin(style, startIndex, attribStart) {
      this.reset();
      this.style = style;
      this.start = startIndex;
      this.attribStart = attribStart;
    }
    end(endIndex, endAttrib) {
      this.attribSize = endAttrib - this.attribStart;
      this.size = endIndex - this.start;
    }
    reset() {
      this.style = null;
      this.size = 0;
      this.start = 0;
      this.attribStart = 0;
      this.attribSize = 0;
    }
  };

  // node_modules/pixijs/graphics/utils/BezierUtils.mjs
  var BezierUtils = class {
    static curveLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY) {
      const n = 10;
      let result = 0;
      let t = 0;
      let t2 = 0;
      let t3 = 0;
      let nt = 0;
      let nt2 = 0;
      let nt3 = 0;
      let x3 = 0;
      let y3 = 0;
      let dx = 0;
      let dy = 0;
      let prevX = fromX;
      let prevY = fromY;
      for (let i = 1; i <= n; ++i) {
        t = i / n;
        t2 = t * t;
        t3 = t2 * t;
        nt = 1 - t;
        nt2 = nt * nt;
        nt3 = nt2 * nt;
        x3 = nt3 * fromX + 3 * nt2 * t * cpX + 3 * nt * t2 * cpX2 + t3 * toX;
        y3 = nt3 * fromY + 3 * nt2 * t * cpY + 3 * nt * t2 * cpY2 + t3 * toY;
        dx = prevX - x3;
        dy = prevY - y3;
        prevX = x3;
        prevY = y3;
        result += Math.sqrt(dx * dx + dy * dy);
      }
      return result;
    }
    static curveTo(cpX, cpY, cpX2, cpY2, toX, toY, points) {
      const fromX = points[points.length - 2];
      const fromY = points[points.length - 1];
      points.length -= 2;
      const n = curves._segmentsCount(BezierUtils.curveLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY));
      let dt = 0;
      let dt2 = 0;
      let dt3 = 0;
      let t2 = 0;
      let t3 = 0;
      points.push(fromX, fromY);
      for (let i = 1, j = 0; i <= n; ++i) {
        j = i / n;
        dt = 1 - j;
        dt2 = dt * dt;
        dt3 = dt2 * dt;
        t2 = j * j;
        t3 = t2 * j;
        points.push(dt3 * fromX + 3 * dt2 * j * cpX + 3 * dt * t2 * cpX2 + t3 * toX, dt3 * fromY + 3 * dt2 * j * cpY + 3 * dt * t2 * cpY2 + t3 * toY);
      }
    }
  };

  // node_modules/pixijs/graphics/utils/buildLine.mjs
  function square(x3, y3, nx, ny, innerWeight, outerWeight, clockwise, verts) {
    const ix = x3 - nx * innerWeight;
    const iy = y3 - ny * innerWeight;
    const ox = x3 + nx * outerWeight;
    const oy = y3 + ny * outerWeight;
    let exx;
    let eyy;
    if (clockwise) {
      exx = ny;
      eyy = -nx;
    } else {
      exx = -ny;
      eyy = nx;
    }
    const eix = ix + exx;
    const eiy = iy + eyy;
    const eox = ox + exx;
    const eoy = oy + eyy;
    verts.push(eix, eiy);
    verts.push(eox, eoy);
    return 2;
  }
  function round(cx, cy, sx, sy, ex, ey, verts, clockwise) {
    const cx2p0x = sx - cx;
    const cy2p0y = sy - cy;
    let angle0 = Math.atan2(cx2p0x, cy2p0y);
    let angle1 = Math.atan2(ex - cx, ey - cy);
    if (clockwise && angle0 < angle1) {
      angle0 += Math.PI * 2;
    } else if (!clockwise && angle0 > angle1) {
      angle1 += Math.PI * 2;
    }
    let startAngle = angle0;
    const angleDiff = angle1 - angle0;
    const absAngleDiff = Math.abs(angleDiff);
    const radius = Math.sqrt(cx2p0x * cx2p0x + cy2p0y * cy2p0y);
    const segCount = (15 * absAngleDiff * Math.sqrt(radius) / Math.PI >> 0) + 1;
    const angleInc = angleDiff / segCount;
    startAngle += angleInc;
    if (clockwise) {
      verts.push(cx, cy);
      verts.push(sx, sy);
      for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc) {
        verts.push(cx, cy);
        verts.push(cx + Math.sin(angle) * radius, cy + Math.cos(angle) * radius);
      }
      verts.push(cx, cy);
      verts.push(ex, ey);
    } else {
      verts.push(sx, sy);
      verts.push(cx, cy);
      for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc) {
        verts.push(cx + Math.sin(angle) * radius, cy + Math.cos(angle) * radius);
        verts.push(cx, cy);
      }
      verts.push(ex, ey);
      verts.push(cx, cy);
    }
    return segCount * 2;
  }
  function buildNonNativeLine(graphicsData, graphicsGeometry) {
    const shape = graphicsData.shape;
    let points = graphicsData.points || shape.points.slice();
    const eps = graphicsGeometry.closePointEps;
    if (points.length === 0) {
      return;
    }
    const style = graphicsData.lineStyle;
    const firstPoint = new Point(points[0], points[1]);
    const lastPoint = new Point(points[points.length - 2], points[points.length - 1]);
    const closedShape = shape.type !== SHAPES.POLY || shape.closeStroke;
    const closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps && Math.abs(firstPoint.y - lastPoint.y) < eps;
    if (closedShape) {
      points = points.slice();
      if (closedPath) {
        points.pop();
        points.pop();
        lastPoint.set(points[points.length - 2], points[points.length - 1]);
      }
      const midPointX = (firstPoint.x + lastPoint.x) * 0.5;
      const midPointY = (lastPoint.y + firstPoint.y) * 0.5;
      points.unshift(midPointX, midPointY);
      points.push(midPointX, midPointY);
    }
    const verts = graphicsGeometry.points;
    const length = points.length / 2;
    let indexCount = points.length;
    const indexStart = verts.length / 2;
    const width = style.width / 2;
    const widthSquared = width * width;
    const miterLimitSquared = style.miterLimit * style.miterLimit;
    let x0 = points[0];
    let y0 = points[1];
    let x1 = points[2];
    let y1 = points[3];
    let x22 = 0;
    let y22 = 0;
    let perpx = -(y0 - y1);
    let perpy = x0 - x1;
    let perp1x = 0;
    let perp1y = 0;
    let dist = Math.sqrt(perpx * perpx + perpy * perpy);
    perpx /= dist;
    perpy /= dist;
    perpx *= width;
    perpy *= width;
    const ratio = style.alignment;
    const innerWeight = (1 - ratio) * 2;
    const outerWeight = ratio * 2;
    if (!closedShape) {
      if (style.cap === LINE_CAP.ROUND) {
        indexCount += round(x0 - perpx * (innerWeight - outerWeight) * 0.5, y0 - perpy * (innerWeight - outerWeight) * 0.5, x0 - perpx * innerWeight, y0 - perpy * innerWeight, x0 + perpx * outerWeight, y0 + perpy * outerWeight, verts, true) + 2;
      } else if (style.cap === LINE_CAP.SQUARE) {
        indexCount += square(x0, y0, perpx, perpy, innerWeight, outerWeight, true, verts);
      }
    }
    verts.push(x0 - perpx * innerWeight, y0 - perpy * innerWeight);
    verts.push(x0 + perpx * outerWeight, y0 + perpy * outerWeight);
    for (let i = 1; i < length - 1; ++i) {
      x0 = points[(i - 1) * 2];
      y0 = points[(i - 1) * 2 + 1];
      x1 = points[i * 2];
      y1 = points[i * 2 + 1];
      x22 = points[(i + 1) * 2];
      y22 = points[(i + 1) * 2 + 1];
      perpx = -(y0 - y1);
      perpy = x0 - x1;
      dist = Math.sqrt(perpx * perpx + perpy * perpy);
      perpx /= dist;
      perpy /= dist;
      perpx *= width;
      perpy *= width;
      perp1x = -(y1 - y22);
      perp1y = x1 - x22;
      dist = Math.sqrt(perp1x * perp1x + perp1y * perp1y);
      perp1x /= dist;
      perp1y /= dist;
      perp1x *= width;
      perp1y *= width;
      const dx0 = x1 - x0;
      const dy0 = y0 - y1;
      const dx1 = x1 - x22;
      const dy1 = y22 - y1;
      const dot = dx0 * dx1 + dy0 * dy1;
      const cross = dy0 * dx1 - dy1 * dx0;
      const clockwise = cross < 0;
      if (Math.abs(cross) < 1e-3 * Math.abs(dot)) {
        verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight);
        verts.push(x1 + perpx * outerWeight, y1 + perpy * outerWeight);
        if (dot >= 0) {
          if (style.join === LINE_JOIN.ROUND) {
            indexCount += round(x1, y1, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, false) + 4;
          } else {
            indexCount += 2;
          }
          verts.push(x1 - perp1x * outerWeight, y1 - perp1y * outerWeight);
          verts.push(x1 + perp1x * innerWeight, y1 + perp1y * innerWeight);
        }
        continue;
      }
      const c1 = (-perpx + x0) * (-perpy + y1) - (-perpx + x1) * (-perpy + y0);
      const c2 = (-perp1x + x22) * (-perp1y + y1) - (-perp1x + x1) * (-perp1y + y22);
      const px = (dx0 * c2 - dx1 * c1) / cross;
      const py = (dy1 * c1 - dy0 * c2) / cross;
      const pdist = (px - x1) * (px - x1) + (py - y1) * (py - y1);
      const imx = x1 + (px - x1) * innerWeight;
      const imy = y1 + (py - y1) * innerWeight;
      const omx = x1 - (px - x1) * outerWeight;
      const omy = y1 - (py - y1) * outerWeight;
      const smallerInsideSegmentSq = Math.min(dx0 * dx0 + dy0 * dy0, dx1 * dx1 + dy1 * dy1);
      const insideWeight = clockwise ? innerWeight : outerWeight;
      const smallerInsideDiagonalSq = smallerInsideSegmentSq + insideWeight * insideWeight * widthSquared;
      const insideMiterOk = pdist <= smallerInsideDiagonalSq;
      if (insideMiterOk) {
        if (style.join === LINE_JOIN.BEVEL || pdist / widthSquared > miterLimitSquared) {
          if (clockwise) {
            verts.push(imx, imy);
            verts.push(x1 + perpx * outerWeight, y1 + perpy * outerWeight);
            verts.push(imx, imy);
            verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
          } else {
            verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight);
            verts.push(omx, omy);
            verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);
            verts.push(omx, omy);
          }
          indexCount += 2;
        } else if (style.join === LINE_JOIN.ROUND) {
          if (clockwise) {
            verts.push(imx, imy);
            verts.push(x1 + perpx * outerWeight, y1 + perpy * outerWeight);
            indexCount += round(x1, y1, x1 + perpx * outerWeight, y1 + perpy * outerWeight, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight, verts, true) + 4;
            verts.push(imx, imy);
            verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
          } else {
            verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight);
            verts.push(omx, omy);
            indexCount += round(x1, y1, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, false) + 4;
            verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);
            verts.push(omx, omy);
          }
        } else {
          verts.push(imx, imy);
          verts.push(omx, omy);
        }
      } else {
        verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight);
        verts.push(x1 + perpx * outerWeight, y1 + perpy * outerWeight);
        if (style.join === LINE_JOIN.ROUND) {
          if (clockwise) {
            indexCount += round(x1, y1, x1 + perpx * outerWeight, y1 + perpy * outerWeight, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight, verts, true) + 2;
          } else {
            indexCount += round(x1, y1, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, false) + 2;
          }
        } else if (style.join === LINE_JOIN.MITER && pdist / widthSquared <= miterLimitSquared) {
          if (clockwise) {
            verts.push(omx, omy);
            verts.push(omx, omy);
          } else {
            verts.push(imx, imy);
            verts.push(imx, imy);
          }
          indexCount += 2;
        }
        verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);
        verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
        indexCount += 2;
      }
    }
    x0 = points[(length - 2) * 2];
    y0 = points[(length - 2) * 2 + 1];
    x1 = points[(length - 1) * 2];
    y1 = points[(length - 1) * 2 + 1];
    perpx = -(y0 - y1);
    perpy = x0 - x1;
    dist = Math.sqrt(perpx * perpx + perpy * perpy);
    perpx /= dist;
    perpy /= dist;
    perpx *= width;
    perpy *= width;
    verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight);
    verts.push(x1 + perpx * outerWeight, y1 + perpy * outerWeight);
    if (!closedShape) {
      if (style.cap === LINE_CAP.ROUND) {
        indexCount += round(x1 - perpx * (innerWeight - outerWeight) * 0.5, y1 - perpy * (innerWeight - outerWeight) * 0.5, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 + perpx * outerWeight, y1 + perpy * outerWeight, verts, false) + 2;
      } else if (style.cap === LINE_CAP.SQUARE) {
        indexCount += square(x1, y1, perpx, perpy, innerWeight, outerWeight, false, verts);
      }
    }
    const indices2 = graphicsGeometry.indices;
    const eps2 = curves.epsilon * curves.epsilon;
    for (let i = indexStart; i < indexCount + indexStart - 2; ++i) {
      x0 = verts[i * 2];
      y0 = verts[i * 2 + 1];
      x1 = verts[(i + 1) * 2];
      y1 = verts[(i + 1) * 2 + 1];
      x22 = verts[(i + 2) * 2];
      y22 = verts[(i + 2) * 2 + 1];
      if (Math.abs(x0 * (y1 - y22) + x1 * (y22 - y0) + x22 * (y0 - y1)) < eps2) {
        continue;
      }
      indices2.push(i, i + 1, i + 2);
    }
  }
  function buildNativeLine(graphicsData, graphicsGeometry) {
    let i = 0;
    const shape = graphicsData.shape;
    const points = graphicsData.points || shape.points;
    const closedShape = shape.type !== SHAPES.POLY || shape.closeStroke;
    if (points.length === 0)
      return;
    const verts = graphicsGeometry.points;
    const indices2 = graphicsGeometry.indices;
    const length = points.length / 2;
    const startIndex = verts.length / 2;
    let currentIndex = startIndex;
    verts.push(points[0], points[1]);
    for (i = 1; i < length; i++) {
      verts.push(points[i * 2], points[i * 2 + 1]);
      indices2.push(currentIndex, currentIndex + 1);
      currentIndex++;
    }
    if (closedShape) {
      indices2.push(currentIndex, startIndex);
    }
  }
  function buildLine(graphicsData, graphicsGeometry) {
    if (graphicsData.lineStyle.native) {
      buildNativeLine(graphicsData, graphicsGeometry);
    } else {
      buildNonNativeLine(graphicsData, graphicsGeometry);
    }
  }

  // node_modules/pixijs/graphics/utils/QuadraticUtils.mjs
  var QuadraticUtils = class {
    static curveLength(fromX, fromY, cpX, cpY, toX, toY) {
      const ax = fromX - 2 * cpX + toX;
      const ay = fromY - 2 * cpY + toY;
      const bx = 2 * cpX - 2 * fromX;
      const by = 2 * cpY - 2 * fromY;
      const a2 = 4 * (ax * ax + ay * ay);
      const b = 4 * (ax * bx + ay * by);
      const c2 = bx * bx + by * by;
      const s = 2 * Math.sqrt(a2 + b + c2);
      const a22 = Math.sqrt(a2);
      const a32 = 2 * a2 * a22;
      const c22 = 2 * Math.sqrt(c2);
      const ba = b / a22;
      return (a32 * s + a22 * b * (s - c22) + (4 * c2 * a2 - b * b) * Math.log((2 * a22 + ba + s) / (ba + c22))) / (4 * a32);
    }
    static curveTo(cpX, cpY, toX, toY, points) {
      const fromX = points[points.length - 2];
      const fromY = points[points.length - 1];
      const n = curves._segmentsCount(QuadraticUtils.curveLength(fromX, fromY, cpX, cpY, toX, toY));
      let xa = 0;
      let ya = 0;
      for (let i = 1; i <= n; ++i) {
        const j = i / n;
        xa = fromX + (cpX - fromX) * j;
        ya = fromY + (cpY - fromY) * j;
        points.push(xa + (cpX + (toX - cpX) * j - xa) * j, ya + (cpY + (toY - cpY) * j - ya) * j);
      }
    }
  };

  // node_modules/pixijs/graphics/utils/index.mjs
  var FILL_COMMANDS = {
    [SHAPES.POLY]: buildPoly,
    [SHAPES.CIRC]: buildCircle,
    [SHAPES.ELIP]: buildCircle,
    [SHAPES.RECT]: buildRectangle,
    [SHAPES.RREC]: buildRoundedRectangle
  };
  var BATCH_POOL = [];
  var DRAW_CALL_POOL = [];

  // node_modules/pixijs/graphics/GraphicsData.mjs
  var GraphicsData = class {
    constructor(shape, fillStyle = null, lineStyle = null, matrix = null) {
      this.points = [];
      this.holes = [];
      this.shape = shape;
      this.lineStyle = lineStyle;
      this.fillStyle = fillStyle;
      this.matrix = matrix;
      this.type = shape.type;
    }
    clone() {
      return new GraphicsData(this.shape, this.fillStyle, this.lineStyle, this.matrix);
    }
    destroy() {
      this.shape = null;
      this.holes.length = 0;
      this.holes = null;
      this.points.length = 0;
      this.points = null;
      this.lineStyle = null;
      this.fillStyle = null;
    }
  };

  // node_modules/pixijs/graphics/GraphicsGeometry.mjs
  var tmpPoint = new Point();
  var _GraphicsGeometry = class extends BatchGeometry {
    constructor() {
      super();
      this.closePointEps = 1e-4;
      this.boundsPadding = 0;
      this.uvsFloat32 = null;
      this.indicesUint16 = null;
      this.batchable = false;
      this.points = [];
      this.colors = [];
      this.uvs = [];
      this.indices = [];
      this.textureIds = [];
      this.graphicsData = [];
      this.drawCalls = [];
      this.batchDirty = -1;
      this.batches = [];
      this.dirty = 0;
      this.cacheDirty = -1;
      this.clearDirty = 0;
      this.shapeIndex = 0;
      this._bounds = new Bounds();
      this.boundsDirty = -1;
    }
    get bounds() {
      this.updateBatches();
      if (this.boundsDirty !== this.dirty) {
        this.boundsDirty = this.dirty;
        this.calculateBounds();
      }
      return this._bounds;
    }
    invalidate() {
      this.boundsDirty = -1;
      this.dirty++;
      this.batchDirty++;
      this.shapeIndex = 0;
      this.points.length = 0;
      this.colors.length = 0;
      this.uvs.length = 0;
      this.indices.length = 0;
      this.textureIds.length = 0;
      for (let i = 0; i < this.drawCalls.length; i++) {
        this.drawCalls[i].texArray.clear();
        DRAW_CALL_POOL.push(this.drawCalls[i]);
      }
      this.drawCalls.length = 0;
      for (let i = 0; i < this.batches.length; i++) {
        const batchPart = this.batches[i];
        batchPart.reset();
        BATCH_POOL.push(batchPart);
      }
      this.batches.length = 0;
    }
    clear() {
      if (this.graphicsData.length > 0) {
        this.invalidate();
        this.clearDirty++;
        this.graphicsData.length = 0;
      }
      return this;
    }
    drawShape(shape, fillStyle = null, lineStyle = null, matrix = null) {
      const data = new GraphicsData(shape, fillStyle, lineStyle, matrix);
      this.graphicsData.push(data);
      this.dirty++;
      return this;
    }
    drawHole(shape, matrix = null) {
      if (!this.graphicsData.length) {
        return null;
      }
      const data = new GraphicsData(shape, null, null, matrix);
      const lastShape = this.graphicsData[this.graphicsData.length - 1];
      data.lineStyle = lastShape.lineStyle;
      lastShape.holes.push(data);
      this.dirty++;
      return this;
    }
    destroy() {
      super.destroy();
      for (let i = 0; i < this.graphicsData.length; ++i) {
        this.graphicsData[i].destroy();
      }
      this.points.length = 0;
      this.points = null;
      this.colors.length = 0;
      this.colors = null;
      this.uvs.length = 0;
      this.uvs = null;
      this.indices.length = 0;
      this.indices = null;
      this.indexBuffer.destroy();
      this.indexBuffer = null;
      this.graphicsData.length = 0;
      this.graphicsData = null;
      this.drawCalls.length = 0;
      this.drawCalls = null;
      this.batches.length = 0;
      this.batches = null;
      this._bounds = null;
    }
    containsPoint(point) {
      const graphicsData = this.graphicsData;
      for (let i = 0; i < graphicsData.length; ++i) {
        const data = graphicsData[i];
        if (!data.fillStyle.visible) {
          continue;
        }
        if (data.shape) {
          if (data.matrix) {
            data.matrix.applyInverse(point, tmpPoint);
          } else {
            tmpPoint.copyFrom(point);
          }
          if (data.shape.contains(tmpPoint.x, tmpPoint.y)) {
            let hitHole = false;
            if (data.holes) {
              for (let i2 = 0; i2 < data.holes.length; i2++) {
                const hole = data.holes[i2];
                if (hole.shape.contains(tmpPoint.x, tmpPoint.y)) {
                  hitHole = true;
                  break;
                }
              }
            }
            if (!hitHole) {
              return true;
            }
          }
        }
      }
      return false;
    }
    updateBatches() {
      if (!this.graphicsData.length) {
        this.batchable = true;
        return;
      }
      if (!this.validateBatching()) {
        return;
      }
      this.cacheDirty = this.dirty;
      const uvs = this.uvs;
      const graphicsData = this.graphicsData;
      let batchPart = null;
      let currentStyle = null;
      if (this.batches.length > 0) {
        batchPart = this.batches[this.batches.length - 1];
        currentStyle = batchPart.style;
      }
      for (let i = this.shapeIndex; i < graphicsData.length; i++) {
        this.shapeIndex++;
        const data = graphicsData[i];
        const fillStyle = data.fillStyle;
        const lineStyle = data.lineStyle;
        const command = FILL_COMMANDS[data.type];
        command.build(data);
        if (data.matrix) {
          this.transformPoints(data.points, data.matrix);
        }
        if (fillStyle.visible || lineStyle.visible) {
          this.processHoles(data.holes);
        }
        for (let j = 0; j < 2; j++) {
          const style = j === 0 ? fillStyle : lineStyle;
          if (!style.visible)
            continue;
          const nextTexture = style.texture.baseTexture;
          const index22 = this.indices.length;
          const attribIndex = this.points.length / 2;
          nextTexture.wrapMode = WRAP_MODES.REPEAT;
          if (j === 0) {
            this.processFill(data);
          } else {
            this.processLine(data);
          }
          const size = this.points.length / 2 - attribIndex;
          if (size === 0)
            continue;
          if (batchPart && !this._compareStyles(currentStyle, style)) {
            batchPart.end(index22, attribIndex);
            batchPart = null;
          }
          if (!batchPart) {
            batchPart = BATCH_POOL.pop() || new BatchPart();
            batchPart.begin(style, index22, attribIndex);
            this.batches.push(batchPart);
            currentStyle = style;
          }
          this.addUvs(this.points, uvs, style.texture, attribIndex, size, style.matrix);
        }
      }
      const index2 = this.indices.length;
      const attrib = this.points.length / 2;
      if (batchPart) {
        batchPart.end(index2, attrib);
      }
      if (this.batches.length === 0) {
        this.batchable = true;
        return;
      }
      const need32 = attrib > 65535;
      if (this.indicesUint16 && this.indices.length === this.indicesUint16.length && need32 === this.indicesUint16.BYTES_PER_ELEMENT > 2) {
        this.indicesUint16.set(this.indices);
      } else {
        this.indicesUint16 = need32 ? new Uint32Array(this.indices) : new Uint16Array(this.indices);
      }
      this.batchable = this.isBatchable();
      if (this.batchable) {
        this.packBatches();
      } else {
        this.buildDrawCalls();
      }
    }
    _compareStyles(styleA, styleB) {
      if (!styleA || !styleB) {
        return false;
      }
      if (styleA.texture.baseTexture !== styleB.texture.baseTexture) {
        return false;
      }
      if (styleA.color + styleA.alpha !== styleB.color + styleB.alpha) {
        return false;
      }
      if (!!styleA.native !== !!styleB.native) {
        return false;
      }
      return true;
    }
    validateBatching() {
      if (this.dirty === this.cacheDirty || !this.graphicsData.length) {
        return false;
      }
      for (let i = 0, l = this.graphicsData.length; i < l; i++) {
        const data = this.graphicsData[i];
        const fill = data.fillStyle;
        const line = data.lineStyle;
        if (fill && !fill.texture.baseTexture.valid)
          return false;
        if (line && !line.texture.baseTexture.valid)
          return false;
      }
      return true;
    }
    packBatches() {
      this.batchDirty++;
      this.uvsFloat32 = new Float32Array(this.uvs);
      const batches = this.batches;
      for (let i = 0, l = batches.length; i < l; i++) {
        const batch = batches[i];
        for (let j = 0; j < batch.size; j++) {
          const index2 = batch.start + j;
          this.indicesUint16[index2] = this.indicesUint16[index2] - batch.attribStart;
        }
      }
    }
    isBatchable() {
      if (this.points.length > 65535 * 2) {
        return false;
      }
      const batches = this.batches;
      for (let i = 0; i < batches.length; i++) {
        if (batches[i].style.native) {
          return false;
        }
      }
      return this.points.length < _GraphicsGeometry.BATCHABLE_SIZE * 2;
    }
    buildDrawCalls() {
      let TICK = ++BaseTexture._globalBatch;
      for (let i = 0; i < this.drawCalls.length; i++) {
        this.drawCalls[i].texArray.clear();
        DRAW_CALL_POOL.push(this.drawCalls[i]);
      }
      this.drawCalls.length = 0;
      const colors = this.colors;
      const textureIds = this.textureIds;
      let currentGroup = DRAW_CALL_POOL.pop();
      if (!currentGroup) {
        currentGroup = new BatchDrawCall();
        currentGroup.texArray = new BatchTextureArray();
      }
      currentGroup.texArray.count = 0;
      currentGroup.start = 0;
      currentGroup.size = 0;
      currentGroup.type = DRAW_MODES.TRIANGLES;
      let textureCount = 0;
      let currentTexture = null;
      let textureId = 0;
      let native = false;
      let drawMode = DRAW_MODES.TRIANGLES;
      let index2 = 0;
      this.drawCalls.push(currentGroup);
      for (let i = 0; i < this.batches.length; i++) {
        const data = this.batches[i];
        const maxTextures = 8;
        const style = data.style;
        const nextTexture = style.texture.baseTexture;
        if (native !== !!style.native) {
          native = !!style.native;
          drawMode = native ? DRAW_MODES.LINES : DRAW_MODES.TRIANGLES;
          currentTexture = null;
          textureCount = maxTextures;
          TICK++;
        }
        if (currentTexture !== nextTexture) {
          currentTexture = nextTexture;
          if (nextTexture._batchEnabled !== TICK) {
            if (textureCount === maxTextures) {
              TICK++;
              textureCount = 0;
              if (currentGroup.size > 0) {
                currentGroup = DRAW_CALL_POOL.pop();
                if (!currentGroup) {
                  currentGroup = new BatchDrawCall();
                  currentGroup.texArray = new BatchTextureArray();
                }
                this.drawCalls.push(currentGroup);
              }
              currentGroup.start = index2;
              currentGroup.size = 0;
              currentGroup.texArray.count = 0;
              currentGroup.type = drawMode;
            }
            nextTexture.touched = 1;
            nextTexture._batchEnabled = TICK;
            nextTexture._batchLocation = textureCount;
            nextTexture.wrapMode = WRAP_MODES.REPEAT;
            currentGroup.texArray.elements[currentGroup.texArray.count++] = nextTexture;
            textureCount++;
          }
        }
        currentGroup.size += data.size;
        index2 += data.size;
        textureId = nextTexture._batchLocation;
        this.addColors(colors, style.color, style.alpha, data.attribSize, data.attribStart);
        this.addTextureIds(textureIds, textureId, data.attribSize, data.attribStart);
      }
      BaseTexture._globalBatch = TICK;
      this.packAttributes();
    }
    packAttributes() {
      const verts = this.points;
      const uvs = this.uvs;
      const colors = this.colors;
      const textureIds = this.textureIds;
      const glPoints = new ArrayBuffer(verts.length * 3 * 4);
      const f32 = new Float32Array(glPoints);
      const u32 = new Uint32Array(glPoints);
      let p = 0;
      for (let i = 0; i < verts.length / 2; i++) {
        f32[p++] = verts[i * 2];
        f32[p++] = verts[i * 2 + 1];
        f32[p++] = uvs[i * 2];
        f32[p++] = uvs[i * 2 + 1];
        u32[p++] = colors[i];
        f32[p++] = textureIds[i];
      }
      this._buffer.update(glPoints);
      this._indexBuffer.update(this.indicesUint16);
    }
    processFill(data) {
      if (data.holes.length) {
        buildPoly.triangulate(data, this);
      } else {
        const command = FILL_COMMANDS[data.type];
        command.triangulate(data, this);
      }
    }
    processLine(data) {
      buildLine(data, this);
      for (let i = 0; i < data.holes.length; i++) {
        buildLine(data.holes[i], this);
      }
    }
    processHoles(holes) {
      for (let i = 0; i < holes.length; i++) {
        const hole = holes[i];
        const command = FILL_COMMANDS[hole.type];
        command.build(hole);
        if (hole.matrix) {
          this.transformPoints(hole.points, hole.matrix);
        }
      }
    }
    calculateBounds() {
      const bounds = this._bounds;
      bounds.clear();
      bounds.addVertexData(this.points, 0, this.points.length);
      bounds.pad(this.boundsPadding, this.boundsPadding);
    }
    transformPoints(points, matrix) {
      for (let i = 0; i < points.length / 2; i++) {
        const x3 = points[i * 2];
        const y3 = points[i * 2 + 1];
        points[i * 2] = matrix.a * x3 + matrix.c * y3 + matrix.tx;
        points[i * 2 + 1] = matrix.b * x3 + matrix.d * y3 + matrix.ty;
      }
    }
    addColors(colors, color2, alpha, size, offset = 0) {
      const rgb2 = (color2 >> 16) + (color2 & 65280) + ((color2 & 255) << 16);
      const rgba2 = utils_exports.premultiplyTint(rgb2, alpha);
      colors.length = Math.max(colors.length, offset + size);
      for (let i = 0; i < size; i++) {
        colors[offset + i] = rgba2;
      }
    }
    addTextureIds(textureIds, id2, size, offset = 0) {
      textureIds.length = Math.max(textureIds.length, offset + size);
      for (let i = 0; i < size; i++) {
        textureIds[offset + i] = id2;
      }
    }
    addUvs(verts, uvs, texture, start2, size, matrix = null) {
      let index2 = 0;
      const uvsStart = uvs.length;
      const frame2 = texture.frame;
      while (index2 < size) {
        let x3 = verts[(start2 + index2) * 2];
        let y3 = verts[(start2 + index2) * 2 + 1];
        if (matrix) {
          const nx = matrix.a * x3 + matrix.c * y3 + matrix.tx;
          y3 = matrix.b * x3 + matrix.d * y3 + matrix.ty;
          x3 = nx;
        }
        index2++;
        uvs.push(x3 / frame2.width, y3 / frame2.height);
      }
      const baseTexture = texture.baseTexture;
      if (frame2.width < baseTexture.width || frame2.height < baseTexture.height) {
        this.adjustUvs(uvs, texture, uvsStart, size);
      }
    }
    adjustUvs(uvs, texture, start2, size) {
      const baseTexture = texture.baseTexture;
      const eps = 1e-6;
      const finish = start2 + size * 2;
      const frame2 = texture.frame;
      const scaleX = frame2.width / baseTexture.width;
      const scaleY = frame2.height / baseTexture.height;
      let offsetX = frame2.x / frame2.width;
      let offsetY = frame2.y / frame2.height;
      let minX = Math.floor(uvs[start2] + eps);
      let minY = Math.floor(uvs[start2 + 1] + eps);
      for (let i = start2 + 2; i < finish; i += 2) {
        minX = Math.min(minX, Math.floor(uvs[i] + eps));
        minY = Math.min(minY, Math.floor(uvs[i + 1] + eps));
      }
      offsetX -= minX;
      offsetY -= minY;
      for (let i = start2; i < finish; i += 2) {
        uvs[i] = (uvs[i] + offsetX) * scaleX;
        uvs[i + 1] = (uvs[i + 1] + offsetY) * scaleY;
      }
    }
  };
  var GraphicsGeometry = _GraphicsGeometry;
  GraphicsGeometry.BATCHABLE_SIZE = 100;

  // node_modules/pixijs/graphics/styles/FillStyle.mjs
  var FillStyle = class {
    constructor() {
      this.color = 16777215;
      this.alpha = 1;
      this.texture = Texture.WHITE;
      this.matrix = null;
      this.visible = false;
      this.reset();
    }
    clone() {
      const obj = new FillStyle();
      obj.color = this.color;
      obj.alpha = this.alpha;
      obj.texture = this.texture;
      obj.matrix = this.matrix;
      obj.visible = this.visible;
      return obj;
    }
    reset() {
      this.color = 16777215;
      this.alpha = 1;
      this.texture = Texture.WHITE;
      this.matrix = null;
      this.visible = false;
    }
    destroy() {
      this.texture = null;
      this.matrix = null;
    }
  };

  // node_modules/pixijs/graphics/styles/LineStyle.mjs
  var LineStyle = class extends FillStyle {
    constructor() {
      super(...arguments);
      this.width = 0;
      this.alignment = 0.5;
      this.native = false;
      this.cap = LINE_CAP.BUTT;
      this.join = LINE_JOIN.MITER;
      this.miterLimit = 10;
    }
    clone() {
      const obj = new LineStyle();
      obj.color = this.color;
      obj.alpha = this.alpha;
      obj.texture = this.texture;
      obj.matrix = this.matrix;
      obj.visible = this.visible;
      obj.width = this.width;
      obj.alignment = this.alignment;
      obj.native = this.native;
      obj.cap = this.cap;
      obj.join = this.join;
      obj.miterLimit = this.miterLimit;
      return obj;
    }
    reset() {
      super.reset();
      this.color = 0;
      this.alignment = 0.5;
      this.width = 0;
      this.native = false;
    }
  };

  // node_modules/pixijs/graphics/Graphics.mjs
  var temp = new Float32Array(3);
  var DEFAULT_SHADERS = {};
  var _Graphics = class extends Container {
    constructor(geometry = null) {
      super();
      this.shader = null;
      this.pluginName = "batch";
      this.currentPath = null;
      this.batches = [];
      this.batchTint = -1;
      this.batchDirty = -1;
      this.vertexData = null;
      this._fillStyle = new FillStyle();
      this._lineStyle = new LineStyle();
      this._matrix = null;
      this._holeMode = false;
      this.state = State.for2d();
      this._geometry = geometry || new GraphicsGeometry();
      this._geometry.refCount++;
      this._transformID = -1;
      this.tint = 16777215;
      this.blendMode = BLEND_MODES.NORMAL;
    }
    get geometry() {
      return this._geometry;
    }
    clone() {
      this.finishPoly();
      return new _Graphics(this._geometry);
    }
    set blendMode(value) {
      this.state.blendMode = value;
    }
    get blendMode() {
      return this.state.blendMode;
    }
    get tint() {
      return this._tint;
    }
    set tint(value) {
      this._tint = value;
    }
    get fill() {
      return this._fillStyle;
    }
    get line() {
      return this._lineStyle;
    }
    lineStyle(options = null, color2 = 0, alpha = 1, alignment = 0.5, native = false) {
      if (typeof options === "number") {
        options = { width: options, color: color2, alpha, alignment, native };
      }
      return this.lineTextureStyle(options);
    }
    lineTextureStyle(options) {
      options = Object.assign({
        width: 0,
        texture: Texture.WHITE,
        color: (options == null ? void 0 : options.texture) ? 16777215 : 0,
        alpha: 1,
        matrix: null,
        alignment: 0.5,
        native: false,
        cap: LINE_CAP.BUTT,
        join: LINE_JOIN.MITER,
        miterLimit: 10
      }, options);
      if (this.currentPath) {
        this.startPoly();
      }
      const visible = options.width > 0 && options.alpha > 0;
      if (!visible) {
        this._lineStyle.reset();
      } else {
        if (options.matrix) {
          options.matrix = options.matrix.clone();
          options.matrix.invert();
        }
        Object.assign(this._lineStyle, { visible }, options);
      }
      return this;
    }
    startPoly() {
      if (this.currentPath) {
        const points = this.currentPath.points;
        const len = this.currentPath.points.length;
        if (len > 2) {
          this.drawShape(this.currentPath);
          this.currentPath = new Polygon();
          this.currentPath.closeStroke = false;
          this.currentPath.points.push(points[len - 2], points[len - 1]);
        }
      } else {
        this.currentPath = new Polygon();
        this.currentPath.closeStroke = false;
      }
    }
    finishPoly() {
      if (this.currentPath) {
        if (this.currentPath.points.length > 2) {
          this.drawShape(this.currentPath);
          this.currentPath = null;
        } else {
          this.currentPath.points.length = 0;
        }
      }
    }
    moveTo(x3, y3) {
      this.startPoly();
      this.currentPath.points[0] = x3;
      this.currentPath.points[1] = y3;
      return this;
    }
    lineTo(x3, y3) {
      if (!this.currentPath) {
        this.moveTo(0, 0);
      }
      const points = this.currentPath.points;
      const fromX = points[points.length - 2];
      const fromY = points[points.length - 1];
      if (fromX !== x3 || fromY !== y3) {
        points.push(x3, y3);
      }
      return this;
    }
    _initCurve(x3 = 0, y3 = 0) {
      if (this.currentPath) {
        if (this.currentPath.points.length === 0) {
          this.currentPath.points = [x3, y3];
        }
      } else {
        this.moveTo(x3, y3);
      }
    }
    quadraticCurveTo(cpX, cpY, toX, toY) {
      this._initCurve();
      const points = this.currentPath.points;
      if (points.length === 0) {
        this.moveTo(0, 0);
      }
      QuadraticUtils.curveTo(cpX, cpY, toX, toY, points);
      return this;
    }
    bezierCurveTo(cpX, cpY, cpX2, cpY2, toX, toY) {
      this._initCurve();
      BezierUtils.curveTo(cpX, cpY, cpX2, cpY2, toX, toY, this.currentPath.points);
      return this;
    }
    arcTo(x1, y1, x22, y22, radius) {
      this._initCurve(x1, y1);
      const points = this.currentPath.points;
      const result = ArcUtils.curveTo(x1, y1, x22, y22, radius, points);
      if (result) {
        const { cx, cy, radius: radius2, startAngle, endAngle, anticlockwise } = result;
        this.arc(cx, cy, radius2, startAngle, endAngle, anticlockwise);
      }
      return this;
    }
    arc(cx, cy, radius, startAngle, endAngle, anticlockwise = false) {
      if (startAngle === endAngle) {
        return this;
      }
      if (!anticlockwise && endAngle <= startAngle) {
        endAngle += PI_2;
      } else if (anticlockwise && startAngle <= endAngle) {
        startAngle += PI_2;
      }
      const sweep = endAngle - startAngle;
      if (sweep === 0) {
        return this;
      }
      const startX = cx + Math.cos(startAngle) * radius;
      const startY = cy + Math.sin(startAngle) * radius;
      const eps = this._geometry.closePointEps;
      let points = this.currentPath ? this.currentPath.points : null;
      if (points) {
        const xDiff = Math.abs(points[points.length - 2] - startX);
        const yDiff = Math.abs(points[points.length - 1] - startY);
        if (xDiff < eps && yDiff < eps) {
        } else {
          points.push(startX, startY);
        }
      } else {
        this.moveTo(startX, startY);
        points = this.currentPath.points;
      }
      ArcUtils.arc(startX, startY, cx, cy, radius, startAngle, endAngle, anticlockwise, points);
      return this;
    }
    beginFill(color2 = 0, alpha = 1) {
      return this.beginTextureFill({ texture: Texture.WHITE, color: color2, alpha });
    }
    beginTextureFill(options) {
      options = Object.assign({
        texture: Texture.WHITE,
        color: 16777215,
        alpha: 1,
        matrix: null
      }, options);
      if (this.currentPath) {
        this.startPoly();
      }
      const visible = options.alpha > 0;
      if (!visible) {
        this._fillStyle.reset();
      } else {
        if (options.matrix) {
          options.matrix = options.matrix.clone();
          options.matrix.invert();
        }
        Object.assign(this._fillStyle, { visible }, options);
      }
      return this;
    }
    endFill() {
      this.finishPoly();
      this._fillStyle.reset();
      return this;
    }
    drawRect(x3, y3, width, height) {
      return this.drawShape(new Rectangle(x3, y3, width, height));
    }
    drawRoundedRect(x3, y3, width, height, radius) {
      return this.drawShape(new RoundedRectangle(x3, y3, width, height, radius));
    }
    drawCircle(x3, y3, radius) {
      return this.drawShape(new Circle(x3, y3, radius));
    }
    drawEllipse(x3, y3, width, height) {
      return this.drawShape(new Ellipse(x3, y3, width, height));
    }
    drawPolygon(...path2) {
      let points;
      let closeStroke = true;
      const poly = path2[0];
      if (poly.points) {
        closeStroke = poly.closeStroke;
        points = poly.points;
      } else if (Array.isArray(path2[0])) {
        points = path2[0];
      } else {
        points = path2;
      }
      const shape = new Polygon(points);
      shape.closeStroke = closeStroke;
      this.drawShape(shape);
      return this;
    }
    drawShape(shape) {
      if (!this._holeMode) {
        this._geometry.drawShape(shape, this._fillStyle.clone(), this._lineStyle.clone(), this._matrix);
      } else {
        this._geometry.drawHole(shape, this._matrix);
      }
      return this;
    }
    clear() {
      this._geometry.clear();
      this._lineStyle.reset();
      this._fillStyle.reset();
      this._boundsID++;
      this._matrix = null;
      this._holeMode = false;
      this.currentPath = null;
      return this;
    }
    isFastRect() {
      const data = this._geometry.graphicsData;
      return data.length === 1 && data[0].shape.type === SHAPES.RECT && !data[0].matrix && !data[0].holes.length && !(data[0].lineStyle.visible && data[0].lineStyle.width);
    }
    _render(renderer) {
      this.finishPoly();
      const geometry = this._geometry;
      geometry.updateBatches();
      if (geometry.batchable) {
        if (this.batchDirty !== geometry.batchDirty) {
          this._populateBatches();
        }
        this._renderBatched(renderer);
      } else {
        renderer.batch.flush();
        this._renderDirect(renderer);
      }
    }
    _populateBatches() {
      const geometry = this._geometry;
      const blendMode = this.blendMode;
      const len = geometry.batches.length;
      this.batchTint = -1;
      this._transformID = -1;
      this.batchDirty = geometry.batchDirty;
      this.batches.length = len;
      this.vertexData = new Float32Array(geometry.points);
      for (let i = 0; i < len; i++) {
        const gI = geometry.batches[i];
        const color2 = gI.style.color;
        const vertexData = new Float32Array(this.vertexData.buffer, gI.attribStart * 4 * 2, gI.attribSize * 2);
        const uvs = new Float32Array(geometry.uvsFloat32.buffer, gI.attribStart * 4 * 2, gI.attribSize * 2);
        const indices2 = new Uint16Array(geometry.indicesUint16.buffer, gI.start * 2, gI.size);
        const batch = {
          vertexData,
          blendMode,
          indices: indices2,
          uvs,
          _batchRGB: utils_exports.hex2rgb(color2),
          _tintRGB: color2,
          _texture: gI.style.texture,
          alpha: gI.style.alpha,
          worldAlpha: 1
        };
        this.batches[i] = batch;
      }
    }
    _renderBatched(renderer) {
      if (!this.batches.length) {
        return;
      }
      renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);
      this.calculateVertices();
      this.calculateTints();
      for (let i = 0, l = this.batches.length; i < l; i++) {
        const batch = this.batches[i];
        batch.worldAlpha = this.worldAlpha * batch.alpha;
        renderer.plugins[this.pluginName].render(batch);
      }
    }
    _renderDirect(renderer) {
      const shader = this._resolveDirectShader(renderer);
      const geometry = this._geometry;
      const tint = this.tint;
      const worldAlpha = this.worldAlpha;
      const uniforms = shader.uniforms;
      const drawCalls = geometry.drawCalls;
      uniforms.translationMatrix = this.transform.worldTransform;
      uniforms.tint[0] = (tint >> 16 & 255) / 255 * worldAlpha;
      uniforms.tint[1] = (tint >> 8 & 255) / 255 * worldAlpha;
      uniforms.tint[2] = (tint & 255) / 255 * worldAlpha;
      uniforms.tint[3] = worldAlpha;
      renderer.shader.bind(shader);
      renderer.geometry.bind(geometry, shader);
      renderer.state.set(this.state);
      for (let i = 0, l = drawCalls.length; i < l; i++) {
        this._renderDrawCallDirect(renderer, geometry.drawCalls[i]);
      }
    }
    _renderDrawCallDirect(renderer, drawCall) {
      const { texArray, type: type2, size, start: start2 } = drawCall;
      const groupTextureCount = texArray.count;
      for (let j = 0; j < groupTextureCount; j++) {
        renderer.texture.bind(texArray.elements[j], j);
      }
      renderer.geometry.draw(type2, size, start2);
    }
    _resolveDirectShader(renderer) {
      let shader = this.shader;
      const pluginName = this.pluginName;
      if (!shader) {
        if (!DEFAULT_SHADERS[pluginName]) {
          const { maxTextures } = renderer.plugins[pluginName];
          const sampleValues = new Int32Array(maxTextures);
          for (let i = 0; i < maxTextures; i++) {
            sampleValues[i] = i;
          }
          const uniforms = {
            tint: new Float32Array([1, 1, 1, 1]),
            translationMatrix: new Matrix(),
            default: UniformGroup.from({ uSamplers: sampleValues }, true)
          };
          const program = renderer.plugins[pluginName]._shader.program;
          DEFAULT_SHADERS[pluginName] = new Shader(program, uniforms);
        }
        shader = DEFAULT_SHADERS[pluginName];
      }
      return shader;
    }
    _calculateBounds() {
      this.finishPoly();
      const geometry = this._geometry;
      if (!geometry.graphicsData.length) {
        return;
      }
      const { minX, minY, maxX, maxY } = geometry.bounds;
      this._bounds.addFrame(this.transform, minX, minY, maxX, maxY);
    }
    containsPoint(point) {
      this.worldTransform.applyInverse(point, _Graphics._TEMP_POINT);
      return this._geometry.containsPoint(_Graphics._TEMP_POINT);
    }
    calculateTints() {
      if (this.batchTint !== this.tint) {
        this.batchTint = this.tint;
        const tintRGB = utils_exports.hex2rgb(this.tint, temp);
        for (let i = 0; i < this.batches.length; i++) {
          const batch = this.batches[i];
          const batchTint = batch._batchRGB;
          const r = tintRGB[0] * batchTint[0] * 255;
          const g = tintRGB[1] * batchTint[1] * 255;
          const b = tintRGB[2] * batchTint[2] * 255;
          const color2 = (r << 16) + (g << 8) + (b | 0);
          batch._tintRGB = (color2 >> 16) + (color2 & 65280) + ((color2 & 255) << 16);
        }
      }
    }
    calculateVertices() {
      const wtID = this.transform._worldID;
      if (this._transformID === wtID) {
        return;
      }
      this._transformID = wtID;
      const wt = this.transform.worldTransform;
      const a2 = wt.a;
      const b = wt.b;
      const c2 = wt.c;
      const d = wt.d;
      const tx = wt.tx;
      const ty = wt.ty;
      const data = this._geometry.points;
      const vertexData = this.vertexData;
      let count = 0;
      for (let i = 0; i < data.length; i += 2) {
        const x3 = data[i];
        const y3 = data[i + 1];
        vertexData[count++] = a2 * x3 + c2 * y3 + tx;
        vertexData[count++] = d * y3 + b * x3 + ty;
      }
    }
    closePath() {
      const currentPath = this.currentPath;
      if (currentPath) {
        currentPath.closeStroke = true;
        this.finishPoly();
      }
      return this;
    }
    setMatrix(matrix) {
      this._matrix = matrix;
      return this;
    }
    beginHole() {
      this.finishPoly();
      this._holeMode = true;
      return this;
    }
    endHole() {
      this.finishPoly();
      this._holeMode = false;
      return this;
    }
    destroy(options) {
      this._geometry.refCount--;
      if (this._geometry.refCount === 0) {
        this._geometry.dispose();
      }
      this._matrix = null;
      this.currentPath = null;
      this._lineStyle.destroy();
      this._lineStyle = null;
      this._fillStyle.destroy();
      this._fillStyle = null;
      this._geometry = null;
      this.shader = null;
      this.vertexData = null;
      this.batches.length = 0;
      this.batches = null;
      super.destroy(options);
    }
  };
  var Graphics = _Graphics;
  Graphics.curves = curves;
  Graphics._TEMP_POINT = new Point();

  // node_modules/pixijs/mesh/MeshBatchUvs.mjs
  var MeshBatchUvs = class {
    constructor(uvBuffer, uvMatrix) {
      this.uvBuffer = uvBuffer;
      this.uvMatrix = uvMatrix;
      this.data = null;
      this._bufferUpdateId = -1;
      this._textureUpdateId = -1;
      this._updateID = 0;
    }
    update(forceUpdate) {
      if (!forceUpdate && this._bufferUpdateId === this.uvBuffer._updateID && this._textureUpdateId === this.uvMatrix._updateID) {
        return;
      }
      this._bufferUpdateId = this.uvBuffer._updateID;
      this._textureUpdateId = this.uvMatrix._updateID;
      const data = this.uvBuffer.data;
      if (!this.data || this.data.length !== data.length) {
        this.data = new Float32Array(data.length);
      }
      this.uvMatrix.multiplyUvs(data, this.data);
      this._updateID++;
    }
  };

  // node_modules/pixijs/mesh/Mesh.mjs
  var tempPoint2 = new Point();
  var tempPolygon = new Polygon();
  var _Mesh = class extends Container {
    constructor(geometry, shader, state, drawMode = DRAW_MODES.TRIANGLES) {
      super();
      this.geometry = geometry;
      this.shader = shader;
      this.state = state || State.for2d();
      this.drawMode = drawMode;
      this.start = 0;
      this.size = 0;
      this.uvs = null;
      this.indices = null;
      this.vertexData = new Float32Array(1);
      this.vertexDirty = -1;
      this._transformID = -1;
      this._roundPixels = settings.ROUND_PIXELS;
      this.batchUvs = null;
    }
    get geometry() {
      return this._geometry;
    }
    set geometry(value) {
      if (this._geometry === value) {
        return;
      }
      if (this._geometry) {
        this._geometry.refCount--;
        if (this._geometry.refCount === 0) {
          this._geometry.dispose();
        }
      }
      this._geometry = value;
      if (this._geometry) {
        this._geometry.refCount++;
      }
      this.vertexDirty = -1;
    }
    get uvBuffer() {
      return this.geometry.buffers[1];
    }
    get verticesBuffer() {
      return this.geometry.buffers[0];
    }
    set material(value) {
      this.shader = value;
    }
    get material() {
      return this.shader;
    }
    set blendMode(value) {
      this.state.blendMode = value;
    }
    get blendMode() {
      return this.state.blendMode;
    }
    set roundPixels(value) {
      if (this._roundPixels !== value) {
        this._transformID = -1;
      }
      this._roundPixels = value;
    }
    get roundPixels() {
      return this._roundPixels;
    }
    get tint() {
      return "tint" in this.shader ? this.shader.tint : null;
    }
    set tint(value) {
      this.shader.tint = value;
    }
    get texture() {
      return "texture" in this.shader ? this.shader.texture : null;
    }
    set texture(value) {
      this.shader.texture = value;
    }
    _render(renderer) {
      const vertices = this.geometry.buffers[0].data;
      const shader = this.shader;
      if (shader.batchable && this.drawMode === DRAW_MODES.TRIANGLES && vertices.length < _Mesh.BATCHABLE_SIZE * 2) {
        this._renderToBatch(renderer);
      } else {
        this._renderDefault(renderer);
      }
    }
    _renderDefault(renderer) {
      const shader = this.shader;
      shader.alpha = this.worldAlpha;
      if (shader.update) {
        shader.update();
      }
      renderer.batch.flush();
      shader.uniforms.translationMatrix = this.transform.worldTransform.toArray(true);
      renderer.shader.bind(shader);
      renderer.state.set(this.state);
      renderer.geometry.bind(this.geometry, shader);
      renderer.geometry.draw(this.drawMode, this.size, this.start, this.geometry.instanceCount);
    }
    _renderToBatch(renderer) {
      const geometry = this.geometry;
      const shader = this.shader;
      if (shader.uvMatrix) {
        shader.uvMatrix.update();
        this.calculateUvs();
      }
      this.calculateVertices();
      this.indices = geometry.indexBuffer.data;
      this._tintRGB = shader._tintRGB;
      this._texture = shader.texture;
      const pluginName = this.material.pluginName;
      renderer.batch.setObjectRenderer(renderer.plugins[pluginName]);
      renderer.plugins[pluginName].render(this);
    }
    calculateVertices() {
      const geometry = this.geometry;
      const verticesBuffer = geometry.buffers[0];
      const vertices = verticesBuffer.data;
      const vertexDirtyId = verticesBuffer._updateID;
      if (vertexDirtyId === this.vertexDirty && this._transformID === this.transform._worldID) {
        return;
      }
      this._transformID = this.transform._worldID;
      if (this.vertexData.length !== vertices.length) {
        this.vertexData = new Float32Array(vertices.length);
      }
      const wt = this.transform.worldTransform;
      const a2 = wt.a;
      const b = wt.b;
      const c2 = wt.c;
      const d = wt.d;
      const tx = wt.tx;
      const ty = wt.ty;
      const vertexData = this.vertexData;
      for (let i = 0; i < vertexData.length / 2; i++) {
        const x3 = vertices[i * 2];
        const y3 = vertices[i * 2 + 1];
        vertexData[i * 2] = a2 * x3 + c2 * y3 + tx;
        vertexData[i * 2 + 1] = b * x3 + d * y3 + ty;
      }
      if (this._roundPixels) {
        const resolution = settings.RESOLUTION;
        for (let i = 0; i < vertexData.length; ++i) {
          vertexData[i] = Math.round(vertexData[i] * resolution) / resolution;
        }
      }
      this.vertexDirty = vertexDirtyId;
    }
    calculateUvs() {
      const geomUvs = this.geometry.buffers[1];
      const shader = this.shader;
      if (!shader.uvMatrix.isSimple) {
        if (!this.batchUvs) {
          this.batchUvs = new MeshBatchUvs(geomUvs, shader.uvMatrix);
        }
        this.batchUvs.update();
        this.uvs = this.batchUvs.data;
      } else {
        this.uvs = geomUvs.data;
      }
    }
    _calculateBounds() {
      this.calculateVertices();
      this._bounds.addVertexData(this.vertexData, 0, this.vertexData.length);
    }
    containsPoint(point) {
      if (!this.getBounds().contains(point.x, point.y)) {
        return false;
      }
      this.worldTransform.applyInverse(point, tempPoint2);
      const vertices = this.geometry.getBuffer("aVertexPosition").data;
      const points = tempPolygon.points;
      const indices2 = this.geometry.getIndex().data;
      const len = indices2.length;
      const step = this.drawMode === 4 ? 3 : 1;
      for (let i = 0; i + 2 < len; i += step) {
        const ind0 = indices2[i] * 2;
        const ind1 = indices2[i + 1] * 2;
        const ind2 = indices2[i + 2] * 2;
        points[0] = vertices[ind0];
        points[1] = vertices[ind0 + 1];
        points[2] = vertices[ind1];
        points[3] = vertices[ind1 + 1];
        points[4] = vertices[ind2];
        points[5] = vertices[ind2 + 1];
        if (tempPolygon.contains(tempPoint2.x, tempPoint2.y)) {
          return true;
        }
      }
      return false;
    }
    destroy(options) {
      super.destroy(options);
      if (this._cachedTexture) {
        this._cachedTexture.destroy();
        this._cachedTexture = null;
      }
      this.geometry = null;
      this.shader = null;
      this.state = null;
      this.uvs = null;
      this.indices = null;
      this.vertexData = null;
    }
  };
  var Mesh = _Mesh;
  Mesh.BATCHABLE_SIZE = 100;

  // node_modules/pixijs/mesh/MeshGeometry.mjs
  var MeshGeometry = class extends Geometry {
    constructor(vertices, uvs, index2) {
      super();
      const verticesBuffer = new Buffer2(vertices);
      const uvsBuffer = new Buffer2(uvs, true);
      const indexBuffer = new Buffer2(index2, true, true);
      this.addAttribute("aVertexPosition", verticesBuffer, 2, false, TYPES.FLOAT).addAttribute("aTextureCoord", uvsBuffer, 2, false, TYPES.FLOAT).addIndex(indexBuffer);
      this._updateId = -1;
    }
    get vertexDirtyId() {
      return this.buffers[0]._updateID;
    }
  };

  // node_modules/pixijs/mesh/shader/mesh.mjs
  var fragment7 = "varying vec2 vTextureCoord;\nuniform vec4 uColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void)\n{\n    gl_FragColor = texture2D(uSampler, vTextureCoord) * uColor;\n}\n";

  // node_modules/pixijs/mesh/shader/mesh2.mjs
  var vertex4 = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTextureMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\n}\n";

  // node_modules/pixijs/mesh/MeshMaterial.mjs
  var MeshMaterial = class extends Shader {
    constructor(uSampler, options) {
      const uniforms = {
        uSampler,
        alpha: 1,
        uTextureMatrix: Matrix.IDENTITY,
        uColor: new Float32Array([1, 1, 1, 1])
      };
      options = Object.assign({
        tint: 16777215,
        alpha: 1,
        pluginName: "batch"
      }, options);
      if (options.uniforms) {
        Object.assign(uniforms, options.uniforms);
      }
      super(options.program || Program.from(vertex4, fragment7), uniforms);
      this._colorDirty = false;
      this.uvMatrix = new TextureMatrix(uSampler);
      this.batchable = options.program === void 0;
      this.pluginName = options.pluginName;
      this.tint = options.tint;
      this.alpha = options.alpha;
    }
    get texture() {
      return this.uniforms.uSampler;
    }
    set texture(value) {
      if (this.uniforms.uSampler !== value) {
        if (!this.uniforms.uSampler.baseTexture.alphaMode !== !value.baseTexture.alphaMode) {
          this._colorDirty = true;
        }
        this.uniforms.uSampler = value;
        this.uvMatrix.texture = value;
      }
    }
    set alpha(value) {
      if (value === this._alpha)
        return;
      this._alpha = value;
      this._colorDirty = true;
    }
    get alpha() {
      return this._alpha;
    }
    set tint(value) {
      if (value === this._tint)
        return;
      this._tint = value;
      this._tintRGB = (value >> 16) + (value & 65280) + ((value & 255) << 16);
      this._colorDirty = true;
    }
    get tint() {
      return this._tint;
    }
    update() {
      if (this._colorDirty) {
        this._colorDirty = false;
        const baseTexture = this.texture.baseTexture;
        utils_exports.premultiplyTintToRgba(this._tint, this._alpha, this.uniforms.uColor, baseTexture.alphaMode);
      }
      if (this.uvMatrix.update()) {
        this.uniforms.uTextureMatrix = this.uvMatrix.mapCoord;
      }
    }
  };

  // node_modules/pixijs/particle-container/ParticleBuffer.mjs
  var ParticleBuffer = class {
    constructor(properties, dynamicPropertyFlags, size) {
      this.geometry = new Geometry();
      this.indexBuffer = null;
      this.size = size;
      this.dynamicProperties = [];
      this.staticProperties = [];
      for (let i = 0; i < properties.length; ++i) {
        let property = properties[i];
        property = {
          attributeName: property.attributeName,
          size: property.size,
          uploadFunction: property.uploadFunction,
          type: property.type || TYPES.FLOAT,
          offset: property.offset
        };
        if (dynamicPropertyFlags[i]) {
          this.dynamicProperties.push(property);
        } else {
          this.staticProperties.push(property);
        }
      }
      this.staticStride = 0;
      this.staticBuffer = null;
      this.staticData = null;
      this.staticDataUint32 = null;
      this.dynamicStride = 0;
      this.dynamicBuffer = null;
      this.dynamicData = null;
      this.dynamicDataUint32 = null;
      this._updateID = 0;
      this.initBuffers();
    }
    initBuffers() {
      const geometry = this.geometry;
      let dynamicOffset = 0;
      this.indexBuffer = new Buffer2(utils_exports.createIndicesForQuads(this.size), true, true);
      geometry.addIndex(this.indexBuffer);
      this.dynamicStride = 0;
      for (let i = 0; i < this.dynamicProperties.length; ++i) {
        const property = this.dynamicProperties[i];
        property.offset = dynamicOffset;
        dynamicOffset += property.size;
        this.dynamicStride += property.size;
      }
      const dynBuffer = new ArrayBuffer(this.size * this.dynamicStride * 4 * 4);
      this.dynamicData = new Float32Array(dynBuffer);
      this.dynamicDataUint32 = new Uint32Array(dynBuffer);
      this.dynamicBuffer = new Buffer2(this.dynamicData, false, false);
      let staticOffset = 0;
      this.staticStride = 0;
      for (let i = 0; i < this.staticProperties.length; ++i) {
        const property = this.staticProperties[i];
        property.offset = staticOffset;
        staticOffset += property.size;
        this.staticStride += property.size;
      }
      const statBuffer = new ArrayBuffer(this.size * this.staticStride * 4 * 4);
      this.staticData = new Float32Array(statBuffer);
      this.staticDataUint32 = new Uint32Array(statBuffer);
      this.staticBuffer = new Buffer2(this.staticData, true, false);
      for (let i = 0; i < this.dynamicProperties.length; ++i) {
        const property = this.dynamicProperties[i];
        geometry.addAttribute(property.attributeName, this.dynamicBuffer, 0, property.type === TYPES.UNSIGNED_BYTE, property.type, this.dynamicStride * 4, property.offset * 4);
      }
      for (let i = 0; i < this.staticProperties.length; ++i) {
        const property = this.staticProperties[i];
        geometry.addAttribute(property.attributeName, this.staticBuffer, 0, property.type === TYPES.UNSIGNED_BYTE, property.type, this.staticStride * 4, property.offset * 4);
      }
    }
    uploadDynamic(children2, startIndex, amount) {
      for (let i = 0; i < this.dynamicProperties.length; i++) {
        const property = this.dynamicProperties[i];
        property.uploadFunction(children2, startIndex, amount, property.type === TYPES.UNSIGNED_BYTE ? this.dynamicDataUint32 : this.dynamicData, this.dynamicStride, property.offset);
      }
      this.dynamicBuffer._updateID++;
    }
    uploadStatic(children2, startIndex, amount) {
      for (let i = 0; i < this.staticProperties.length; i++) {
        const property = this.staticProperties[i];
        property.uploadFunction(children2, startIndex, amount, property.type === TYPES.UNSIGNED_BYTE ? this.staticDataUint32 : this.staticData, this.staticStride, property.offset);
      }
      this.staticBuffer._updateID++;
    }
    destroy() {
      this.indexBuffer = null;
      this.dynamicProperties = null;
      this.dynamicBuffer = null;
      this.dynamicData = null;
      this.dynamicDataUint32 = null;
      this.staticProperties = null;
      this.staticBuffer = null;
      this.staticData = null;
      this.staticDataUint32 = null;
      this.geometry.destroy();
    }
  };

  // node_modules/pixijs/particle-container/particles.mjs
  var fragment8 = "varying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n    vec4 color = texture2D(uSampler, vTextureCoord) * vColor;\n    gl_FragColor = color;\n}";

  // node_modules/pixijs/particle-container/particles2.mjs
  var vertex5 = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\n\nattribute vec2 aPositionCoord;\nattribute float aRotation;\n\nuniform mat3 translationMatrix;\nuniform vec4 uColor;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nvoid main(void){\n    float x = (aVertexPosition.x) * cos(aRotation) - (aVertexPosition.y) * sin(aRotation);\n    float y = (aVertexPosition.x) * sin(aRotation) + (aVertexPosition.y) * cos(aRotation);\n\n    vec2 v = vec2(x, y);\n    v = v + aPositionCoord;\n\n    gl_Position = vec4((translationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vColor = aColor * uColor;\n}\n";

  // node_modules/pixijs/particle-container/ParticleRenderer.mjs
  var ParticleRenderer = class extends ObjectRenderer {
    constructor(renderer) {
      super(renderer);
      this.shader = null;
      this.properties = null;
      this.tempMatrix = new Matrix();
      this.properties = [
        {
          attributeName: "aVertexPosition",
          size: 2,
          uploadFunction: this.uploadVertices,
          offset: 0
        },
        {
          attributeName: "aPositionCoord",
          size: 2,
          uploadFunction: this.uploadPosition,
          offset: 0
        },
        {
          attributeName: "aRotation",
          size: 1,
          uploadFunction: this.uploadRotation,
          offset: 0
        },
        {
          attributeName: "aTextureCoord",
          size: 2,
          uploadFunction: this.uploadUvs,
          offset: 0
        },
        {
          attributeName: "aColor",
          size: 1,
          type: TYPES.UNSIGNED_BYTE,
          uploadFunction: this.uploadTint,
          offset: 0
        }
      ];
      this.shader = Shader.from(vertex5, fragment8, {});
      this.state = State.for2d();
    }
    render(container) {
      const children2 = container.children;
      const maxSize = container._maxSize;
      const batchSize = container._batchSize;
      const renderer = this.renderer;
      let totalChildren = children2.length;
      if (totalChildren === 0) {
        return;
      } else if (totalChildren > maxSize && !container.autoResize) {
        totalChildren = maxSize;
      }
      let buffers = container._buffers;
      if (!buffers) {
        buffers = container._buffers = this.generateBuffers(container);
      }
      const baseTexture = children2[0]._texture.baseTexture;
      const premultiplied = baseTexture.alphaMode > 0;
      this.state.blendMode = utils_exports.correctBlendMode(container.blendMode, premultiplied);
      renderer.state.set(this.state);
      const gl = renderer.gl;
      const m2 = container.worldTransform.copyTo(this.tempMatrix);
      m2.prepend(renderer.globalUniforms.uniforms.projectionMatrix);
      this.shader.uniforms.translationMatrix = m2.toArray(true);
      this.shader.uniforms.uColor = utils_exports.premultiplyRgba(container.tintRgb, container.worldAlpha, this.shader.uniforms.uColor, premultiplied);
      this.shader.uniforms.uSampler = baseTexture;
      this.renderer.shader.bind(this.shader);
      let updateStatic = false;
      for (let i = 0, j = 0; i < totalChildren; i += batchSize, j += 1) {
        let amount = totalChildren - i;
        if (amount > batchSize) {
          amount = batchSize;
        }
        if (j >= buffers.length) {
          buffers.push(this._generateOneMoreBuffer(container));
        }
        const buffer = buffers[j];
        buffer.uploadDynamic(children2, i, amount);
        const bid = container._bufferUpdateIDs[j] || 0;
        updateStatic = updateStatic || buffer._updateID < bid;
        if (updateStatic) {
          buffer._updateID = container._updateID;
          buffer.uploadStatic(children2, i, amount);
        }
        renderer.geometry.bind(buffer.geometry);
        gl.drawElements(gl.TRIANGLES, amount * 6, gl.UNSIGNED_SHORT, 0);
      }
    }
    generateBuffers(container) {
      const buffers = [];
      const size = container._maxSize;
      const batchSize = container._batchSize;
      const dynamicPropertyFlags = container._properties;
      for (let i = 0; i < size; i += batchSize) {
        buffers.push(new ParticleBuffer(this.properties, dynamicPropertyFlags, batchSize));
      }
      return buffers;
    }
    _generateOneMoreBuffer(container) {
      const batchSize = container._batchSize;
      const dynamicPropertyFlags = container._properties;
      return new ParticleBuffer(this.properties, dynamicPropertyFlags, batchSize);
    }
    uploadVertices(children2, startIndex, amount, array2, stride, offset) {
      let w0 = 0;
      let w1 = 0;
      let h0 = 0;
      let h1 = 0;
      for (let i = 0; i < amount; ++i) {
        const sprite = children2[startIndex + i];
        const texture = sprite._texture;
        const sx = sprite.scale.x;
        const sy = sprite.scale.y;
        const trim = texture.trim;
        const orig = texture.orig;
        if (trim) {
          w1 = trim.x - sprite.anchor.x * orig.width;
          w0 = w1 + trim.width;
          h1 = trim.y - sprite.anchor.y * orig.height;
          h0 = h1 + trim.height;
        } else {
          w0 = orig.width * (1 - sprite.anchor.x);
          w1 = orig.width * -sprite.anchor.x;
          h0 = orig.height * (1 - sprite.anchor.y);
          h1 = orig.height * -sprite.anchor.y;
        }
        array2[offset] = w1 * sx;
        array2[offset + 1] = h1 * sy;
        array2[offset + stride] = w0 * sx;
        array2[offset + stride + 1] = h1 * sy;
        array2[offset + stride * 2] = w0 * sx;
        array2[offset + stride * 2 + 1] = h0 * sy;
        array2[offset + stride * 3] = w1 * sx;
        array2[offset + stride * 3 + 1] = h0 * sy;
        offset += stride * 4;
      }
    }
    uploadPosition(children2, startIndex, amount, array2, stride, offset) {
      for (let i = 0; i < amount; i++) {
        const spritePosition = children2[startIndex + i].position;
        array2[offset] = spritePosition.x;
        array2[offset + 1] = spritePosition.y;
        array2[offset + stride] = spritePosition.x;
        array2[offset + stride + 1] = spritePosition.y;
        array2[offset + stride * 2] = spritePosition.x;
        array2[offset + stride * 2 + 1] = spritePosition.y;
        array2[offset + stride * 3] = spritePosition.x;
        array2[offset + stride * 3 + 1] = spritePosition.y;
        offset += stride * 4;
      }
    }
    uploadRotation(children2, startIndex, amount, array2, stride, offset) {
      for (let i = 0; i < amount; i++) {
        const spriteRotation = children2[startIndex + i].rotation;
        array2[offset] = spriteRotation;
        array2[offset + stride] = spriteRotation;
        array2[offset + stride * 2] = spriteRotation;
        array2[offset + stride * 3] = spriteRotation;
        offset += stride * 4;
      }
    }
    uploadUvs(children2, startIndex, amount, array2, stride, offset) {
      for (let i = 0; i < amount; ++i) {
        const textureUvs = children2[startIndex + i]._texture._uvs;
        if (textureUvs) {
          array2[offset] = textureUvs.x0;
          array2[offset + 1] = textureUvs.y0;
          array2[offset + stride] = textureUvs.x1;
          array2[offset + stride + 1] = textureUvs.y1;
          array2[offset + stride * 2] = textureUvs.x2;
          array2[offset + stride * 2 + 1] = textureUvs.y2;
          array2[offset + stride * 3] = textureUvs.x3;
          array2[offset + stride * 3 + 1] = textureUvs.y3;
          offset += stride * 4;
        } else {
          array2[offset] = 0;
          array2[offset + 1] = 0;
          array2[offset + stride] = 0;
          array2[offset + stride + 1] = 0;
          array2[offset + stride * 2] = 0;
          array2[offset + stride * 2 + 1] = 0;
          array2[offset + stride * 3] = 0;
          array2[offset + stride * 3 + 1] = 0;
          offset += stride * 4;
        }
      }
    }
    uploadTint(children2, startIndex, amount, array2, stride, offset) {
      for (let i = 0; i < amount; ++i) {
        const sprite = children2[startIndex + i];
        const premultiplied = sprite._texture.baseTexture.alphaMode > 0;
        const alpha = sprite.alpha;
        const argb = alpha < 1 && premultiplied ? utils_exports.premultiplyTint(sprite._tintRGB, alpha) : sprite._tintRGB + (alpha * 255 << 24);
        array2[offset] = argb;
        array2[offset + stride] = argb;
        array2[offset + stride * 2] = argb;
        array2[offset + stride * 3] = argb;
        offset += stride * 4;
      }
    }
    destroy() {
      super.destroy();
      if (this.shader) {
        this.shader.destroy();
        this.shader = null;
      }
      this.tempMatrix = null;
    }
  };
  ParticleRenderer.extension = {
    name: "particle",
    type: ExtensionType.RendererPlugin
  };
  extensions.add(ParticleRenderer);

  // node_modules/pixijs/text/const.mjs
  var TEXT_GRADIENT = /* @__PURE__ */ ((TEXT_GRADIENT2) => {
    TEXT_GRADIENT2[TEXT_GRADIENT2["LINEAR_VERTICAL"] = 0] = "LINEAR_VERTICAL";
    TEXT_GRADIENT2[TEXT_GRADIENT2["LINEAR_HORIZONTAL"] = 1] = "LINEAR_HORIZONTAL";
    return TEXT_GRADIENT2;
  })(TEXT_GRADIENT || {});

  // node_modules/pixijs/text/TextMetrics.mjs
  var contextSettings = {
    willReadFrequently: true
  };
  var _TextMetrics = class {
    static get experimentalLetterSpacingSupported() {
      let result = _TextMetrics._experimentalLetterSpacingSupported;
      if (result !== void 0) {
        const proto = settings.ADAPTER.getCanvasRenderingContext2D().prototype;
        result = _TextMetrics._experimentalLetterSpacingSupported = "letterSpacing" in proto || "textLetterSpacing" in proto;
      }
      return result;
    }
    constructor(text, style, width, height, lines, lineWidths, lineHeight, maxLineWidth, fontProperties) {
      this.text = text;
      this.style = style;
      this.width = width;
      this.height = height;
      this.lines = lines;
      this.lineWidths = lineWidths;
      this.lineHeight = lineHeight;
      this.maxLineWidth = maxLineWidth;
      this.fontProperties = fontProperties;
    }
    static measureText(text, style, wordWrap, canvas = _TextMetrics._canvas) {
      wordWrap = wordWrap === void 0 || wordWrap === null ? style.wordWrap : wordWrap;
      const font = style.toFontString();
      const fontProperties = _TextMetrics.measureFont(font);
      if (fontProperties.fontSize === 0) {
        fontProperties.fontSize = style.fontSize;
        fontProperties.ascent = style.fontSize;
      }
      const context2 = canvas.getContext("2d", contextSettings);
      context2.font = font;
      const outputText = wordWrap ? _TextMetrics.wordWrap(text, style, canvas) : text;
      const lines = outputText.split(/(?:\r\n|\r|\n)/);
      const lineWidths = new Array(lines.length);
      let maxLineWidth = 0;
      for (let i = 0; i < lines.length; i++) {
        const lineWidth = _TextMetrics._measureText(lines[i], style.letterSpacing, context2);
        lineWidths[i] = lineWidth;
        maxLineWidth = Math.max(maxLineWidth, lineWidth);
      }
      let width = maxLineWidth + style.strokeThickness;
      if (style.dropShadow) {
        width += style.dropShadowDistance;
      }
      const lineHeight = style.lineHeight || fontProperties.fontSize + style.strokeThickness;
      let height = Math.max(lineHeight, fontProperties.fontSize + style.strokeThickness * 2) + (lines.length - 1) * (lineHeight + style.leading);
      if (style.dropShadow) {
        height += style.dropShadowDistance;
      }
      return new _TextMetrics(text, style, width, height, lines, lineWidths, lineHeight + style.leading, maxLineWidth, fontProperties);
    }
    static _measureText(text, letterSpacing, context2) {
      let useExperimentalLetterSpacing = false;
      if (_TextMetrics.experimentalLetterSpacingSupported) {
        if (_TextMetrics.experimentalLetterSpacing) {
          context2.letterSpacing = `${letterSpacing}px`;
          context2.textLetterSpacing = `${letterSpacing}px`;
          useExperimentalLetterSpacing = true;
        } else {
          context2.letterSpacing = "0px";
          context2.textLetterSpacing = "0px";
        }
      }
      let width = context2.measureText(text).width;
      if (width > 0) {
        if (useExperimentalLetterSpacing) {
          width -= letterSpacing;
        } else {
          width += (_TextMetrics.graphemeSegmenter(text).length - 1) * letterSpacing;
        }
      }
      return width;
    }
    static wordWrap(text, style, canvas = _TextMetrics._canvas) {
      const context2 = canvas.getContext("2d", contextSettings);
      let width = 0;
      let line = "";
      let lines = "";
      const cache = /* @__PURE__ */ Object.create(null);
      const { letterSpacing, whiteSpace } = style;
      const collapseSpaces = _TextMetrics.collapseSpaces(whiteSpace);
      const collapseNewlines = _TextMetrics.collapseNewlines(whiteSpace);
      let canPrependSpaces = !collapseSpaces;
      const wordWrapWidth = style.wordWrapWidth + letterSpacing;
      const tokens = _TextMetrics.tokenize(text);
      for (let i = 0; i < tokens.length; i++) {
        let token = tokens[i];
        if (_TextMetrics.isNewline(token)) {
          if (!collapseNewlines) {
            lines += _TextMetrics.addLine(line);
            canPrependSpaces = !collapseSpaces;
            line = "";
            width = 0;
            continue;
          }
          token = " ";
        }
        if (collapseSpaces) {
          const currIsBreakingSpace = _TextMetrics.isBreakingSpace(token);
          const lastIsBreakingSpace = _TextMetrics.isBreakingSpace(line[line.length - 1]);
          if (currIsBreakingSpace && lastIsBreakingSpace) {
            continue;
          }
        }
        const tokenWidth = _TextMetrics.getFromCache(token, letterSpacing, cache, context2);
        if (tokenWidth > wordWrapWidth) {
          if (line !== "") {
            lines += _TextMetrics.addLine(line);
            line = "";
            width = 0;
          }
          if (_TextMetrics.canBreakWords(token, style.breakWords)) {
            const characters = _TextMetrics.wordWrapSplit(token);
            for (let j = 0; j < characters.length; j++) {
              let char = characters[j];
              let lastChar = char;
              let k = 1;
              while (characters[j + k]) {
                const nextChar = characters[j + k];
                if (!_TextMetrics.canBreakChars(lastChar, nextChar, token, j, style.breakWords)) {
                  char += nextChar;
                } else {
                  break;
                }
                lastChar = nextChar;
                k++;
              }
              j += k - 1;
              const characterWidth = _TextMetrics.getFromCache(char, letterSpacing, cache, context2);
              if (characterWidth + width > wordWrapWidth) {
                lines += _TextMetrics.addLine(line);
                canPrependSpaces = false;
                line = "";
                width = 0;
              }
              line += char;
              width += characterWidth;
            }
          } else {
            if (line.length > 0) {
              lines += _TextMetrics.addLine(line);
              line = "";
              width = 0;
            }
            const isLastToken = i === tokens.length - 1;
            lines += _TextMetrics.addLine(token, !isLastToken);
            canPrependSpaces = false;
            line = "";
            width = 0;
          }
        } else {
          if (tokenWidth + width > wordWrapWidth) {
            canPrependSpaces = false;
            lines += _TextMetrics.addLine(line);
            line = "";
            width = 0;
          }
          if (line.length > 0 || !_TextMetrics.isBreakingSpace(token) || canPrependSpaces) {
            line += token;
            width += tokenWidth;
          }
        }
      }
      lines += _TextMetrics.addLine(line, false);
      return lines;
    }
    static addLine(line, newLine = true) {
      line = _TextMetrics.trimRight(line);
      line = newLine ? `${line}
` : line;
      return line;
    }
    static getFromCache(key, letterSpacing, cache, context2) {
      let width = cache[key];
      if (typeof width !== "number") {
        width = _TextMetrics._measureText(key, letterSpacing, context2) + letterSpacing;
        cache[key] = width;
      }
      return width;
    }
    static collapseSpaces(whiteSpace) {
      return whiteSpace === "normal" || whiteSpace === "pre-line";
    }
    static collapseNewlines(whiteSpace) {
      return whiteSpace === "normal";
    }
    static trimRight(text) {
      if (typeof text !== "string") {
        return "";
      }
      for (let i = text.length - 1; i >= 0; i--) {
        const char = text[i];
        if (!_TextMetrics.isBreakingSpace(char)) {
          break;
        }
        text = text.slice(0, -1);
      }
      return text;
    }
    static isNewline(char) {
      if (typeof char !== "string") {
        return false;
      }
      return _TextMetrics._newlines.includes(char.charCodeAt(0));
    }
    static isBreakingSpace(char, _nextChar) {
      if (typeof char !== "string") {
        return false;
      }
      return _TextMetrics._breakingSpaces.includes(char.charCodeAt(0));
    }
    static tokenize(text) {
      const tokens = [];
      let token = "";
      if (typeof text !== "string") {
        return tokens;
      }
      for (let i = 0; i < text.length; i++) {
        const char = text[i];
        const nextChar = text[i + 1];
        if (_TextMetrics.isBreakingSpace(char, nextChar) || _TextMetrics.isNewline(char)) {
          if (token !== "") {
            tokens.push(token);
            token = "";
          }
          tokens.push(char);
          continue;
        }
        token += char;
      }
      if (token !== "") {
        tokens.push(token);
      }
      return tokens;
    }
    static canBreakWords(_token, breakWords) {
      return breakWords;
    }
    static canBreakChars(_char, _nextChar, _token, _index, _breakWords) {
      return true;
    }
    static wordWrapSplit(token) {
      return _TextMetrics.graphemeSegmenter(token);
    }
    static measureFont(font) {
      if (_TextMetrics._fonts[font]) {
        return _TextMetrics._fonts[font];
      }
      const properties = {
        ascent: 0,
        descent: 0,
        fontSize: 0
      };
      const canvas = _TextMetrics._canvas;
      const context2 = _TextMetrics._context;
      context2.font = font;
      const metricsString = _TextMetrics.METRICS_STRING + _TextMetrics.BASELINE_SYMBOL;
      const width = Math.ceil(context2.measureText(metricsString).width);
      let baseline = Math.ceil(context2.measureText(_TextMetrics.BASELINE_SYMBOL).width);
      const height = Math.ceil(_TextMetrics.HEIGHT_MULTIPLIER * baseline);
      baseline = baseline * _TextMetrics.BASELINE_MULTIPLIER | 0;
      if (width === 0 || height === 0) {
        _TextMetrics._fonts[font] = properties;
        return properties;
      }
      canvas.width = width;
      canvas.height = height;
      context2.fillStyle = "#f00";
      context2.fillRect(0, 0, width, height);
      context2.font = font;
      context2.textBaseline = "alphabetic";
      context2.fillStyle = "#000";
      context2.fillText(metricsString, 0, baseline);
      const imagedata = context2.getImageData(0, 0, width, height).data;
      const pixels = imagedata.length;
      const line = width * 4;
      let i = 0;
      let idx = 0;
      let stop = false;
      for (i = 0; i < baseline; ++i) {
        for (let j = 0; j < line; j += 4) {
          if (imagedata[idx + j] !== 255) {
            stop = true;
            break;
          }
        }
        if (!stop) {
          idx += line;
        } else {
          break;
        }
      }
      properties.ascent = baseline - i;
      idx = pixels - line;
      stop = false;
      for (i = height; i > baseline; --i) {
        for (let j = 0; j < line; j += 4) {
          if (imagedata[idx + j] !== 255) {
            stop = true;
            break;
          }
        }
        if (!stop) {
          idx -= line;
        } else {
          break;
        }
      }
      properties.descent = i - baseline;
      properties.fontSize = properties.ascent + properties.descent;
      _TextMetrics._fonts[font] = properties;
      return properties;
    }
    static clearMetrics(font = "") {
      if (font) {
        delete _TextMetrics._fonts[font];
      } else {
        _TextMetrics._fonts = {};
      }
    }
    static get _canvas() {
      if (!_TextMetrics.__canvas) {
        let canvas;
        try {
          const c2 = new OffscreenCanvas(0, 0);
          const context2 = c2.getContext("2d", contextSettings);
          if (context2 == null ? void 0 : context2.measureText) {
            _TextMetrics.__canvas = c2;
            return c2;
          }
          canvas = settings.ADAPTER.createCanvas();
        } catch (ex) {
          canvas = settings.ADAPTER.createCanvas();
        }
        canvas.width = canvas.height = 10;
        _TextMetrics.__canvas = canvas;
      }
      return _TextMetrics.__canvas;
    }
    static get _context() {
      if (!_TextMetrics.__context) {
        _TextMetrics.__context = _TextMetrics._canvas.getContext("2d", contextSettings);
      }
      return _TextMetrics.__context;
    }
  };
  var TextMetrics = _TextMetrics;
  TextMetrics.METRICS_STRING = "|\xC9q\xC5";
  TextMetrics.BASELINE_SYMBOL = "M";
  TextMetrics.BASELINE_MULTIPLIER = 1.4;
  TextMetrics.HEIGHT_MULTIPLIER = 2;
  TextMetrics.graphemeSegmenter = (() => {
    if (typeof (Intl == null ? void 0 : Intl.Segmenter) === "function") {
      const segmenter = new Intl.Segmenter();
      return (s) => [...segmenter.segment(s)].map((x3) => x3.segment);
    }
    return (s) => [...s];
  })();
  TextMetrics.experimentalLetterSpacing = false;
  TextMetrics._fonts = {};
  TextMetrics._newlines = [
    10,
    13
  ];
  TextMetrics._breakingSpaces = [
    9,
    32,
    8192,
    8193,
    8194,
    8195,
    8196,
    8197,
    8198,
    8200,
    8201,
    8202,
    8287,
    12288
  ];

  // node_modules/pixijs/text/TextStyle.mjs
  var genericFontFamilies = [
    "serif",
    "sans-serif",
    "monospace",
    "cursive",
    "fantasy",
    "system-ui"
  ];
  var _TextStyle = class {
    constructor(style) {
      this.styleID = 0;
      this.reset();
      deepCopyProperties(this, style, style);
    }
    clone() {
      const clonedProperties = {};
      deepCopyProperties(clonedProperties, this, _TextStyle.defaultStyle);
      return new _TextStyle(clonedProperties);
    }
    reset() {
      deepCopyProperties(this, _TextStyle.defaultStyle, _TextStyle.defaultStyle);
    }
    get align() {
      return this._align;
    }
    set align(align) {
      if (this._align !== align) {
        this._align = align;
        this.styleID++;
      }
    }
    get breakWords() {
      return this._breakWords;
    }
    set breakWords(breakWords) {
      if (this._breakWords !== breakWords) {
        this._breakWords = breakWords;
        this.styleID++;
      }
    }
    get dropShadow() {
      return this._dropShadow;
    }
    set dropShadow(dropShadow) {
      if (this._dropShadow !== dropShadow) {
        this._dropShadow = dropShadow;
        this.styleID++;
      }
    }
    get dropShadowAlpha() {
      return this._dropShadowAlpha;
    }
    set dropShadowAlpha(dropShadowAlpha) {
      if (this._dropShadowAlpha !== dropShadowAlpha) {
        this._dropShadowAlpha = dropShadowAlpha;
        this.styleID++;
      }
    }
    get dropShadowAngle() {
      return this._dropShadowAngle;
    }
    set dropShadowAngle(dropShadowAngle) {
      if (this._dropShadowAngle !== dropShadowAngle) {
        this._dropShadowAngle = dropShadowAngle;
        this.styleID++;
      }
    }
    get dropShadowBlur() {
      return this._dropShadowBlur;
    }
    set dropShadowBlur(dropShadowBlur) {
      if (this._dropShadowBlur !== dropShadowBlur) {
        this._dropShadowBlur = dropShadowBlur;
        this.styleID++;
      }
    }
    get dropShadowColor() {
      return this._dropShadowColor;
    }
    set dropShadowColor(dropShadowColor) {
      const outputColor = getColor(dropShadowColor);
      if (this._dropShadowColor !== outputColor) {
        this._dropShadowColor = outputColor;
        this.styleID++;
      }
    }
    get dropShadowDistance() {
      return this._dropShadowDistance;
    }
    set dropShadowDistance(dropShadowDistance) {
      if (this._dropShadowDistance !== dropShadowDistance) {
        this._dropShadowDistance = dropShadowDistance;
        this.styleID++;
      }
    }
    get fill() {
      return this._fill;
    }
    set fill(fill) {
      const outputColor = getColor(fill);
      if (this._fill !== outputColor) {
        this._fill = outputColor;
        this.styleID++;
      }
    }
    get fillGradientType() {
      return this._fillGradientType;
    }
    set fillGradientType(fillGradientType) {
      if (this._fillGradientType !== fillGradientType) {
        this._fillGradientType = fillGradientType;
        this.styleID++;
      }
    }
    get fillGradientStops() {
      return this._fillGradientStops;
    }
    set fillGradientStops(fillGradientStops) {
      if (!areArraysEqual(this._fillGradientStops, fillGradientStops)) {
        this._fillGradientStops = fillGradientStops;
        this.styleID++;
      }
    }
    get fontFamily() {
      return this._fontFamily;
    }
    set fontFamily(fontFamily) {
      if (this.fontFamily !== fontFamily) {
        this._fontFamily = fontFamily;
        this.styleID++;
      }
    }
    get fontSize() {
      return this._fontSize;
    }
    set fontSize(fontSize) {
      if (this._fontSize !== fontSize) {
        this._fontSize = fontSize;
        this.styleID++;
      }
    }
    get fontStyle() {
      return this._fontStyle;
    }
    set fontStyle(fontStyle) {
      if (this._fontStyle !== fontStyle) {
        this._fontStyle = fontStyle;
        this.styleID++;
      }
    }
    get fontVariant() {
      return this._fontVariant;
    }
    set fontVariant(fontVariant) {
      if (this._fontVariant !== fontVariant) {
        this._fontVariant = fontVariant;
        this.styleID++;
      }
    }
    get fontWeight() {
      return this._fontWeight;
    }
    set fontWeight(fontWeight) {
      if (this._fontWeight !== fontWeight) {
        this._fontWeight = fontWeight;
        this.styleID++;
      }
    }
    get letterSpacing() {
      return this._letterSpacing;
    }
    set letterSpacing(letterSpacing) {
      if (this._letterSpacing !== letterSpacing) {
        this._letterSpacing = letterSpacing;
        this.styleID++;
      }
    }
    get lineHeight() {
      return this._lineHeight;
    }
    set lineHeight(lineHeight) {
      if (this._lineHeight !== lineHeight) {
        this._lineHeight = lineHeight;
        this.styleID++;
      }
    }
    get leading() {
      return this._leading;
    }
    set leading(leading) {
      if (this._leading !== leading) {
        this._leading = leading;
        this.styleID++;
      }
    }
    get lineJoin() {
      return this._lineJoin;
    }
    set lineJoin(lineJoin) {
      if (this._lineJoin !== lineJoin) {
        this._lineJoin = lineJoin;
        this.styleID++;
      }
    }
    get miterLimit() {
      return this._miterLimit;
    }
    set miterLimit(miterLimit) {
      if (this._miterLimit !== miterLimit) {
        this._miterLimit = miterLimit;
        this.styleID++;
      }
    }
    get padding() {
      return this._padding;
    }
    set padding(padding) {
      if (this._padding !== padding) {
        this._padding = padding;
        this.styleID++;
      }
    }
    get stroke() {
      return this._stroke;
    }
    set stroke(stroke) {
      const outputColor = getColor(stroke);
      if (this._stroke !== outputColor) {
        this._stroke = outputColor;
        this.styleID++;
      }
    }
    get strokeThickness() {
      return this._strokeThickness;
    }
    set strokeThickness(strokeThickness) {
      if (this._strokeThickness !== strokeThickness) {
        this._strokeThickness = strokeThickness;
        this.styleID++;
      }
    }
    get textBaseline() {
      return this._textBaseline;
    }
    set textBaseline(textBaseline) {
      if (this._textBaseline !== textBaseline) {
        this._textBaseline = textBaseline;
        this.styleID++;
      }
    }
    get trim() {
      return this._trim;
    }
    set trim(trim) {
      if (this._trim !== trim) {
        this._trim = trim;
        this.styleID++;
      }
    }
    get whiteSpace() {
      return this._whiteSpace;
    }
    set whiteSpace(whiteSpace) {
      if (this._whiteSpace !== whiteSpace) {
        this._whiteSpace = whiteSpace;
        this.styleID++;
      }
    }
    get wordWrap() {
      return this._wordWrap;
    }
    set wordWrap(wordWrap) {
      if (this._wordWrap !== wordWrap) {
        this._wordWrap = wordWrap;
        this.styleID++;
      }
    }
    get wordWrapWidth() {
      return this._wordWrapWidth;
    }
    set wordWrapWidth(wordWrapWidth) {
      if (this._wordWrapWidth !== wordWrapWidth) {
        this._wordWrapWidth = wordWrapWidth;
        this.styleID++;
      }
    }
    toFontString() {
      const fontSizeString = typeof this.fontSize === "number" ? `${this.fontSize}px` : this.fontSize;
      let fontFamilies = this.fontFamily;
      if (!Array.isArray(this.fontFamily)) {
        fontFamilies = this.fontFamily.split(",");
      }
      for (let i = fontFamilies.length - 1; i >= 0; i--) {
        let fontFamily = fontFamilies[i].trim();
        if (!/([\"\'])[^\'\"]+\1/.test(fontFamily) && !genericFontFamilies.includes(fontFamily)) {
          fontFamily = `"${fontFamily}"`;
        }
        fontFamilies[i] = fontFamily;
      }
      return `${this.fontStyle} ${this.fontVariant} ${this.fontWeight} ${fontSizeString} ${fontFamilies.join(",")}`;
    }
  };
  var TextStyle = _TextStyle;
  TextStyle.defaultStyle = {
    align: "left",
    breakWords: false,
    dropShadow: false,
    dropShadowAlpha: 1,
    dropShadowAngle: Math.PI / 6,
    dropShadowBlur: 0,
    dropShadowColor: "black",
    dropShadowDistance: 5,
    fill: "black",
    fillGradientType: TEXT_GRADIENT.LINEAR_VERTICAL,
    fillGradientStops: [],
    fontFamily: "Arial",
    fontSize: 26,
    fontStyle: "normal",
    fontVariant: "normal",
    fontWeight: "normal",
    leading: 0,
    letterSpacing: 0,
    lineHeight: 0,
    lineJoin: "miter",
    miterLimit: 10,
    padding: 0,
    stroke: "black",
    strokeThickness: 0,
    textBaseline: "alphabetic",
    trim: false,
    whiteSpace: "pre",
    wordWrap: false,
    wordWrapWidth: 100
  };
  function getSingleColor(color2) {
    if (typeof color2 === "number") {
      return utils_exports.hex2string(color2);
    } else if (typeof color2 === "string") {
      if (color2.startsWith("0x")) {
        color2 = color2.replace("0x", "#");
      }
    }
    return color2;
  }
  function getColor(color2) {
    if (!Array.isArray(color2)) {
      return getSingleColor(color2);
    } else {
      for (let i = 0; i < color2.length; ++i) {
        color2[i] = getSingleColor(color2[i]);
      }
      return color2;
    }
  }
  function areArraysEqual(array1, array2) {
    if (!Array.isArray(array1) || !Array.isArray(array2)) {
      return false;
    }
    if (array1.length !== array2.length) {
      return false;
    }
    for (let i = 0; i < array1.length; ++i) {
      if (array1[i] !== array2[i]) {
        return false;
      }
    }
    return true;
  }
  function deepCopyProperties(target, source, propertyObj) {
    for (const prop in propertyObj) {
      if (Array.isArray(source[prop])) {
        target[prop] = source[prop].slice();
      } else {
        target[prop] = source[prop];
      }
    }
  }

  // node_modules/pixijs/text/Text.mjs
  var defaultDestroyOptions = {
    texture: true,
    children: false,
    baseTexture: true
  };
  var _Text = class extends Sprite {
    constructor(text, style, canvas) {
      var _a;
      let ownCanvas = false;
      if (!canvas) {
        canvas = settings.ADAPTER.createCanvas();
        ownCanvas = true;
      }
      canvas.width = 3;
      canvas.height = 3;
      const texture = Texture.from(canvas);
      texture.orig = new Rectangle();
      texture.trim = new Rectangle();
      super(texture);
      this._ownCanvas = ownCanvas;
      this.canvas = canvas;
      this.context = canvas.getContext("2d", {
        willReadFrequently: true
      });
      this._resolution = (_a = _Text.defaultResolution) != null ? _a : settings.RESOLUTION;
      this._autoResolution = _Text.defaultAutoResolution;
      this._text = null;
      this._style = null;
      this._styleListener = null;
      this._font = "";
      this.text = text;
      this.style = style;
      this.localStyleID = -1;
    }
    static get experimentalLetterSpacing() {
      return TextMetrics.experimentalLetterSpacing;
    }
    static set experimentalLetterSpacing(value) {
      utils_exports.deprecation("7.1.0", "Text.experimentalLetterSpacing is deprecated, use TextMetrics.experimentalLetterSpacing");
      TextMetrics.experimentalLetterSpacing = value;
    }
    updateText(respectDirty) {
      const style = this._style;
      if (this.localStyleID !== style.styleID) {
        this.dirty = true;
        this.localStyleID = style.styleID;
      }
      if (!this.dirty && respectDirty) {
        return;
      }
      this._font = this._style.toFontString();
      const context2 = this.context;
      const measured = TextMetrics.measureText(this._text || " ", this._style, this._style.wordWrap, this.canvas);
      const width = measured.width;
      const height = measured.height;
      const lines = measured.lines;
      const lineHeight = measured.lineHeight;
      const lineWidths = measured.lineWidths;
      const maxLineWidth = measured.maxLineWidth;
      const fontProperties = measured.fontProperties;
      this.canvas.width = Math.ceil(Math.ceil(Math.max(1, width) + style.padding * 2) * this._resolution);
      this.canvas.height = Math.ceil(Math.ceil(Math.max(1, height) + style.padding * 2) * this._resolution);
      context2.scale(this._resolution, this._resolution);
      context2.clearRect(0, 0, this.canvas.width, this.canvas.height);
      context2.font = this._font;
      context2.lineWidth = style.strokeThickness;
      context2.textBaseline = style.textBaseline;
      context2.lineJoin = style.lineJoin;
      context2.miterLimit = style.miterLimit;
      let linePositionX;
      let linePositionY;
      const passesCount = style.dropShadow ? 2 : 1;
      for (let i = 0; i < passesCount; ++i) {
        const isShadowPass = style.dropShadow && i === 0;
        const dsOffsetText = isShadowPass ? Math.ceil(Math.max(1, height) + style.padding * 2) : 0;
        const dsOffsetShadow = dsOffsetText * this._resolution;
        if (isShadowPass) {
          context2.fillStyle = "black";
          context2.strokeStyle = "black";
          const dropShadowColor = style.dropShadowColor;
          const rgb2 = utils_exports.hex2rgb(typeof dropShadowColor === "number" ? dropShadowColor : utils_exports.string2hex(dropShadowColor));
          const dropShadowBlur = style.dropShadowBlur * this._resolution;
          const dropShadowDistance = style.dropShadowDistance * this._resolution;
          context2.shadowColor = `rgba(${rgb2[0] * 255},${rgb2[1] * 255},${rgb2[2] * 255},${style.dropShadowAlpha})`;
          context2.shadowBlur = dropShadowBlur;
          context2.shadowOffsetX = Math.cos(style.dropShadowAngle) * dropShadowDistance;
          context2.shadowOffsetY = Math.sin(style.dropShadowAngle) * dropShadowDistance + dsOffsetShadow;
        } else {
          context2.fillStyle = this._generateFillStyle(style, lines, measured);
          context2.strokeStyle = style.stroke;
          context2.shadowColor = "black";
          context2.shadowBlur = 0;
          context2.shadowOffsetX = 0;
          context2.shadowOffsetY = 0;
        }
        let linePositionYShift = (lineHeight - fontProperties.fontSize) / 2;
        if (lineHeight - fontProperties.fontSize < 0) {
          linePositionYShift = 0;
        }
        for (let i2 = 0; i2 < lines.length; i2++) {
          linePositionX = style.strokeThickness / 2;
          linePositionY = style.strokeThickness / 2 + i2 * lineHeight + fontProperties.ascent + linePositionYShift;
          if (style.align === "right") {
            linePositionX += maxLineWidth - lineWidths[i2];
          } else if (style.align === "center") {
            linePositionX += (maxLineWidth - lineWidths[i2]) / 2;
          }
          if (style.stroke && style.strokeThickness) {
            this.drawLetterSpacing(lines[i2], linePositionX + style.padding, linePositionY + style.padding - dsOffsetText, true);
          }
          if (style.fill) {
            this.drawLetterSpacing(lines[i2], linePositionX + style.padding, linePositionY + style.padding - dsOffsetText);
          }
        }
      }
      this.updateTexture();
    }
    drawLetterSpacing(text, x3, y3, isStroke = false) {
      const style = this._style;
      const letterSpacing = style.letterSpacing;
      let useExperimentalLetterSpacing = false;
      if (TextMetrics.experimentalLetterSpacingSupported) {
        if (TextMetrics.experimentalLetterSpacing) {
          this.context.letterSpacing = `${letterSpacing}px`;
          this.context.textLetterSpacing = `${letterSpacing}px`;
          useExperimentalLetterSpacing = true;
        } else {
          this.context.letterSpacing = "0px";
          this.context.textLetterSpacing = "0px";
        }
      }
      if (letterSpacing === 0 || useExperimentalLetterSpacing) {
        if (isStroke) {
          this.context.strokeText(text, x3, y3);
        } else {
          this.context.fillText(text, x3, y3);
        }
        return;
      }
      let currentPosition = x3;
      const stringArray = TextMetrics.graphemeSegmenter(text);
      let previousWidth = this.context.measureText(text).width;
      let currentWidth = 0;
      for (let i = 0; i < stringArray.length; ++i) {
        const currentChar = stringArray[i];
        if (isStroke) {
          this.context.strokeText(currentChar, currentPosition, y3);
        } else {
          this.context.fillText(currentChar, currentPosition, y3);
        }
        let textStr = "";
        for (let j = i + 1; j < stringArray.length; ++j) {
          textStr += stringArray[j];
        }
        currentWidth = this.context.measureText(textStr).width;
        currentPosition += previousWidth - currentWidth + letterSpacing;
        previousWidth = currentWidth;
      }
    }
    updateTexture() {
      const canvas = this.canvas;
      if (this._style.trim) {
        const trimmed = utils_exports.trimCanvas(canvas);
        if (trimmed.data) {
          canvas.width = trimmed.width;
          canvas.height = trimmed.height;
          this.context.putImageData(trimmed.data, 0, 0);
        }
      }
      const texture = this._texture;
      const style = this._style;
      const padding = style.trim ? 0 : style.padding;
      const baseTexture = texture.baseTexture;
      texture.trim.width = texture._frame.width = canvas.width / this._resolution;
      texture.trim.height = texture._frame.height = canvas.height / this._resolution;
      texture.trim.x = -padding;
      texture.trim.y = -padding;
      texture.orig.width = texture._frame.width - padding * 2;
      texture.orig.height = texture._frame.height - padding * 2;
      this._onTextureUpdate();
      baseTexture.setRealSize(canvas.width, canvas.height, this._resolution);
      texture.updateUvs();
      this.dirty = false;
    }
    _render(renderer) {
      if (this._autoResolution && this._resolution !== renderer.resolution) {
        this._resolution = renderer.resolution;
        this.dirty = true;
      }
      this.updateText(true);
      super._render(renderer);
    }
    updateTransform() {
      this.updateText(true);
      super.updateTransform();
    }
    getBounds(skipUpdate, rect) {
      this.updateText(true);
      if (this._textureID === -1) {
        skipUpdate = false;
      }
      return super.getBounds(skipUpdate, rect);
    }
    getLocalBounds(rect) {
      this.updateText(true);
      return super.getLocalBounds.call(this, rect);
    }
    _calculateBounds() {
      this.calculateVertices();
      this._bounds.addQuad(this.vertexData);
    }
    _generateFillStyle(style, lines, metrics) {
      const fillStyle = style.fill;
      if (!Array.isArray(fillStyle)) {
        return fillStyle;
      } else if (fillStyle.length === 1) {
        return fillStyle[0];
      }
      let gradient;
      const dropShadowCorrection = style.dropShadow ? style.dropShadowDistance : 0;
      const padding = style.padding || 0;
      const width = this.canvas.width / this._resolution - dropShadowCorrection - padding * 2;
      const height = this.canvas.height / this._resolution - dropShadowCorrection - padding * 2;
      const fill = fillStyle.slice();
      const fillGradientStops = style.fillGradientStops.slice();
      if (!fillGradientStops.length) {
        const lengthPlus1 = fill.length + 1;
        for (let i = 1; i < lengthPlus1; ++i) {
          fillGradientStops.push(i / lengthPlus1);
        }
      }
      fill.unshift(fillStyle[0]);
      fillGradientStops.unshift(0);
      fill.push(fillStyle[fillStyle.length - 1]);
      fillGradientStops.push(1);
      if (style.fillGradientType === TEXT_GRADIENT.LINEAR_VERTICAL) {
        gradient = this.context.createLinearGradient(width / 2, padding, width / 2, height + padding);
        const textHeight = metrics.fontProperties.fontSize + style.strokeThickness;
        for (let i = 0; i < lines.length; i++) {
          const lastLineBottom = metrics.lineHeight * (i - 1) + textHeight;
          const thisLineTop = metrics.lineHeight * i;
          let thisLineGradientStart = thisLineTop;
          if (i > 0 && lastLineBottom > thisLineTop) {
            thisLineGradientStart = (thisLineTop + lastLineBottom) / 2;
          }
          const thisLineBottom = thisLineTop + textHeight;
          const nextLineTop = metrics.lineHeight * (i + 1);
          let thisLineGradientEnd = thisLineBottom;
          if (i + 1 < lines.length && nextLineTop < thisLineBottom) {
            thisLineGradientEnd = (thisLineBottom + nextLineTop) / 2;
          }
          const gradStopLineHeight = (thisLineGradientEnd - thisLineGradientStart) / height;
          for (let j = 0; j < fill.length; j++) {
            let lineStop = 0;
            if (typeof fillGradientStops[j] === "number") {
              lineStop = fillGradientStops[j];
            } else {
              lineStop = j / fill.length;
            }
            let globalStop = Math.min(1, Math.max(0, thisLineGradientStart / height + lineStop * gradStopLineHeight));
            globalStop = Number(globalStop.toFixed(5));
            gradient.addColorStop(globalStop, fill[j]);
          }
        }
      } else {
        gradient = this.context.createLinearGradient(padding, height / 2, width + padding, height / 2);
        const totalIterations = fill.length + 1;
        let currentIteration = 1;
        for (let i = 0; i < fill.length; i++) {
          let stop;
          if (typeof fillGradientStops[i] === "number") {
            stop = fillGradientStops[i];
          } else {
            stop = currentIteration / totalIterations;
          }
          gradient.addColorStop(stop, fill[i]);
          currentIteration++;
        }
      }
      return gradient;
    }
    destroy(options) {
      if (typeof options === "boolean") {
        options = { children: options };
      }
      options = Object.assign({}, defaultDestroyOptions, options);
      super.destroy(options);
      if (this._ownCanvas) {
        this.canvas.height = this.canvas.width = 0;
      }
      this.context = null;
      this.canvas = null;
      this._style = null;
    }
    get width() {
      this.updateText(true);
      return Math.abs(this.scale.x) * this._texture.orig.width;
    }
    set width(value) {
      this.updateText(true);
      const s = utils_exports.sign(this.scale.x) || 1;
      this.scale.x = s * value / this._texture.orig.width;
      this._width = value;
    }
    get height() {
      this.updateText(true);
      return Math.abs(this.scale.y) * this._texture.orig.height;
    }
    set height(value) {
      this.updateText(true);
      const s = utils_exports.sign(this.scale.y) || 1;
      this.scale.y = s * value / this._texture.orig.height;
      this._height = value;
    }
    get style() {
      return this._style;
    }
    set style(style) {
      style = style || {};
      if (style instanceof TextStyle) {
        this._style = style;
      } else {
        this._style = new TextStyle(style);
      }
      this.localStyleID = -1;
      this.dirty = true;
    }
    get text() {
      return this._text;
    }
    set text(text) {
      text = String(text === null || text === void 0 ? "" : text);
      if (this._text === text) {
        return;
      }
      this._text = text;
      this.dirty = true;
    }
    get resolution() {
      return this._resolution;
    }
    set resolution(value) {
      this._autoResolution = false;
      if (this._resolution === value) {
        return;
      }
      this._resolution = value;
      this.dirty = true;
    }
  };
  var Text = _Text;
  Text.defaultAutoResolution = true;

  // node_modules/pixijs/prepare/CountLimiter.mjs
  var CountLimiter = class {
    constructor(maxItemsPerFrame) {
      this.maxItemsPerFrame = maxItemsPerFrame;
      this.itemsLeft = 0;
    }
    beginFrame() {
      this.itemsLeft = this.maxItemsPerFrame;
    }
    allowedToUpload() {
      return this.itemsLeft-- > 0;
    }
  };

  // node_modules/pixijs/prepare/BasePrepare.mjs
  function findMultipleBaseTextures(item, queue) {
    var _a;
    let result = false;
    if ((_a = item == null ? void 0 : item._textures) == null ? void 0 : _a.length) {
      for (let i = 0; i < item._textures.length; i++) {
        if (item._textures[i] instanceof Texture) {
          const baseTexture = item._textures[i].baseTexture;
          if (!queue.includes(baseTexture)) {
            queue.push(baseTexture);
            result = true;
          }
        }
      }
    }
    return result;
  }
  function findBaseTexture(item, queue) {
    if (item.baseTexture instanceof BaseTexture) {
      const texture = item.baseTexture;
      if (!queue.includes(texture)) {
        queue.push(texture);
      }
      return true;
    }
    return false;
  }
  function findTexture(item, queue) {
    if (item._texture && item._texture instanceof Texture) {
      const texture = item._texture.baseTexture;
      if (!queue.includes(texture)) {
        queue.push(texture);
      }
      return true;
    }
    return false;
  }
  function drawText(_helper, item) {
    if (item instanceof Text) {
      item.updateText(true);
      return true;
    }
    return false;
  }
  function calculateTextStyle(_helper, item) {
    if (item instanceof TextStyle) {
      const font = item.toFontString();
      TextMetrics.measureFont(font);
      return true;
    }
    return false;
  }
  function findText(item, queue) {
    if (item instanceof Text) {
      if (!queue.includes(item.style)) {
        queue.push(item.style);
      }
      if (!queue.includes(item)) {
        queue.push(item);
      }
      const texture = item._texture.baseTexture;
      if (!queue.includes(texture)) {
        queue.push(texture);
      }
      return true;
    }
    return false;
  }
  function findTextStyle(item, queue) {
    if (item instanceof TextStyle) {
      if (!queue.includes(item)) {
        queue.push(item);
      }
      return true;
    }
    return false;
  }
  var _BasePrepare = class {
    constructor(renderer) {
      this.limiter = new CountLimiter(_BasePrepare.uploadsPerFrame);
      this.renderer = renderer;
      this.uploadHookHelper = null;
      this.queue = [];
      this.addHooks = [];
      this.uploadHooks = [];
      this.completes = [];
      this.ticking = false;
      this.delayedTick = () => {
        if (!this.queue) {
          return;
        }
        this.prepareItems();
      };
      this.registerFindHook(findText);
      this.registerFindHook(findTextStyle);
      this.registerFindHook(findMultipleBaseTextures);
      this.registerFindHook(findBaseTexture);
      this.registerFindHook(findTexture);
      this.registerUploadHook(drawText);
      this.registerUploadHook(calculateTextStyle);
    }
    upload(item) {
      return new Promise((resolve2) => {
        if (item) {
          this.add(item);
        }
        if (this.queue.length) {
          this.completes.push(resolve2);
          if (!this.ticking) {
            this.ticking = true;
            Ticker.system.addOnce(this.tick, this, UPDATE_PRIORITY.UTILITY);
          }
        } else {
          resolve2();
        }
      });
    }
    tick() {
      setTimeout(this.delayedTick, 0);
    }
    prepareItems() {
      this.limiter.beginFrame();
      while (this.queue.length && this.limiter.allowedToUpload()) {
        const item = this.queue[0];
        let uploaded = false;
        if (item && !item._destroyed) {
          for (let i = 0, len = this.uploadHooks.length; i < len; i++) {
            if (this.uploadHooks[i](this.uploadHookHelper, item)) {
              this.queue.shift();
              uploaded = true;
              break;
            }
          }
        }
        if (!uploaded) {
          this.queue.shift();
        }
      }
      if (!this.queue.length) {
        this.ticking = false;
        const completes = this.completes.slice(0);
        this.completes.length = 0;
        for (let i = 0, len = completes.length; i < len; i++) {
          completes[i]();
        }
      } else {
        Ticker.system.addOnce(this.tick, this, UPDATE_PRIORITY.UTILITY);
      }
    }
    registerFindHook(addHook) {
      if (addHook) {
        this.addHooks.push(addHook);
      }
      return this;
    }
    registerUploadHook(uploadHook) {
      if (uploadHook) {
        this.uploadHooks.push(uploadHook);
      }
      return this;
    }
    add(item) {
      for (let i = 0, len = this.addHooks.length; i < len; i++) {
        if (this.addHooks[i](item, this.queue)) {
          break;
        }
      }
      if (item instanceof Container) {
        for (let i = item.children.length - 1; i >= 0; i--) {
          this.add(item.children[i]);
        }
      }
      return this;
    }
    destroy() {
      if (this.ticking) {
        Ticker.system.remove(this.tick, this);
      }
      this.ticking = false;
      this.addHooks = null;
      this.uploadHooks = null;
      this.renderer = null;
      this.completes = null;
      this.queue = null;
      this.limiter = null;
      this.uploadHookHelper = null;
    }
  };
  var BasePrepare = _BasePrepare;
  BasePrepare.uploadsPerFrame = 4;

  // node_modules/pixijs/prepare/settings.mjs
  Object.defineProperties(settings, {
    UPLOADS_PER_FRAME: {
      get() {
        return BasePrepare.uploadsPerFrame;
      },
      set(value) {
        utils_exports.deprecation("7.1.0", "settings.UPLOADS_PER_FRAME is deprecated, use prepare.BasePrepare.uploadsPerFrame");
        BasePrepare.uploadsPerFrame = value;
      }
    }
  });

  // node_modules/pixijs/prepare/Prepare.mjs
  function uploadBaseTextures(renderer, item) {
    if (item instanceof BaseTexture) {
      if (!item._glTextures[renderer.CONTEXT_UID]) {
        renderer.texture.bind(item);
      }
      return true;
    }
    return false;
  }
  function uploadGraphics(renderer, item) {
    if (!(item instanceof Graphics)) {
      return false;
    }
    const { geometry } = item;
    item.finishPoly();
    geometry.updateBatches();
    const { batches } = geometry;
    for (let i = 0; i < batches.length; i++) {
      const { texture } = batches[i].style;
      if (texture) {
        uploadBaseTextures(renderer, texture.baseTexture);
      }
    }
    if (!geometry.batchable) {
      renderer.geometry.bind(geometry, item._resolveDirectShader(renderer));
    }
    return true;
  }
  function findGraphics(item, queue) {
    if (item instanceof Graphics) {
      queue.push(item);
      return true;
    }
    return false;
  }
  var Prepare = class extends BasePrepare {
    constructor(renderer) {
      super(renderer);
      this.uploadHookHelper = this.renderer;
      this.registerFindHook(findGraphics);
      this.registerUploadHook(uploadBaseTextures);
      this.registerUploadHook(uploadGraphics);
    }
  };
  Prepare.extension = {
    name: "prepare",
    type: ExtensionType.RendererSystem
  };
  extensions.add(Prepare);

  // node_modules/pixijs/sprite-tiling/TilingSprite.mjs
  var tempPoint3 = new Point();

  // node_modules/pixijs/sprite-tiling/sprite-tiling.mjs
  var gl2FragmentSrc = "#version 300 es\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nin vec2 vTextureCoord;\n\nout vec4 fragmentColor;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\nuniform mat3 uMapCoord;\nuniform vec4 uClampFrame;\nuniform vec2 uClampOffset;\n\nvoid main(void)\n{\n    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\n    vec2 unclamped = coord;\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n    vec4 texSample = texture(uSampler, coord, unclamped == coord ? 0.0f : -32.0f);// lod-bias very negative to force lod 0\n\n    fragmentColor = texSample * uColor;\n}\n";

  // node_modules/pixijs/sprite-tiling/sprite-tiling2.mjs
  var gl2VertexSrc = "#version 300 es\n#define SHADER_NAME Tiling-Sprite-300\n\nprecision lowp float;\n\nin vec2 aVertexPosition;\nin vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTransform;\n\nout vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\n}\n";

  // node_modules/pixijs/sprite-tiling/sprite-tiling-fallback.mjs
  var gl1FragmentSrc = "#version 100\n#ifdef GL_EXT_shader_texture_lod\n    #extension GL_EXT_shader_texture_lod : enable\n#endif\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\nuniform mat3 uMapCoord;\nuniform vec4 uClampFrame;\nuniform vec2 uClampOffset;\n\nvoid main(void)\n{\n    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\n    vec2 unclamped = coord;\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n    #ifdef GL_EXT_shader_texture_lod\n        vec4 texSample = unclamped == coord\n            ? texture2D(uSampler, coord) \n            : texture2DLodEXT(uSampler, coord, 0);\n    #else\n        vec4 texSample = texture2D(uSampler, coord);\n    #endif\n\n    gl_FragColor = texSample * uColor;\n}\n";

  // node_modules/pixijs/sprite-tiling/sprite-tiling-fallback2.mjs
  var gl1VertexSrc = "#version 100\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTransform;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\n}\n";

  // node_modules/pixijs/sprite-tiling/sprite-tiling-simple.mjs
  var fragmentSimpleSrc = "#version 100\n#define SHADER_NAME Tiling-Sprite-Simple-100\n\nprecision lowp float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\n\nvoid main(void)\n{\n    vec4 texSample = texture2D(uSampler, vTextureCoord);\n    gl_FragColor = texSample * uColor;\n}\n";

  // node_modules/pixijs/sprite-tiling/TilingSpriteRenderer.mjs
  var tempMat2 = new Matrix();
  var TilingSpriteRenderer = class extends ObjectRenderer {
    constructor(renderer) {
      super(renderer);
      renderer.runners.contextChange.add(this);
      this.quad = new QuadUv();
      this.state = State.for2d();
    }
    contextChange() {
      const renderer = this.renderer;
      const uniforms = { globals: renderer.globalUniforms };
      this.simpleShader = Shader.from(gl1VertexSrc, fragmentSimpleSrc, uniforms);
      this.shader = renderer.context.webGLVersion > 1 ? Shader.from(gl2VertexSrc, gl2FragmentSrc, uniforms) : Shader.from(gl1VertexSrc, gl1FragmentSrc, uniforms);
    }
    render(ts) {
      const renderer = this.renderer;
      const quad = this.quad;
      let vertices = quad.vertices;
      vertices[0] = vertices[6] = ts._width * -ts.anchor.x;
      vertices[1] = vertices[3] = ts._height * -ts.anchor.y;
      vertices[2] = vertices[4] = ts._width * (1 - ts.anchor.x);
      vertices[5] = vertices[7] = ts._height * (1 - ts.anchor.y);
      const anchorX = ts.uvRespectAnchor ? ts.anchor.x : 0;
      const anchorY = ts.uvRespectAnchor ? ts.anchor.y : 0;
      vertices = quad.uvs;
      vertices[0] = vertices[6] = -anchorX;
      vertices[1] = vertices[3] = -anchorY;
      vertices[2] = vertices[4] = 1 - anchorX;
      vertices[5] = vertices[7] = 1 - anchorY;
      quad.invalidate();
      const tex = ts._texture;
      const baseTex = tex.baseTexture;
      const premultiplied = baseTex.alphaMode > 0;
      const lt = ts.tileTransform.localTransform;
      const uv = ts.uvMatrix;
      let isSimple = baseTex.isPowerOfTwo && tex.frame.width === baseTex.width && tex.frame.height === baseTex.height;
      if (isSimple) {
        if (!baseTex._glTextures[renderer.CONTEXT_UID]) {
          if (baseTex.wrapMode === WRAP_MODES.CLAMP) {
            baseTex.wrapMode = WRAP_MODES.REPEAT;
          }
        } else {
          isSimple = baseTex.wrapMode !== WRAP_MODES.CLAMP;
        }
      }
      const shader = isSimple ? this.simpleShader : this.shader;
      const w = tex.width;
      const h = tex.height;
      const W = ts._width;
      const H = ts._height;
      tempMat2.set(lt.a * w / W, lt.b * w / H, lt.c * h / W, lt.d * h / H, lt.tx / W, lt.ty / H);
      tempMat2.invert();
      if (isSimple) {
        tempMat2.prepend(uv.mapCoord);
      } else {
        shader.uniforms.uMapCoord = uv.mapCoord.toArray(true);
        shader.uniforms.uClampFrame = uv.uClampFrame;
        shader.uniforms.uClampOffset = uv.uClampOffset;
      }
      shader.uniforms.uTransform = tempMat2.toArray(true);
      shader.uniforms.uColor = utils_exports.premultiplyTintToRgba(ts.tint, ts.worldAlpha, shader.uniforms.uColor, premultiplied);
      shader.uniforms.translationMatrix = ts.transform.worldTransform.toArray(true);
      shader.uniforms.uSampler = tex;
      renderer.shader.bind(shader);
      renderer.geometry.bind(quad);
      this.state.blendMode = utils_exports.correctBlendMode(ts.blendMode, premultiplied);
      renderer.state.set(this.state);
      renderer.geometry.draw(this.renderer.gl.TRIANGLES, 6, 0);
    }
  };
  TilingSpriteRenderer.extension = {
    name: "tilingSprite",
    type: ExtensionType.RendererPlugin
  };
  extensions.add(TilingSpriteRenderer);

  // node_modules/pixijs/spritesheet/Spritesheet.mjs
  var _Spritesheet = class {
    constructor(texture, data, resolutionFilename = null) {
      this.linkedSheets = [];
      this._texture = texture instanceof Texture ? texture : null;
      this.baseTexture = texture instanceof BaseTexture ? texture : this._texture.baseTexture;
      this.textures = {};
      this.animations = {};
      this.data = data;
      const resource = this.baseTexture.resource;
      this.resolution = this._updateResolution(resolutionFilename || (resource ? resource.url : null));
      this._frames = this.data.frames;
      this._frameKeys = Object.keys(this._frames);
      this._batchIndex = 0;
      this._callback = null;
    }
    _updateResolution(resolutionFilename = null) {
      const { scale } = this.data.meta;
      let resolution = utils_exports.getResolutionOfUrl(resolutionFilename, null);
      if (resolution === null) {
        resolution = parseFloat(scale != null ? scale : "1");
      }
      if (resolution !== 1) {
        this.baseTexture.setResolution(resolution);
      }
      return resolution;
    }
    parse() {
      return new Promise((resolve2) => {
        this._callback = resolve2;
        this._batchIndex = 0;
        if (this._frameKeys.length <= _Spritesheet.BATCH_SIZE) {
          this._processFrames(0);
          this._processAnimations();
          this._parseComplete();
        } else {
          this._nextBatch();
        }
      });
    }
    _processFrames(initialFrameIndex) {
      let frameIndex = initialFrameIndex;
      const maxFrames = _Spritesheet.BATCH_SIZE;
      while (frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length) {
        const i = this._frameKeys[frameIndex];
        const data = this._frames[i];
        const rect = data.frame;
        if (rect) {
          let frame2 = null;
          let trim = null;
          const sourceSize = data.trimmed !== false && data.sourceSize ? data.sourceSize : data.frame;
          const orig = new Rectangle(0, 0, Math.floor(sourceSize.w) / this.resolution, Math.floor(sourceSize.h) / this.resolution);
          if (data.rotated) {
            frame2 = new Rectangle(Math.floor(rect.x) / this.resolution, Math.floor(rect.y) / this.resolution, Math.floor(rect.h) / this.resolution, Math.floor(rect.w) / this.resolution);
          } else {
            frame2 = new Rectangle(Math.floor(rect.x) / this.resolution, Math.floor(rect.y) / this.resolution, Math.floor(rect.w) / this.resolution, Math.floor(rect.h) / this.resolution);
          }
          if (data.trimmed !== false && data.spriteSourceSize) {
            trim = new Rectangle(Math.floor(data.spriteSourceSize.x) / this.resolution, Math.floor(data.spriteSourceSize.y) / this.resolution, Math.floor(rect.w) / this.resolution, Math.floor(rect.h) / this.resolution);
          }
          this.textures[i] = new Texture(this.baseTexture, frame2, orig, trim, data.rotated ? 2 : 0, data.anchor);
          Texture.addToCache(this.textures[i], i);
        }
        frameIndex++;
      }
    }
    _processAnimations() {
      const animations = this.data.animations || {};
      for (const animName in animations) {
        this.animations[animName] = [];
        for (let i = 0; i < animations[animName].length; i++) {
          const frameName = animations[animName][i];
          this.animations[animName].push(this.textures[frameName]);
        }
      }
    }
    _parseComplete() {
      const callback = this._callback;
      this._callback = null;
      this._batchIndex = 0;
      callback.call(this, this.textures);
    }
    _nextBatch() {
      this._processFrames(this._batchIndex * _Spritesheet.BATCH_SIZE);
      this._batchIndex++;
      setTimeout(() => {
        if (this._batchIndex * _Spritesheet.BATCH_SIZE < this._frameKeys.length) {
          this._nextBatch();
        } else {
          this._processAnimations();
          this._parseComplete();
        }
      }, 0);
    }
    destroy(destroyBase = false) {
      var _a;
      for (const i in this.textures) {
        this.textures[i].destroy();
      }
      this._frames = null;
      this._frameKeys = null;
      this.data = null;
      this.textures = null;
      if (destroyBase) {
        (_a = this._texture) == null ? void 0 : _a.destroy();
        this.baseTexture.destroy();
      }
      this._texture = null;
      this.baseTexture = null;
      this.linkedSheets = [];
    }
  };
  var Spritesheet = _Spritesheet;
  Spritesheet.BATCH_SIZE = 1e3;

  // node_modules/pixijs/spritesheet/spritesheetAsset.mjs
  var validImages = ["jpg", "png", "jpeg", "avif", "webp"];
  function getCacheableAssets(keys, asset, ignoreMultiPack) {
    const out = {};
    keys.forEach((key) => {
      out[key] = asset;
    });
    Object.keys(asset.textures).forEach((key) => {
      out[key] = asset.textures[key];
    });
    if (!ignoreMultiPack) {
      const basePath = utils_exports.path.dirname(keys[0]);
      asset.linkedSheets.forEach((item, i) => {
        const out2 = getCacheableAssets([`${basePath}/${asset.data.meta.related_multi_packs[i]}`], item, true);
        Object.assign(out, out2);
      });
    }
    return out;
  }
  var spritesheetAsset = {
    extension: ExtensionType.Asset,
    cache: {
      test: (asset) => asset instanceof Spritesheet,
      getCacheableAssets: (keys, asset) => getCacheableAssets(keys, asset, false)
    },
    resolver: {
      test: (value) => {
        const tempURL = value.split("?")[0];
        const split = tempURL.split(".");
        const extension = split.pop();
        const format2 = split.pop();
        return extension === "json" && validImages.includes(format2);
      },
      parse: (value) => {
        var _a, _b;
        const split = value.split(".");
        return {
          resolution: parseFloat((_b = (_a = settings.RETINA_PREFIX.exec(value)) == null ? void 0 : _a[1]) != null ? _b : "1"),
          format: split[split.length - 2],
          src: value
        };
      }
    },
    loader: {
      extension: {
        type: ExtensionType.LoadParser,
        priority: LoaderParserPriority.Normal
      },
      async testParse(asset, options) {
        return utils_exports.path.extname(options.src).toLowerCase() === ".json" && !!asset.frames;
      },
      async parse(asset, options, loader) {
        var _a, _b;
        let basePath = utils_exports.path.dirname(options.src);
        if (basePath && basePath.lastIndexOf("/") !== basePath.length - 1) {
          basePath += "/";
        }
        let imagePath = basePath + asset.meta.image;
        imagePath = copySearchParams(imagePath, options.src);
        const assets = await loader.load([imagePath]);
        const texture = assets[imagePath];
        const spritesheet = new Spritesheet(texture.baseTexture, asset, options.src);
        await spritesheet.parse();
        const multiPacks = (_a = asset == null ? void 0 : asset.meta) == null ? void 0 : _a.related_multi_packs;
        if (Array.isArray(multiPacks)) {
          const promises = [];
          for (const item of multiPacks) {
            if (typeof item !== "string") {
              continue;
            }
            let itemUrl = basePath + item;
            if ((_b = options.data) == null ? void 0 : _b.ignoreMultiPack) {
              continue;
            }
            itemUrl = copySearchParams(itemUrl, options.src);
            promises.push(loader.load({
              src: itemUrl,
              data: {
                ignoreMultiPack: true
              }
            }));
          }
          const res = await Promise.all(promises);
          spritesheet.linkedSheets = res;
          res.forEach((item) => {
            item.linkedSheets = [spritesheet].concat(spritesheet.linkedSheets.filter((sp) => sp !== item));
          });
        }
        return spritesheet;
      },
      unload(spritesheet) {
        spritesheet.destroy(true);
      }
    }
  };
  extensions.add(spritesheetAsset);

  // node_modules/pixijs/text-bitmap/BitmapFontData.mjs
  var BitmapFontData = class {
    constructor() {
      this.info = [];
      this.common = [];
      this.page = [];
      this.char = [];
      this.kerning = [];
      this.distanceField = [];
    }
  };

  // node_modules/pixijs/text-bitmap/formats/TextFormat.mjs
  var TextFormat = class {
    static test(data) {
      return typeof data === "string" && data.startsWith("info face=");
    }
    static parse(txt) {
      const items = txt.match(/^[a-z]+\s+.+$/gm);
      const rawData = {
        info: [],
        common: [],
        page: [],
        char: [],
        chars: [],
        kerning: [],
        kernings: [],
        distanceField: []
      };
      for (const i in items) {
        const name = items[i].match(/^[a-z]+/gm)[0];
        const attributeList = items[i].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm);
        const itemData = {};
        for (const i2 in attributeList) {
          const split = attributeList[i2].split("=");
          const key = split[0];
          const strValue = split[1].replace(/"/gm, "");
          const floatValue = parseFloat(strValue);
          const value = isNaN(floatValue) ? strValue : floatValue;
          itemData[key] = value;
        }
        rawData[name].push(itemData);
      }
      const font = new BitmapFontData();
      rawData.info.forEach((info) => font.info.push({
        face: info.face,
        size: parseInt(info.size, 10)
      }));
      rawData.common.forEach((common) => font.common.push({
        lineHeight: parseInt(common.lineHeight, 10)
      }));
      rawData.page.forEach((page) => font.page.push({
        id: parseInt(page.id, 10),
        file: page.file
      }));
      rawData.char.forEach((char) => font.char.push({
        id: parseInt(char.id, 10),
        page: parseInt(char.page, 10),
        x: parseInt(char.x, 10),
        y: parseInt(char.y, 10),
        width: parseInt(char.width, 10),
        height: parseInt(char.height, 10),
        xoffset: parseInt(char.xoffset, 10),
        yoffset: parseInt(char.yoffset, 10),
        xadvance: parseInt(char.xadvance, 10)
      }));
      rawData.kerning.forEach((kerning) => font.kerning.push({
        first: parseInt(kerning.first, 10),
        second: parseInt(kerning.second, 10),
        amount: parseInt(kerning.amount, 10)
      }));
      rawData.distanceField.forEach((df) => font.distanceField.push({
        distanceRange: parseInt(df.distanceRange, 10),
        fieldType: df.fieldType
      }));
      return font;
    }
  };

  // node_modules/pixijs/text-bitmap/formats/XMLFormat.mjs
  var XMLFormat = class {
    static test(data) {
      const xml = data;
      return "getElementsByTagName" in xml && xml.getElementsByTagName("page").length && xml.getElementsByTagName("info")[0].getAttribute("face") !== null;
    }
    static parse(xml) {
      const data = new BitmapFontData();
      const info = xml.getElementsByTagName("info");
      const common = xml.getElementsByTagName("common");
      const page = xml.getElementsByTagName("page");
      const char = xml.getElementsByTagName("char");
      const kerning = xml.getElementsByTagName("kerning");
      const distanceField = xml.getElementsByTagName("distanceField");
      for (let i = 0; i < info.length; i++) {
        data.info.push({
          face: info[i].getAttribute("face"),
          size: parseInt(info[i].getAttribute("size"), 10)
        });
      }
      for (let i = 0; i < common.length; i++) {
        data.common.push({
          lineHeight: parseInt(common[i].getAttribute("lineHeight"), 10)
        });
      }
      for (let i = 0; i < page.length; i++) {
        data.page.push({
          id: parseInt(page[i].getAttribute("id"), 10) || 0,
          file: page[i].getAttribute("file")
        });
      }
      for (let i = 0; i < char.length; i++) {
        const letter = char[i];
        data.char.push({
          id: parseInt(letter.getAttribute("id"), 10),
          page: parseInt(letter.getAttribute("page"), 10) || 0,
          x: parseInt(letter.getAttribute("x"), 10),
          y: parseInt(letter.getAttribute("y"), 10),
          width: parseInt(letter.getAttribute("width"), 10),
          height: parseInt(letter.getAttribute("height"), 10),
          xoffset: parseInt(letter.getAttribute("xoffset"), 10),
          yoffset: parseInt(letter.getAttribute("yoffset"), 10),
          xadvance: parseInt(letter.getAttribute("xadvance"), 10)
        });
      }
      for (let i = 0; i < kerning.length; i++) {
        data.kerning.push({
          first: parseInt(kerning[i].getAttribute("first"), 10),
          second: parseInt(kerning[i].getAttribute("second"), 10),
          amount: parseInt(kerning[i].getAttribute("amount"), 10)
        });
      }
      for (let i = 0; i < distanceField.length; i++) {
        data.distanceField.push({
          fieldType: distanceField[i].getAttribute("fieldType"),
          distanceRange: parseInt(distanceField[i].getAttribute("distanceRange"), 10)
        });
      }
      return data;
    }
  };

  // node_modules/pixijs/text-bitmap/formats/XMLStringFormat.mjs
  var XMLStringFormat = class {
    static test(data) {
      if (typeof data === "string" && data.includes("<font>")) {
        return XMLFormat.test(settings.ADAPTER.parseXML(data));
      }
      return false;
    }
    static parse(xmlTxt) {
      return XMLFormat.parse(settings.ADAPTER.parseXML(xmlTxt));
    }
  };

  // node_modules/pixijs/text-bitmap/formats/index.mjs
  var formats = [
    TextFormat,
    XMLFormat,
    XMLStringFormat
  ];
  function autoDetectFormat(data) {
    for (let i = 0; i < formats.length; i++) {
      if (formats[i].test(data)) {
        return formats[i];
      }
    }
    return null;
  }

  // node_modules/pixijs/text-bitmap/utils/generateFillStyle.mjs
  function generateFillStyle(canvas, context2, style, resolution, lines, metrics) {
    const fillStyle = style.fill;
    if (!Array.isArray(fillStyle)) {
      return fillStyle;
    } else if (fillStyle.length === 1) {
      return fillStyle[0];
    }
    let gradient;
    const dropShadowCorrection = style.dropShadow ? style.dropShadowDistance : 0;
    const padding = style.padding || 0;
    const width = canvas.width / resolution - dropShadowCorrection - padding * 2;
    const height = canvas.height / resolution - dropShadowCorrection - padding * 2;
    const fill = fillStyle.slice();
    const fillGradientStops = style.fillGradientStops.slice();
    if (!fillGradientStops.length) {
      const lengthPlus1 = fill.length + 1;
      for (let i = 1; i < lengthPlus1; ++i) {
        fillGradientStops.push(i / lengthPlus1);
      }
    }
    fill.unshift(fillStyle[0]);
    fillGradientStops.unshift(0);
    fill.push(fillStyle[fillStyle.length - 1]);
    fillGradientStops.push(1);
    if (style.fillGradientType === TEXT_GRADIENT.LINEAR_VERTICAL) {
      gradient = context2.createLinearGradient(width / 2, padding, width / 2, height + padding);
      let lastIterationStop = 0;
      const textHeight = metrics.fontProperties.fontSize + style.strokeThickness;
      const gradStopLineHeight = textHeight / height;
      for (let i = 0; i < lines.length; i++) {
        const thisLineTop = metrics.lineHeight * i;
        for (let j = 0; j < fill.length; j++) {
          let lineStop = 0;
          if (typeof fillGradientStops[j] === "number") {
            lineStop = fillGradientStops[j];
          } else {
            lineStop = j / fill.length;
          }
          const globalStop = thisLineTop / height + lineStop * gradStopLineHeight;
          let clampedStop = Math.max(lastIterationStop, globalStop);
          clampedStop = Math.min(clampedStop, 1);
          gradient.addColorStop(clampedStop, fill[j]);
          lastIterationStop = clampedStop;
        }
      }
    } else {
      gradient = context2.createLinearGradient(padding, height / 2, width + padding, height / 2);
      const totalIterations = fill.length + 1;
      let currentIteration = 1;
      for (let i = 0; i < fill.length; i++) {
        let stop;
        if (typeof fillGradientStops[i] === "number") {
          stop = fillGradientStops[i];
        } else {
          stop = currentIteration / totalIterations;
        }
        gradient.addColorStop(stop, fill[i]);
        currentIteration++;
      }
    }
    return gradient;
  }

  // node_modules/pixijs/text-bitmap/utils/drawGlyph.mjs
  function drawGlyph(canvas, context2, metrics, x3, y3, resolution, style) {
    const char = metrics.text;
    const fontProperties = metrics.fontProperties;
    context2.translate(x3, y3);
    context2.scale(resolution, resolution);
    const tx = style.strokeThickness / 2;
    const ty = -(style.strokeThickness / 2);
    context2.font = style.toFontString();
    context2.lineWidth = style.strokeThickness;
    context2.textBaseline = style.textBaseline;
    context2.lineJoin = style.lineJoin;
    context2.miterLimit = style.miterLimit;
    context2.fillStyle = generateFillStyle(canvas, context2, style, resolution, [char], metrics);
    context2.strokeStyle = style.stroke;
    if (style.dropShadow) {
      const dropShadowColor = style.dropShadowColor;
      const rgb2 = utils_exports.hex2rgb(typeof dropShadowColor === "number" ? dropShadowColor : utils_exports.string2hex(dropShadowColor));
      const dropShadowBlur = style.dropShadowBlur * resolution;
      const dropShadowDistance = style.dropShadowDistance * resolution;
      context2.shadowColor = `rgba(${rgb2[0] * 255},${rgb2[1] * 255},${rgb2[2] * 255},${style.dropShadowAlpha})`;
      context2.shadowBlur = dropShadowBlur;
      context2.shadowOffsetX = Math.cos(style.dropShadowAngle) * dropShadowDistance;
      context2.shadowOffsetY = Math.sin(style.dropShadowAngle) * dropShadowDistance;
    } else {
      context2.shadowColor = "black";
      context2.shadowBlur = 0;
      context2.shadowOffsetX = 0;
      context2.shadowOffsetY = 0;
    }
    if (style.stroke && style.strokeThickness) {
      context2.strokeText(char, tx, ty + metrics.lineHeight - fontProperties.descent);
    }
    if (style.fill) {
      context2.fillText(char, tx, ty + metrics.lineHeight - fontProperties.descent);
    }
    context2.setTransform(1, 0, 0, 1, 0, 0);
    context2.fillStyle = "rgba(0, 0, 0, 0)";
  }

  // node_modules/pixijs/text-bitmap/utils/extractCharCode.mjs
  function extractCharCode(str) {
    return str.codePointAt ? str.codePointAt(0) : str.charCodeAt(0);
  }

  // node_modules/pixijs/text-bitmap/utils/splitTextToCharacters.mjs
  function splitTextToCharacters(text) {
    return Array.from ? Array.from(text) : text.split("");
  }

  // node_modules/pixijs/text-bitmap/utils/resolveCharacters.mjs
  function resolveCharacters(chars) {
    if (typeof chars === "string") {
      chars = [chars];
    }
    const result = [];
    for (let i = 0, j = chars.length; i < j; i++) {
      const item = chars[i];
      if (Array.isArray(item)) {
        if (item.length !== 2) {
          throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${item.length}.`);
        }
        const startCode = item[0].charCodeAt(0);
        const endCode = item[1].charCodeAt(0);
        if (endCode < startCode) {
          throw new Error("[BitmapFont]: Invalid character range.");
        }
        for (let i2 = startCode, j2 = endCode; i2 <= j2; i2++) {
          result.push(String.fromCharCode(i2));
        }
      } else {
        result.push(...splitTextToCharacters(item));
      }
    }
    if (result.length === 0) {
      throw new Error("[BitmapFont]: Empty set when resolving characters.");
    }
    return result;
  }

  // node_modules/pixijs/text-bitmap/BitmapFont.mjs
  var _BitmapFont = class {
    constructor(data, textures, ownsTextures) {
      var _a, _b;
      const [info] = data.info;
      const [common] = data.common;
      const [page] = data.page;
      const [distanceField] = data.distanceField;
      const res = utils_exports.getResolutionOfUrl(page.file);
      const pageTextures = {};
      this._ownsTextures = ownsTextures;
      this.font = info.face;
      this.size = info.size;
      this.lineHeight = common.lineHeight / res;
      this.chars = {};
      this.pageTextures = pageTextures;
      for (let i = 0; i < data.page.length; i++) {
        const { id: id2, file } = data.page[i];
        pageTextures[id2] = textures instanceof Array ? textures[i] : textures[file];
        if ((distanceField == null ? void 0 : distanceField.fieldType) && distanceField.fieldType !== "none") {
          pageTextures[id2].baseTexture.alphaMode = ALPHA_MODES.NO_PREMULTIPLIED_ALPHA;
          pageTextures[id2].baseTexture.mipmap = MIPMAP_MODES.OFF;
        }
      }
      for (let i = 0; i < data.char.length; i++) {
        const { id: id2, page: page2 } = data.char[i];
        let { x: x3, y: y3, width, height, xoffset, yoffset, xadvance } = data.char[i];
        x3 /= res;
        y3 /= res;
        width /= res;
        height /= res;
        xoffset /= res;
        yoffset /= res;
        xadvance /= res;
        const rect = new Rectangle(x3 + pageTextures[page2].frame.x / res, y3 + pageTextures[page2].frame.y / res, width, height);
        this.chars[id2] = {
          xOffset: xoffset,
          yOffset: yoffset,
          xAdvance: xadvance,
          kerning: {},
          texture: new Texture(pageTextures[page2].baseTexture, rect),
          page: page2
        };
      }
      for (let i = 0; i < data.kerning.length; i++) {
        let { first, second, amount } = data.kerning[i];
        first /= res;
        second /= res;
        amount /= res;
        if (this.chars[second]) {
          this.chars[second].kerning[first] = amount;
        }
      }
      this.distanceFieldRange = distanceField == null ? void 0 : distanceField.distanceRange;
      this.distanceFieldType = (_b = (_a = distanceField == null ? void 0 : distanceField.fieldType) == null ? void 0 : _a.toLowerCase()) != null ? _b : "none";
    }
    destroy() {
      for (const id2 in this.chars) {
        this.chars[id2].texture.destroy();
        this.chars[id2].texture = null;
      }
      for (const id2 in this.pageTextures) {
        if (this._ownsTextures) {
          this.pageTextures[id2].destroy(true);
        }
        this.pageTextures[id2] = null;
      }
      this.chars = null;
      this.pageTextures = null;
    }
    static install(data, textures, ownsTextures) {
      let fontData;
      if (data instanceof BitmapFontData) {
        fontData = data;
      } else {
        const format2 = autoDetectFormat(data);
        if (!format2) {
          throw new Error("Unrecognized data format for font.");
        }
        fontData = format2.parse(data);
      }
      if (textures instanceof Texture) {
        textures = [textures];
      }
      const font = new _BitmapFont(fontData, textures, ownsTextures);
      _BitmapFont.available[font.font] = font;
      return font;
    }
    static uninstall(name) {
      const font = _BitmapFont.available[name];
      if (!font) {
        throw new Error(`No font found named '${name}'`);
      }
      font.destroy();
      delete _BitmapFont.available[name];
    }
    static from(name, textStyle, options) {
      if (!name) {
        throw new Error("[BitmapFont] Property `name` is required.");
      }
      const _a = Object.assign({}, _BitmapFont.defaultOptions, options), {
        chars,
        padding,
        resolution,
        textureWidth,
        textureHeight
      } = _a, baseOptions = __objRest(_a, [
        "chars",
        "padding",
        "resolution",
        "textureWidth",
        "textureHeight"
      ]);
      const charsList = resolveCharacters(chars);
      const style = textStyle instanceof TextStyle ? textStyle : new TextStyle(textStyle);
      const lineWidth = textureWidth;
      const fontData = new BitmapFontData();
      fontData.info[0] = {
        face: style.fontFamily,
        size: style.fontSize
      };
      fontData.common[0] = {
        lineHeight: style.fontSize
      };
      let positionX = 0;
      let positionY = 0;
      let canvas;
      let context2;
      let baseTexture;
      let maxCharHeight = 0;
      const baseTextures = [];
      const textures = [];
      for (let i = 0; i < charsList.length; i++) {
        if (!canvas) {
          canvas = settings.ADAPTER.createCanvas();
          canvas.width = textureWidth;
          canvas.height = textureHeight;
          context2 = canvas.getContext("2d");
          baseTexture = new BaseTexture(canvas, __spreadValues({ resolution }, baseOptions));
          baseTextures.push(baseTexture);
          textures.push(new Texture(baseTexture));
          fontData.page.push({
            id: textures.length - 1,
            file: ""
          });
        }
        const character = charsList[i];
        const metrics = TextMetrics.measureText(character, style, false, canvas);
        const width = metrics.width;
        const height = Math.ceil(metrics.height);
        const textureGlyphWidth = Math.ceil((style.fontStyle === "italic" ? 2 : 1) * width);
        if (positionY >= textureHeight - height * resolution) {
          if (positionY === 0) {
            throw new Error(`[BitmapFont] textureHeight ${textureHeight}px is too small (fontFamily: '${style.fontFamily}', fontSize: ${style.fontSize}px, char: '${character}')`);
          }
          --i;
          canvas = null;
          context2 = null;
          baseTexture = null;
          positionY = 0;
          positionX = 0;
          maxCharHeight = 0;
          continue;
        }
        maxCharHeight = Math.max(height + metrics.fontProperties.descent, maxCharHeight);
        if (textureGlyphWidth * resolution + positionX >= lineWidth) {
          if (positionX === 0) {
            throw new Error(`[BitmapFont] textureWidth ${textureWidth}px is too small (fontFamily: '${style.fontFamily}', fontSize: ${style.fontSize}px, char: '${character}')`);
          }
          --i;
          positionY += maxCharHeight * resolution;
          positionY = Math.ceil(positionY);
          positionX = 0;
          maxCharHeight = 0;
          continue;
        }
        drawGlyph(canvas, context2, metrics, positionX, positionY, resolution, style);
        const id2 = extractCharCode(metrics.text);
        fontData.char.push({
          id: id2,
          page: textures.length - 1,
          x: positionX / resolution,
          y: positionY / resolution,
          width: textureGlyphWidth,
          height,
          xoffset: 0,
          yoffset: 0,
          xadvance: width - (style.dropShadow ? style.dropShadowDistance : 0) - (style.stroke ? style.strokeThickness : 0)
        });
        positionX += (textureGlyphWidth + 2 * padding) * resolution;
        positionX = Math.ceil(positionX);
      }
      for (let i = 0, len = charsList.length; i < len; i++) {
        const first = charsList[i];
        for (let j = 0; j < len; j++) {
          const second = charsList[j];
          const c1 = context2.measureText(first).width;
          const c2 = context2.measureText(second).width;
          const total = context2.measureText(first + second).width;
          const amount = total - (c1 + c2);
          if (amount) {
            fontData.kerning.push({
              first: extractCharCode(first),
              second: extractCharCode(second),
              amount
            });
          }
        }
      }
      const font = new _BitmapFont(fontData, textures, true);
      if (_BitmapFont.available[name] !== void 0) {
        _BitmapFont.uninstall(name);
      }
      _BitmapFont.available[name] = font;
      return font;
    }
  };
  var BitmapFont = _BitmapFont;
  BitmapFont.ALPHA = [["a", "z"], ["A", "Z"], " "];
  BitmapFont.NUMERIC = [["0", "9"]];
  BitmapFont.ALPHANUMERIC = [["a", "z"], ["A", "Z"], ["0", "9"], " "];
  BitmapFont.ASCII = [[" ", "~"]];
  BitmapFont.defaultOptions = {
    resolution: 1,
    textureWidth: 512,
    textureHeight: 512,
    padding: 4,
    chars: _BitmapFont.ALPHANUMERIC
  };
  BitmapFont.available = {};

  // node_modules/pixijs/text-bitmap/shader/msdf.mjs
  var msdfFrag = "// Pixi texture info\r\nvarying vec2 vTextureCoord;\r\nuniform sampler2D uSampler;\r\n\r\n// Tint\r\nuniform vec4 uColor;\r\n\r\n// on 2D applications fwidth is screenScale / glyphAtlasScale * distanceFieldRange\r\nuniform float uFWidth;\r\n\r\nvoid main(void) {\r\n\r\n  // To stack MSDF and SDF we need a non-pre-multiplied-alpha texture.\r\n  vec4 texColor = texture2D(uSampler, vTextureCoord);\r\n\r\n  // MSDF\r\n  float median = texColor.r + texColor.g + texColor.b -\r\n                  min(texColor.r, min(texColor.g, texColor.b)) -\r\n                  max(texColor.r, max(texColor.g, texColor.b));\r\n  // SDF\r\n  median = min(median, texColor.a);\r\n\r\n  float screenPxDistance = uFWidth * (median - 0.5);\r\n  float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\r\n  if (median < 0.01) {\r\n    alpha = 0.0;\r\n  } else if (median > 0.99) {\r\n    alpha = 1.0;\r\n  }\r\n\r\n  // NPM Textures, NPM outputs\r\n  gl_FragColor = vec4(uColor.rgb, uColor.a * alpha);\r\n\r\n}\r\n";

  // node_modules/pixijs/text-bitmap/shader/msdf2.mjs
  var msdfVert = "// Mesh material default fragment\r\nattribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\n\r\nuniform mat3 projectionMatrix;\r\nuniform mat3 translationMatrix;\r\nuniform mat3 uTextureMatrix;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nvoid main(void)\r\n{\r\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n\r\n    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\r\n}\r\n";

  // node_modules/pixijs/text-bitmap/BitmapText.mjs
  var pageMeshDataDefaultPageMeshData = [];
  var pageMeshDataMSDFPageMeshData = [];
  var charRenderDataPool = [];
  var _BitmapText = class extends Container {
    constructor(text, style = {}) {
      super();
      this._tint = 16777215;
      const { align, tint, maxWidth, letterSpacing, fontName, fontSize } = Object.assign({}, _BitmapText.styleDefaults, style);
      if (!BitmapFont.available[fontName]) {
        throw new Error(`Missing BitmapFont "${fontName}"`);
      }
      this._activePagesMeshData = [];
      this._textWidth = 0;
      this._textHeight = 0;
      this._align = align;
      this._tint = tint;
      this._font = void 0;
      this._fontName = fontName;
      this._fontSize = fontSize;
      this.text = text;
      this._maxWidth = maxWidth;
      this._maxLineHeight = 0;
      this._letterSpacing = letterSpacing;
      this._anchor = new ObservablePoint(() => {
        this.dirty = true;
      }, this, 0, 0);
      this._roundPixels = settings.ROUND_PIXELS;
      this.dirty = true;
      this._resolution = settings.RESOLUTION;
      this._autoResolution = true;
      this._textureCache = {};
    }
    updateText() {
      var _a;
      const data = BitmapFont.available[this._fontName];
      const fontSize = this.fontSize;
      const scale = fontSize / data.size;
      const pos = new Point();
      const chars = [];
      const lineWidths = [];
      const lineSpaces = [];
      const text = this._text.replace(/(?:\r\n|\r)/g, "\n") || " ";
      const charsInput = splitTextToCharacters(text);
      const maxWidth = this._maxWidth * data.size / fontSize;
      const pageMeshDataPool = data.distanceFieldType === "none" ? pageMeshDataDefaultPageMeshData : pageMeshDataMSDFPageMeshData;
      let prevCharCode = null;
      let lastLineWidth = 0;
      let maxLineWidth = 0;
      let line = 0;
      let lastBreakPos = -1;
      let lastBreakWidth = 0;
      let spacesRemoved = 0;
      let maxLineHeight = 0;
      let spaceCount = 0;
      for (let i = 0; i < charsInput.length; i++) {
        const char = charsInput[i];
        const charCode = extractCharCode(char);
        if (/(?:\s)/.test(char)) {
          lastBreakPos = i;
          lastBreakWidth = lastLineWidth;
          spaceCount++;
        }
        if (char === "\r" || char === "\n") {
          lineWidths.push(lastLineWidth);
          lineSpaces.push(-1);
          maxLineWidth = Math.max(maxLineWidth, lastLineWidth);
          ++line;
          ++spacesRemoved;
          pos.x = 0;
          pos.y += data.lineHeight;
          prevCharCode = null;
          spaceCount = 0;
          continue;
        }
        const charData = data.chars[charCode];
        if (!charData) {
          continue;
        }
        if (prevCharCode && charData.kerning[prevCharCode]) {
          pos.x += charData.kerning[prevCharCode];
        }
        const charRenderData = charRenderDataPool.pop() || {
          texture: Texture.EMPTY,
          line: 0,
          charCode: 0,
          prevSpaces: 0,
          position: new Point()
        };
        charRenderData.texture = charData.texture;
        charRenderData.line = line;
        charRenderData.charCode = charCode;
        charRenderData.position.x = Math.round(pos.x + charData.xOffset + this._letterSpacing / 2);
        charRenderData.position.y = Math.round(pos.y + charData.yOffset);
        charRenderData.prevSpaces = spaceCount;
        chars.push(charRenderData);
        lastLineWidth = charRenderData.position.x + Math.max(charData.xAdvance - charData.xOffset, charData.texture.orig.width);
        pos.x += charData.xAdvance + this._letterSpacing;
        maxLineHeight = Math.max(maxLineHeight, charData.yOffset + charData.texture.height);
        prevCharCode = charCode;
        if (lastBreakPos !== -1 && maxWidth > 0 && pos.x > maxWidth) {
          ++spacesRemoved;
          utils_exports.removeItems(chars, 1 + lastBreakPos - spacesRemoved, 1 + i - lastBreakPos);
          i = lastBreakPos;
          lastBreakPos = -1;
          lineWidths.push(lastBreakWidth);
          lineSpaces.push(chars.length > 0 ? chars[chars.length - 1].prevSpaces : 0);
          maxLineWidth = Math.max(maxLineWidth, lastBreakWidth);
          line++;
          pos.x = 0;
          pos.y += data.lineHeight;
          prevCharCode = null;
          spaceCount = 0;
        }
      }
      const lastChar = charsInput[charsInput.length - 1];
      if (lastChar !== "\r" && lastChar !== "\n") {
        if (/(?:\s)/.test(lastChar)) {
          lastLineWidth = lastBreakWidth;
        }
        lineWidths.push(lastLineWidth);
        maxLineWidth = Math.max(maxLineWidth, lastLineWidth);
        lineSpaces.push(-1);
      }
      const lineAlignOffsets = [];
      for (let i = 0; i <= line; i++) {
        let alignOffset = 0;
        if (this._align === "right") {
          alignOffset = maxLineWidth - lineWidths[i];
        } else if (this._align === "center") {
          alignOffset = (maxLineWidth - lineWidths[i]) / 2;
        } else if (this._align === "justify") {
          alignOffset = lineSpaces[i] < 0 ? 0 : (maxLineWidth - lineWidths[i]) / lineSpaces[i];
        }
        lineAlignOffsets.push(alignOffset);
      }
      const lenChars = chars.length;
      const pagesMeshData = {};
      const newPagesMeshData = [];
      const activePagesMeshData = this._activePagesMeshData;
      pageMeshDataPool.push(...activePagesMeshData);
      for (let i = 0; i < lenChars; i++) {
        const texture = chars[i].texture;
        const baseTextureUid = texture.baseTexture.uid;
        if (!pagesMeshData[baseTextureUid]) {
          let pageMeshData = pageMeshDataPool.pop();
          if (!pageMeshData) {
            const geometry = new MeshGeometry();
            let material;
            let meshBlendMode;
            if (data.distanceFieldType === "none") {
              material = new MeshMaterial(Texture.EMPTY);
              meshBlendMode = BLEND_MODES.NORMAL;
            } else {
              material = new MeshMaterial(Texture.EMPTY, { program: Program.from(msdfVert, msdfFrag), uniforms: { uFWidth: 0 } });
              meshBlendMode = BLEND_MODES.NORMAL_NPM;
            }
            const mesh = new Mesh(geometry, material);
            mesh.blendMode = meshBlendMode;
            pageMeshData = {
              index: 0,
              indexCount: 0,
              vertexCount: 0,
              uvsCount: 0,
              total: 0,
              mesh,
              vertices: null,
              uvs: null,
              indices: null
            };
          }
          pageMeshData.index = 0;
          pageMeshData.indexCount = 0;
          pageMeshData.vertexCount = 0;
          pageMeshData.uvsCount = 0;
          pageMeshData.total = 0;
          const { _textureCache } = this;
          _textureCache[baseTextureUid] = _textureCache[baseTextureUid] || new Texture(texture.baseTexture);
          pageMeshData.mesh.texture = _textureCache[baseTextureUid];
          pageMeshData.mesh.tint = this._tint;
          newPagesMeshData.push(pageMeshData);
          pagesMeshData[baseTextureUid] = pageMeshData;
        }
        pagesMeshData[baseTextureUid].total++;
      }
      for (let i = 0; i < activePagesMeshData.length; i++) {
        if (!newPagesMeshData.includes(activePagesMeshData[i])) {
          this.removeChild(activePagesMeshData[i].mesh);
        }
      }
      for (let i = 0; i < newPagesMeshData.length; i++) {
        if (newPagesMeshData[i].mesh.parent !== this) {
          this.addChild(newPagesMeshData[i].mesh);
        }
      }
      this._activePagesMeshData = newPagesMeshData;
      for (const i in pagesMeshData) {
        const pageMeshData = pagesMeshData[i];
        const total = pageMeshData.total;
        if (!(((_a = pageMeshData.indices) == null ? void 0 : _a.length) > 6 * total) || pageMeshData.vertices.length < Mesh.BATCHABLE_SIZE * 2) {
          pageMeshData.vertices = new Float32Array(4 * 2 * total);
          pageMeshData.uvs = new Float32Array(4 * 2 * total);
          pageMeshData.indices = new Uint16Array(6 * total);
        } else {
          const total2 = pageMeshData.total;
          const vertices = pageMeshData.vertices;
          for (let i2 = total2 * 4 * 2; i2 < vertices.length; i2++) {
            vertices[i2] = 0;
          }
        }
        pageMeshData.mesh.size = 6 * total;
      }
      for (let i = 0; i < lenChars; i++) {
        const char = chars[i];
        let offset = char.position.x + lineAlignOffsets[char.line] * (this._align === "justify" ? char.prevSpaces : 1);
        if (this._roundPixels) {
          offset = Math.round(offset);
        }
        const xPos = offset * scale;
        const yPos = char.position.y * scale;
        const texture = char.texture;
        const pageMesh = pagesMeshData[texture.baseTexture.uid];
        const textureFrame = texture.frame;
        const textureUvs = texture._uvs;
        const index2 = pageMesh.index++;
        pageMesh.indices[index2 * 6 + 0] = 0 + index2 * 4;
        pageMesh.indices[index2 * 6 + 1] = 1 + index2 * 4;
        pageMesh.indices[index2 * 6 + 2] = 2 + index2 * 4;
        pageMesh.indices[index2 * 6 + 3] = 0 + index2 * 4;
        pageMesh.indices[index2 * 6 + 4] = 2 + index2 * 4;
        pageMesh.indices[index2 * 6 + 5] = 3 + index2 * 4;
        pageMesh.vertices[index2 * 8 + 0] = xPos;
        pageMesh.vertices[index2 * 8 + 1] = yPos;
        pageMesh.vertices[index2 * 8 + 2] = xPos + textureFrame.width * scale;
        pageMesh.vertices[index2 * 8 + 3] = yPos;
        pageMesh.vertices[index2 * 8 + 4] = xPos + textureFrame.width * scale;
        pageMesh.vertices[index2 * 8 + 5] = yPos + textureFrame.height * scale;
        pageMesh.vertices[index2 * 8 + 6] = xPos;
        pageMesh.vertices[index2 * 8 + 7] = yPos + textureFrame.height * scale;
        pageMesh.uvs[index2 * 8 + 0] = textureUvs.x0;
        pageMesh.uvs[index2 * 8 + 1] = textureUvs.y0;
        pageMesh.uvs[index2 * 8 + 2] = textureUvs.x1;
        pageMesh.uvs[index2 * 8 + 3] = textureUvs.y1;
        pageMesh.uvs[index2 * 8 + 4] = textureUvs.x2;
        pageMesh.uvs[index2 * 8 + 5] = textureUvs.y2;
        pageMesh.uvs[index2 * 8 + 6] = textureUvs.x3;
        pageMesh.uvs[index2 * 8 + 7] = textureUvs.y3;
      }
      this._textWidth = maxLineWidth * scale;
      this._textHeight = (pos.y + data.lineHeight) * scale;
      for (const i in pagesMeshData) {
        const pageMeshData = pagesMeshData[i];
        if (this.anchor.x !== 0 || this.anchor.y !== 0) {
          let vertexCount = 0;
          const anchorOffsetX = this._textWidth * this.anchor.x;
          const anchorOffsetY = this._textHeight * this.anchor.y;
          for (let i2 = 0; i2 < pageMeshData.total; i2++) {
            pageMeshData.vertices[vertexCount++] -= anchorOffsetX;
            pageMeshData.vertices[vertexCount++] -= anchorOffsetY;
            pageMeshData.vertices[vertexCount++] -= anchorOffsetX;
            pageMeshData.vertices[vertexCount++] -= anchorOffsetY;
            pageMeshData.vertices[vertexCount++] -= anchorOffsetX;
            pageMeshData.vertices[vertexCount++] -= anchorOffsetY;
            pageMeshData.vertices[vertexCount++] -= anchorOffsetX;
            pageMeshData.vertices[vertexCount++] -= anchorOffsetY;
          }
        }
        this._maxLineHeight = maxLineHeight * scale;
        const vertexBuffer = pageMeshData.mesh.geometry.getBuffer("aVertexPosition");
        const textureBuffer = pageMeshData.mesh.geometry.getBuffer("aTextureCoord");
        const indexBuffer = pageMeshData.mesh.geometry.getIndex();
        vertexBuffer.data = pageMeshData.vertices;
        textureBuffer.data = pageMeshData.uvs;
        indexBuffer.data = pageMeshData.indices;
        vertexBuffer.update();
        textureBuffer.update();
        indexBuffer.update();
      }
      for (let i = 0; i < chars.length; i++) {
        charRenderDataPool.push(chars[i]);
      }
      this._font = data;
      this.dirty = false;
    }
    updateTransform() {
      this.validate();
      this.containerUpdateTransform();
    }
    _render(renderer) {
      if (this._autoResolution && this._resolution !== renderer.resolution) {
        this._resolution = renderer.resolution;
        this.dirty = true;
      }
      const { distanceFieldRange, distanceFieldType, size } = BitmapFont.available[this._fontName];
      if (distanceFieldType !== "none") {
        const { a: a2, b, c: c2, d } = this.worldTransform;
        const dx = Math.sqrt(a2 * a2 + b * b);
        const dy = Math.sqrt(c2 * c2 + d * d);
        const worldScale = (Math.abs(dx) + Math.abs(dy)) / 2;
        const fontScale = this.fontSize / size;
        const resolution = renderer._view.resolution;
        for (const mesh of this._activePagesMeshData) {
          mesh.mesh.shader.uniforms.uFWidth = worldScale * distanceFieldRange * fontScale * resolution;
        }
      }
      super._render(renderer);
    }
    getLocalBounds() {
      this.validate();
      return super.getLocalBounds();
    }
    validate() {
      const font = BitmapFont.available[this._fontName];
      if (!font) {
        throw new Error(`Missing BitmapFont "${this._fontName}"`);
      }
      if (this._font !== font) {
        this.dirty = true;
      }
      if (this.dirty) {
        this.updateText();
      }
    }
    get tint() {
      return this._tint;
    }
    set tint(value) {
      if (this._tint === value)
        return;
      this._tint = value;
      for (let i = 0; i < this._activePagesMeshData.length; i++) {
        this._activePagesMeshData[i].mesh.tint = value;
      }
    }
    get align() {
      return this._align;
    }
    set align(value) {
      if (this._align !== value) {
        this._align = value;
        this.dirty = true;
      }
    }
    get fontName() {
      return this._fontName;
    }
    set fontName(value) {
      if (!BitmapFont.available[value]) {
        throw new Error(`Missing BitmapFont "${value}"`);
      }
      if (this._fontName !== value) {
        this._fontName = value;
        this.dirty = true;
      }
    }
    get fontSize() {
      var _a;
      return (_a = this._fontSize) != null ? _a : BitmapFont.available[this._fontName].size;
    }
    set fontSize(value) {
      if (this._fontSize !== value) {
        this._fontSize = value;
        this.dirty = true;
      }
    }
    get anchor() {
      return this._anchor;
    }
    set anchor(value) {
      if (typeof value === "number") {
        this._anchor.set(value);
      } else {
        this._anchor.copyFrom(value);
      }
    }
    get text() {
      return this._text;
    }
    set text(text) {
      text = String(text === null || text === void 0 ? "" : text);
      if (this._text === text) {
        return;
      }
      this._text = text;
      this.dirty = true;
    }
    get maxWidth() {
      return this._maxWidth;
    }
    set maxWidth(value) {
      if (this._maxWidth === value) {
        return;
      }
      this._maxWidth = value;
      this.dirty = true;
    }
    get maxLineHeight() {
      this.validate();
      return this._maxLineHeight;
    }
    get textWidth() {
      this.validate();
      return this._textWidth;
    }
    get letterSpacing() {
      return this._letterSpacing;
    }
    set letterSpacing(value) {
      if (this._letterSpacing !== value) {
        this._letterSpacing = value;
        this.dirty = true;
      }
    }
    get roundPixels() {
      return this._roundPixels;
    }
    set roundPixels(value) {
      if (value !== this._roundPixels) {
        this._roundPixels = value;
        this.dirty = true;
      }
    }
    get textHeight() {
      this.validate();
      return this._textHeight;
    }
    get resolution() {
      return this._resolution;
    }
    set resolution(value) {
      this._autoResolution = false;
      if (this._resolution === value) {
        return;
      }
      this._resolution = value;
      this.dirty = true;
    }
    destroy(options) {
      const { _textureCache } = this;
      const data = BitmapFont.available[this._fontName];
      const pageMeshDataPool = data.distanceFieldType === "none" ? pageMeshDataDefaultPageMeshData : pageMeshDataMSDFPageMeshData;
      pageMeshDataPool.push(...this._activePagesMeshData);
      for (const pageMeshData of this._activePagesMeshData) {
        this.removeChild(pageMeshData.mesh);
      }
      this._activePagesMeshData = [];
      pageMeshDataPool.filter((page) => _textureCache[page.mesh.texture.baseTexture.uid]).forEach((page) => {
        page.mesh.texture = Texture.EMPTY;
      });
      for (const id2 in _textureCache) {
        const texture = _textureCache[id2];
        texture.destroy();
        delete _textureCache[id2];
      }
      this._font = null;
      this._textureCache = null;
      super.destroy(options);
    }
  };
  var BitmapText = _BitmapText;
  BitmapText.styleDefaults = {
    align: "left",
    tint: 16777215,
    maxWidth: 0,
    letterSpacing: 0
  };

  // node_modules/pixijs/text-bitmap/loadBitmapFont.mjs
  var validExtensions = [".xml", ".fnt"];
  var loadBitmapFont = {
    extension: {
      type: ExtensionType.LoadParser,
      priority: LoaderParserPriority.Normal
    },
    test(url2) {
      return validExtensions.includes(utils_exports.path.extname(url2).toLowerCase());
    },
    async testParse(data) {
      return TextFormat.test(data) || XMLStringFormat.test(data);
    },
    async parse(asset, data, loader) {
      const fontData = TextFormat.test(asset) ? TextFormat.parse(asset) : XMLStringFormat.parse(asset);
      const { src } = data;
      const { page: pages } = fontData;
      const textureUrls = [];
      for (let i = 0; i < pages.length; ++i) {
        const pageFile = pages[i].file;
        let imagePath = utils_exports.path.join(utils_exports.path.dirname(src), pageFile);
        imagePath = copySearchParams(imagePath, src);
        textureUrls.push(imagePath);
      }
      const loadedTextures = await loader.load(textureUrls);
      const textures = textureUrls.map((url2) => loadedTextures[url2]);
      return BitmapFont.install(fontData, textures, true);
    },
    async load(url2, _options) {
      const response = await settings.ADAPTER.fetch(url2);
      return response.text();
    },
    unload(bitmapFont) {
      bitmapFont.destroy();
    }
  };
  extensions.add(loadBitmapFont);

  // src/simulation.ts
  var Simulation = class {
    constructor(parentElementId, options) {
      this.options = options;
      this.labelParent = select_default2("#label");
      this.parent = document.getElementById(parentElementId);
      if (!this.parent)
        throw new Error("Parent element is missing.");
      this.app = new Application({ antialias: true, resizeTo: parent, resolution: window.devicePixelRatio });
      this.parent.appendChild(this.app.view);
      this.graphics = new Graphics();
      this.updateSize();
    }
    updateSize() {
      this.width = this.parent.offsetWidth;
      this.height = this.parent.offsetHeight;
      this.halfWidth = this.width / 2;
      this.halfHeight = this.height / 2;
    }
    create(nodes, links, forces) {
      this.simulation = simulation_default(nodes).alphaDecay(1e-3).velocityDecay(0.55);
      this.updateSim({ nodes, forces });
      this.simulation.on("tick", () => this.tick({ nodes, links }));
    }
    updateSim({ nodes, forces }) {
      this.simulation.nodes(nodes);
      forces.forEach(({ name, f }) => {
        this.simulation.force(name, f);
      });
      this.simulation.alpha(1).restart();
    }
    tick({ nodes, links }) {
      const graphics = this.graphics;
      graphics.clear();
      const fx = (x3) => x3 + this.halfWidth;
      const fy = (y3) => y3 + this.halfHeight;
      for (const [i, link] of links.entries()) {
        graphics.lineStyle({ width: 1, color: link.color });
        graphics.moveTo(fx(link.source.x), fy(link.source.y));
        graphics.lineTo(fx(link.target.x), fy(link.target.y));
        graphics.endFill();
      }
      for (const [i, node] of nodes.entries()) {
        graphics.lineStyle(0);
        graphics.beginFill(node.color, 1);
        graphics.drawCircle(fx(node.x), fy(node.y), node.r);
        graphics.endFill();
      }
      this.app.stage.addChild(graphics);
      this.labelElements.style("left", (d) => d.x + this.halfWidth + d.r + 5 + "px").style("top", (d) => d.y + this.halfHeight + "px");
    }
    drawLabels(labeledNodes, className = "") {
      this.labelParent.attr("class", className);
      this.labelElements = select_default2("#label").selectAll("div.label").data(labeledNodes, (d) => d.id).join("div").attr("class", (d) => "label " + d.class).style("display", "block");
      const nodeType = {
        measure: "mutat\xF3",
        dataset: "adatk\xF6r",
        dimension: "dimenzi\xF3",
        element: "elem"
      };
      this.labelElements.selectAll("div").remove();
      this.labelElements.append("div").attr("class", "type").text((d) => nodeType[d.class]);
      this.labelElements.append("div").attr("class", "name").text((d) => d.name);
    }
    stop() {
      this.simulation.alpha(0);
    }
    restart() {
      this.simulation.velocityDecay();
      this.simulation.alpha(1).restart();
    }
  };

  // src/story.ts
  var import_scrollama = __toESM(require_scrollama(), 1);
  var Story = class {
    constructor(selector) {
      const scroller = (0, import_scrollama.default)();
      scroller.setup({
        step: selector,
        offset: 0.7,
        progress: true
      }).onStepEnter(({ element, index: index2, direction }) => {
        select_default2(element).classed("active", true);
        this.steps[index2](direction);
      }).onStepExit(({ element, index: index2, direction }) => {
        select_default2(element).classed("active", false);
      });
      window.addEventListener("resize", scroller.resize);
    }
  };
  var SimulationStory = class extends Story {
    constructor(selector, elementId) {
      super(selector);
      const nodeRadius = (d) => d.mutato && 40 || d.dataset && 20 || d.dimension && 10 || 5;
      this.simulation = new Simulation(elementId, { nodeRadius });
    }
    initSim(nodes, links, forces) {
      this.simulation.create(nodes, links, forces);
      this.nodes = nodes;
      this.links = links;
      this.forces = forces;
    }
  };

  // src/NszMetaStory.ts
  var _ = __toESM(require_lodash(), 1);
  var NszMetaStory = class extends SimulationStory {
    createSteps(initForces) {
      const f = (name, f2) => ({ name, f: f2 });
      let xyf;
      let radius;
      let height, width;
      let m2;
      const updateSize = () => {
        this.simulation.updateSize();
        width = this.simulation.width;
        height = this.simulation.height;
        m2 = Math.min(width, height);
        xyf = 0.09 * Math.sqrt(m2 / 1e3);
        const nodeRadius = (d) => d.mutato && m2 / 25 || d.dataset && m2 / 45 || d.dimension && m2 / 85 || Math.max(m2 / 190, 3);
        this.nodes.forEach((n) => n.r = nodeRadius(n));
        radius = m2 / 2.6;
      };
      updateSize();
      window.addEventListener("resize", updateSize);
      const getHierarchy = (direction) => (links, elementId, depth) => {
        const nodeResult = [];
        const linkResult = [];
        switch (direction) {
          case "down":
            walk(elementId, "source", "target", depth);
            break;
          case "up":
            walk(elementId, "target", "source", depth);
            break;
          default:
            walk(elementId, "source", "target", depth);
            walk(elementId, "target", "source", depth);
        }
        function walk(id2, p1, p2, depth2) {
          nodeResult.push(id2);
          if (depth2 === 0)
            return;
          links.filter((link) => link[p1].id === id2).forEach((link) => {
            linkResult.push(link.id);
            walk(link[p2].id, p1, p2, depth2 - 1);
          });
        }
        return [_.uniq(nodeResult), _.uniq(linkResult)];
      };
      const getIdsDown = getHierarchy("down");
      const getIdsUp = getHierarchy("up");
      const getIds = getHierarchy("all");
      const forcesToCenter = (ids, links, c2, forces = {}) => {
        const includes = ids == "all" ? () => true : (id2) => ids.includes(id2);
        const chargeForceStrength = (scale) => (d) => {
          const charge = {
            measure: -1e3,
            dataset: -250,
            dimension: -100,
            element: -12
          };
          if (includes(d.id)) {
            return charge[d.class] * scale;
          }
          return 0;
        };
        const defaultForces = {
          radial: radial_default(radius).x(width > height ? width / 7.5 : 0).strength((d) => includes(d.id) ? 0 : 0.1),
          collision: collide_default().radius((d) => d.r).iterations(2),
          charge: manyBody_default().strength(chargeForceStrength(radius * c2)),
          x: x_default2().x(width > height ? width / 7.5 : 0).strength((d) => includes(d.id) ? xyf : 0),
          y: y_default2().y(0).strength((d) => includes(d.id) ? xyf : 0),
          links: link_default(links).id((d) => d.id).strength((d) => (d.elem2elem || d.dim2elem) && 0.29 || d.dataset2dim && 0.12 || 0.16)
        };
        const newForces = __spreadValues(__spreadValues({}, defaultForces), forces);
        return Object.keys(newForces).map((name) => f(name, newForces[name]));
      };
      let timeout2;
      const center = ({ nodeIds, linkFilter, c: c2, forces = {}, postFn = void 0, labelFilter = void 0, stopAfter = void 0 }) => () => {
        clearTimeout(timeout2);
        if (stopAfter) {
          timeout2 = setTimeout(() => this.simulation.stop(), stopAfter);
        }
        const { nodes, links } = this;
        const activeLinks = links.filter(linkFilter);
        const linkIds = activeLinks.map((l) => l.id);
        const newForces = forcesToCenter(nodeIds, activeLinks, c2, forces);
        const labeledNodes = labelFilter ? nodes.filter(labelFilter) : [];
        this.simulation.drawLabels(labeledNodes);
        this.simulation.updateSim({ nodes, forces: newForces });
        const color2 = (n) => {
          return n.mutato && 341894 || n.dataset && 15560083 || n.dimension && 16697872 || n.element && 10292750 || 3355443;
        };
        for (const [i, node] of nodes.entries()) {
          node.color = nodeIds.includes(node.id) ? color2(node) : 2236962;
        }
        for (const [i, link] of links.entries()) {
          link.color = linkIds.includes(link.id) ? 5224792 : 0;
        }
        select_default2("div.story").classed("hover", false);
        select_default2("body").attr("class", "matyo-2 dim");
        if (postFn)
          postFn();
      };
      const hierarchy = (from, depth, c2, forces = {}) => (direction) => {
        if (direction === "up") {
          this.nodes.forEach((d) => {
            delete d.fx;
            delete d.fy;
          });
        }
        const [nodeIdsDown, linksDown] = getIdsDown(this.links, from, depth);
        center({ nodeIds: nodeIdsDown, linkFilter: (l) => linksDown.includes(l.id), c: c2, forces })();
      };
      const allIds = this.nodes.map((d) => d.id);
      const centerForces = (nodeIds, links) => ({
        charge: manyBody_default().strength((d) => nodeIds.includes(d.id) ? d.mutato ? -10 : -60 : 0),
        links: link_default(links).id((d) => d.id).strength((d) => (d.elem2elem || d.dim2elem) && xyf || d.dataset2dim && xyf || xyf),
        y: y_default2((d) => d.mutato && -m2 / 5 || d.dataset && -m2 / 15 || d.dimension && m2 / 20 || d.element && m2 / 5).strength((d) => nodeIds.includes(d.id) ? xyf : 0)
      });
      return [
        center({ nodeIds: allIds, linkFilter: () => true, c: 2e-3, forces: { radial: null } }),
        center({ nodeIds: allIds, linkFilter: () => true, c: 2e-3, forces: { radial: null } }),
        center({
          nodeIds: ["fo"],
          linkFilter: () => false,
          c: 6e-3,
          forces: centerForces(["fo"], []),
          labelFilter: (n) => n.id === "fo"
        }),
        () => {
          const nodeIds = ["fo", "WB1A08"];
          const linkFilter = (l) => l.source.id === "fo" && l.target.id === "WB1A08";
          const forces = centerForces(nodeIds, this.links.filter(linkFilter));
          center({
            nodeIds,
            linkFilter,
            c: 6e-3,
            forces,
            labelFilter: (n) => ["fo", "WB1A08"].includes(n.id)
          })();
        },
        () => {
          const nodeIds = ["fo", "WB1A08", "YN01B"];
          const linkFilter = (l) => l.source.id === "fo" && l.target.id === "WB1A08" || l.source.id === "WB1A08" && l.target.id === "YN01B";
          const forces = centerForces(nodeIds, this.links.filter(linkFilter));
          center({
            nodeIds,
            forces,
            linkFilter,
            c: 6e-3,
            labelFilter: (n) => nodeIds.includes(n.id)
          })();
        },
        () => {
          const nodeIds = ["fo", "WB1A08", "YN01B", "YN01B-T", "YN01B-F", "YN01B-M"];
          const linkFilter = (l) => l.source.id === "fo" && l.target.id === "WB1A08" || l.source.id === "WB1A08" && l.target.id === "YN01B" || l.source.id === "YN01B" || l.source.id === "YN01B-T";
          const forces = centerForces(nodeIds, this.links.filter(linkFilter));
          center({
            nodeIds,
            forces,
            linkFilter,
            c: 6e-3,
            labelFilter: (n) => nodeIds.includes(n.id)
          })();
        },
        hierarchy("fo", 1, 4e-3),
        hierarchy("fo", 2, 4e-3),
        hierarchy("fo", 2, 4e-3),
        hierarchy("fo", 5, 2e-3),
        hierarchy("fo", 7, 2e-3),
        center({
          nodeIds: allIds,
          linkFilter: () => true,
          c: 2e-3,
          forces: { radial: null },
          postFn: () => {
            select_default2("body").attr("class", "matyo-2 dim sub");
            select_default2("div.story").classed("hover", true);
            const { nodeElements, linkElements, links, simulation } = this;
            simulation.getSvg().on("click", deselect);
            let selectedNode;
            nodeElements.on("mousemove", (e, d) => {
              simulation.drawLabels([d], "withBg");
            });
            nodeElements.on("mouseleave", () => {
              simulation.drawLabels([]);
            });
            nodeElements.on("click", (e, d) => {
              if (selectedNode === d.id) {
                deselect();
              } else {
                const [nodeIds, linkIds] = getIds(links, d.id, 100);
                nodeElements.classed("highlighted", (d2) => nodeIds.includes(d2.id));
                linkElements.classed("highlighted", (d2) => linkIds.includes(d2.id));
                selectedNode = d.id;
              }
              e.stopPropagation();
            });
            function deselect() {
              nodeElements.classed("highlighted", true);
              linkElements.classed("highlighted", true);
              selectedNode = null;
            }
            const drag = drag_default().on("drag", dragged);
            this.nodeElements.call(drag).on("dblclick", dblclick);
            function dblclick(e, d) {
              delete d.fx;
              delete d.fy;
              simulation.restart();
            }
            function dragstart() {
            }
            function dragged(event, d) {
              d.fx = event.x;
              d.fy = event.y;
              simulation.restart();
            }
          }
        })
      ];
    }
    create(nodes, links) {
      const f = (name, f2) => ({ name, f: f2 });
      const forces = [];
      this.initSim(nodes, links, forces);
      this.steps = this.createSteps(forces);
    }
  };

  // src/app.ts
  app();
  async function app() {
    const setFontSize = () => {
      const { innerWidth, innerHeight } = window;
      const m2 = Math.min(innerHeight, innerWidth);
      const c2 = 0.04;
      document.body.style.fontSize = Math.max(m2 * c2, 20) + "px";
    };
    setFontSize();
    window.addEventListener("resize", setFontSize);
    const { nodes, links } = await getData();
    const story = new NszMetaStory(".step", "canvas");
    story.create(nodes, links);
  }
})();
/*! https://mths.be/punycode v1.3.2 by @mathias */
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
